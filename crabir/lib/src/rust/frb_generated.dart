// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/simple.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'third_party/reddit_api/client.dart';
import 'third_party/reddit_api/model.dart';
import 'third_party/reddit_api/model/author.dart';
import 'third_party/reddit_api/model/comment.dart';
import 'third_party/reddit_api/model/feed.dart';
import 'third_party/reddit_api/model/flair.dart';
import 'third_party/reddit_api/model/gallery.dart';
import 'third_party/reddit_api/model/multi.dart';
import 'third_party/reddit_api/model/post.dart';
import 'third_party/reddit_api/model/subreddit.dart';
import 'third_party/reddit_api/model/user/model.dart';
import 'third_party/reddit_api/search.dart';
import 'third_party/reddit_api/streamable.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiSimpleInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 1596579972;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_crabir',
    ioDirectory: '../crabir_bridge/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<void> redditApiClientClientAuthenticate(
      {required Client that, required String refreshToken});

  Future<(Post, List<Thing>)> redditApiClientClientComments(
      {required Client that, required String permalink, CommentSort? sort});

  Future<Client> redditApiClientClientDefault();

  Streamable redditApiClientClientFeedStream(
      {required Client that, required Feed feed, required FeedSort sort});

  Future<Client> redditApiClientClientFromRefreshToken(
      {required String refreshToken});

  Future<Post> redditApiClientClientGetPost(
      {required Client that, required String permalink});

  Future<List<Thing>> redditApiClientClientLoadMoreComments(
      {required Client that,
      required Fullname parentId,
      required List<String> children,
      CommentSort? sort});

  Future<UserInfo> redditApiClientClientLoggedUserInfo({required Client that});

  Streamable redditApiClientClientMultiPosts(
      {required Client that, required Multi multi, required FeedSort sort});

  Future<List<Multi>> redditApiClientClientMultis({required Client that});

  Future<Client> redditApiClientClientNewAnonymous();

  Future<void> redditApiClientClientNewLoggedOutUserToken(
      {required Client that});

  Future<void> redditApiClientClientSave(
      {required Client that, required Fullname thing});

  Streamable redditApiClientClientSearchPost(
      {required Client that,
      String? subreddit,
      Flair? flair,
      String? query,
      required PostSearchSort sort});

  Streamable redditApiClientClientSearchSubreddits(
      {required Client that,
      required String query,
      required SubredditSearchSort sort});

  Future<List<Subreddit>> redditApiClientClientSubsriptions(
      {required Client that});

  Future<void> redditApiClientClientUnsave(
      {required Client that, required Fullname thing});

  Future<UserInfo> redditApiClientClientUserAbout(
      {required Client that, required String username});

  Streamable redditApiClientClientUserComments(
      {required Client that,
      required String username,
      required UserStreamSort sort});

  Streamable redditApiClientClientUserDownvoted(
      {required Client that, required String username});

  Streamable redditApiClientClientUserGilded(
      {required Client that, required String username});

  Streamable redditApiClientClientUserHidden(
      {required Client that, required String username});

  Streamable redditApiClientClientUserOverview(
      {required Client that,
      required String username,
      required UserStreamSort sort});

  Streamable redditApiClientClientUserSaved(
      {required Client that, required String username});

  Streamable redditApiClientClientUserSubmitted(
      {required Client that,
      required String username,
      required UserStreamSort sort});

  Streamable redditApiClientClientUserUpvoted(
      {required Client that, required String username});

  Future<void> redditApiClientClientVote(
      {required Client that,
      required Fullname fullname,
      required VoteDirection direction});

  bool redditApiModelCommentCommentAutoAccessorGetArchived(
      {required Comment that});

  AuthorInfo? redditApiModelCommentCommentAutoAccessorGetAuthor(
      {required Comment that});

  String redditApiModelCommentCommentAutoAccessorGetBody(
      {required Comment that});

  String redditApiModelCommentCommentAutoAccessorGetBodyHtml(
      {required Comment that});

  bool redditApiModelCommentCommentAutoAccessorGetCanGild(
      {required Comment that});

  bool redditApiModelCommentCommentAutoAccessorGetCanModPost(
      {required Comment that});

  bool redditApiModelCommentCommentAutoAccessorGetCollapsed(
      {required Comment that});

  int redditApiModelCommentCommentAutoAccessorGetControversiality(
      {required Comment that});

  DateTime redditApiModelCommentCommentAutoAccessorGetCreated(
      {required Comment that});

  DateTime redditApiModelCommentCommentAutoAccessorGetCreatedUtc(
      {required Comment that});

  int redditApiModelCommentCommentAutoAccessorGetDepth({required Comment that});

  String? redditApiModelCommentCommentAutoAccessorGetDistinguished(
      {required Comment that});

  int redditApiModelCommentCommentAutoAccessorGetDowns({required Comment that});

  double? redditApiModelCommentCommentAutoAccessorGetEdited(
      {required Comment that});

  int redditApiModelCommentCommentAutoAccessorGetGilded(
      {required Comment that});

  String redditApiModelCommentCommentAutoAccessorGetId({required Comment that});

  bool redditApiModelCommentCommentAutoAccessorGetIsSubmitter(
      {required Comment that});

  bool? redditApiModelCommentCommentAutoAccessorGetLikes(
      {required Comment that});

  String redditApiModelCommentCommentAutoAccessorGetLinkId(
      {required Comment that});

  bool redditApiModelCommentCommentAutoAccessorGetLocked(
      {required Comment that});

  Fullname redditApiModelCommentCommentAutoAccessorGetName(
      {required Comment that});

  bool redditApiModelCommentCommentAutoAccessorGetNoFollow(
      {required Comment that});

  String redditApiModelCommentCommentAutoAccessorGetParentId(
      {required Comment that});

  String redditApiModelCommentCommentAutoAccessorGetPermalink(
      {required Comment that});

  bool redditApiModelCommentCommentAutoAccessorGetSaved(
      {required Comment that});

  int redditApiModelCommentCommentAutoAccessorGetScore({required Comment that});

  bool redditApiModelCommentCommentAutoAccessorGetScoreHidden(
      {required Comment that});

  bool redditApiModelCommentCommentAutoAccessorGetSendReplies(
      {required Comment that});

  bool redditApiModelCommentCommentAutoAccessorGetStickied(
      {required Comment that});

  String redditApiModelCommentCommentAutoAccessorGetSubreddit(
      {required Comment that});

  String redditApiModelCommentCommentAutoAccessorGetSubredditId(
      {required Comment that});

  String redditApiModelCommentCommentAutoAccessorGetSubredditNamePrefixed(
      {required Comment that});

  String redditApiModelCommentCommentAutoAccessorGetSubredditType(
      {required Comment that});

  int redditApiModelCommentCommentAutoAccessorGetUps({required Comment that});

  void redditApiModelCommentCommentAutoAccessorSetArchived(
      {required Comment that, required bool archived});

  void redditApiModelCommentCommentAutoAccessorSetAuthor(
      {required Comment that, AuthorInfo? author});

  void redditApiModelCommentCommentAutoAccessorSetBody(
      {required Comment that, required String body});

  void redditApiModelCommentCommentAutoAccessorSetBodyHtml(
      {required Comment that, required String bodyHtml});

  void redditApiModelCommentCommentAutoAccessorSetCanGild(
      {required Comment that, required bool canGild});

  void redditApiModelCommentCommentAutoAccessorSetCanModPost(
      {required Comment that, required bool canModPost});

  void redditApiModelCommentCommentAutoAccessorSetCollapsed(
      {required Comment that, required bool collapsed});

  void redditApiModelCommentCommentAutoAccessorSetControversiality(
      {required Comment that, required int controversiality});

  void redditApiModelCommentCommentAutoAccessorSetCreated(
      {required Comment that, required DateTime created});

  void redditApiModelCommentCommentAutoAccessorSetCreatedUtc(
      {required Comment that, required DateTime createdUtc});

  void redditApiModelCommentCommentAutoAccessorSetDepth(
      {required Comment that, required int depth});

  void redditApiModelCommentCommentAutoAccessorSetDistinguished(
      {required Comment that, String? distinguished});

  void redditApiModelCommentCommentAutoAccessorSetDowns(
      {required Comment that, required int downs});

  void redditApiModelCommentCommentAutoAccessorSetEdited(
      {required Comment that, double? edited});

  void redditApiModelCommentCommentAutoAccessorSetGilded(
      {required Comment that, required int gilded});

  void redditApiModelCommentCommentAutoAccessorSetId(
      {required Comment that, required String id});

  void redditApiModelCommentCommentAutoAccessorSetIsSubmitter(
      {required Comment that, required bool isSubmitter});

  void redditApiModelCommentCommentAutoAccessorSetLikes(
      {required Comment that, bool? likes});

  void redditApiModelCommentCommentAutoAccessorSetLinkId(
      {required Comment that, required String linkId});

  void redditApiModelCommentCommentAutoAccessorSetLocked(
      {required Comment that, required bool locked});

  void redditApiModelCommentCommentAutoAccessorSetName(
      {required Comment that, required Fullname name});

  void redditApiModelCommentCommentAutoAccessorSetNoFollow(
      {required Comment that, required bool noFollow});

  void redditApiModelCommentCommentAutoAccessorSetParentId(
      {required Comment that, required String parentId});

  void redditApiModelCommentCommentAutoAccessorSetPermalink(
      {required Comment that, required String permalink});

  void redditApiModelCommentCommentAutoAccessorSetSaved(
      {required Comment that, required bool saved});

  void redditApiModelCommentCommentAutoAccessorSetScore(
      {required Comment that, required int score});

  void redditApiModelCommentCommentAutoAccessorSetScoreHidden(
      {required Comment that, required bool scoreHidden});

  void redditApiModelCommentCommentAutoAccessorSetSendReplies(
      {required Comment that, required bool sendReplies});

  void redditApiModelCommentCommentAutoAccessorSetStickied(
      {required Comment that, required bool stickied});

  void redditApiModelCommentCommentAutoAccessorSetSubreddit(
      {required Comment that, required String subreddit});

  void redditApiModelCommentCommentAutoAccessorSetSubredditId(
      {required Comment that, required String subredditId});

  void redditApiModelCommentCommentAutoAccessorSetSubredditNamePrefixed(
      {required Comment that, required String subredditNamePrefixed});

  void redditApiModelCommentCommentAutoAccessorSetSubredditType(
      {required Comment that, required String subredditType});

  void redditApiModelCommentCommentAutoAccessorSetUps(
      {required Comment that, required int ups});

  Future<Comment> redditApiModelCommentCommentDefault();

  void redditApiModelCommentCommentReplaceMore(
      {required Comment that,
      required Thing more,
      required List<Thing> newThings});

  List<Thing> redditApiModelCommentCommentReplies({required Comment that});

  Future<void> redditApiModelCommentCommentSave(
      {required Comment that, required Client client});

  Future<void> redditApiModelCommentCommentUnsave(
      {required Comment that, required Client client});

  Future<void> redditApiModelCommentCommentVote(
      {required Comment that,
      required VoteDirection direction,
      required Client client});

  bool redditApiModelSubredditCommonAutoAccessorGetAcceptFollowers(
      {required Common that});

  List<String>
      redditApiModelSubredditCommonAutoAccessorGetAllowedMediaInComments(
          {required Common that});

  String? redditApiModelSubredditCommonAutoAccessorGetBannerImg(
      {required Common that});

  Int64List? redditApiModelSubredditCommonAutoAccessorGetBannerSize(
      {required Common that});

  double redditApiModelSubredditCommonAutoAccessorGetCreated(
      {required Common that});

  double redditApiModelSubredditCommonAutoAccessorGetCreatedUtc(
      {required Common that});

  bool redditApiModelSubredditCommonAutoAccessorGetDisableContributorRequests(
      {required Common that});

  String redditApiModelSubredditCommonAutoAccessorGetDisplayName(
      {required Common that});

  String redditApiModelSubredditCommonAutoAccessorGetDisplayNamePrefixed(
      {required Common that});

  bool redditApiModelSubredditCommonAutoAccessorGetFreeFormReports(
      {required Common that});

  String? redditApiModelSubredditCommonAutoAccessorGetHeaderImg(
      {required Common that});

  Int64List? redditApiModelSubredditCommonAutoAccessorGetHeaderSize(
      {required Common that});

  String? redditApiModelSubredditCommonAutoAccessorGetKeyColor(
      {required Common that});

  bool redditApiModelSubredditCommonAutoAccessorGetLinkFlairEnabled(
      {required Common that});

  String? redditApiModelSubredditCommonAutoAccessorGetLinkFlairPosition(
      {required Common that});

  Fullname redditApiModelSubredditCommonAutoAccessorGetName(
      {required Common that});

  String? redditApiModelSubredditCommonAutoAccessorGetPrimaryColor(
      {required Common that});

  String? redditApiModelSubredditCommonAutoAccessorGetPublicDescription(
      {required Common that});

  bool redditApiModelSubredditCommonAutoAccessorGetQuarantine(
      {required Common that});

  bool redditApiModelSubredditCommonAutoAccessorGetRestrictCommenting(
      {required Common that});

  bool redditApiModelSubredditCommonAutoAccessorGetRestrictPosting(
      {required Common that});

  bool redditApiModelSubredditCommonAutoAccessorGetShowMedia(
      {required Common that});

  String? redditApiModelSubredditCommonAutoAccessorGetSubmitLinkLabel(
      {required Common that});

  String? redditApiModelSubredditCommonAutoAccessorGetSubmitTextLabel(
      {required Common that});

  String? redditApiModelSubredditCommonAutoAccessorGetSubredditType(
      {required Common that});

  PlatformInt64 redditApiModelSubredditCommonAutoAccessorGetSubscribers(
      {required Common that});

  String? redditApiModelSubredditCommonAutoAccessorGetTitle(
      {required Common that});

  String redditApiModelSubredditCommonAutoAccessorGetUrl(
      {required Common that});

  bool redditApiModelSubredditCommonAutoAccessorGetUserIsBanned(
      {required Common that});

  bool redditApiModelSubredditCommonAutoAccessorGetUserIsContributor(
      {required Common that});

  bool redditApiModelSubredditCommonAutoAccessorGetUserIsModerator(
      {required Common that});

  bool redditApiModelSubredditCommonAutoAccessorGetUserIsMuted(
      {required Common that});

  bool redditApiModelSubredditCommonAutoAccessorGetUserIsSubscriber(
      {required Common that});

  void redditApiModelSubredditCommonAutoAccessorSetAcceptFollowers(
      {required Common that, required bool acceptFollowers});

  void redditApiModelSubredditCommonAutoAccessorSetAllowedMediaInComments(
      {required Common that, required List<String> allowedMediaInComments});

  void redditApiModelSubredditCommonAutoAccessorSetBannerImg(
      {required Common that, String? bannerImg});

  void redditApiModelSubredditCommonAutoAccessorSetBannerSize(
      {required Common that, Int64List? bannerSize});

  void redditApiModelSubredditCommonAutoAccessorSetCreated(
      {required Common that, required double created});

  void redditApiModelSubredditCommonAutoAccessorSetCreatedUtc(
      {required Common that, required double createdUtc});

  void redditApiModelSubredditCommonAutoAccessorSetDisableContributorRequests(
      {required Common that, required bool disableContributorRequests});

  void redditApiModelSubredditCommonAutoAccessorSetDisplayName(
      {required Common that, required String displayName});

  void redditApiModelSubredditCommonAutoAccessorSetDisplayNamePrefixed(
      {required Common that, required String displayNamePrefixed});

  void redditApiModelSubredditCommonAutoAccessorSetFreeFormReports(
      {required Common that, required bool freeFormReports});

  void redditApiModelSubredditCommonAutoAccessorSetHeaderImg(
      {required Common that, String? headerImg});

  void redditApiModelSubredditCommonAutoAccessorSetHeaderSize(
      {required Common that, Int64List? headerSize});

  void redditApiModelSubredditCommonAutoAccessorSetKeyColor(
      {required Common that, String? keyColor});

  void redditApiModelSubredditCommonAutoAccessorSetLinkFlairEnabled(
      {required Common that, required bool linkFlairEnabled});

  void redditApiModelSubredditCommonAutoAccessorSetLinkFlairPosition(
      {required Common that, String? linkFlairPosition});

  void redditApiModelSubredditCommonAutoAccessorSetName(
      {required Common that, required Fullname name});

  void redditApiModelSubredditCommonAutoAccessorSetPrimaryColor(
      {required Common that, String? primaryColor});

  void redditApiModelSubredditCommonAutoAccessorSetPublicDescription(
      {required Common that, String? publicDescription});

  void redditApiModelSubredditCommonAutoAccessorSetQuarantine(
      {required Common that, required bool quarantine});

  void redditApiModelSubredditCommonAutoAccessorSetRestrictCommenting(
      {required Common that, required bool restrictCommenting});

  void redditApiModelSubredditCommonAutoAccessorSetRestrictPosting(
      {required Common that, required bool restrictPosting});

  void redditApiModelSubredditCommonAutoAccessorSetShowMedia(
      {required Common that, required bool showMedia});

  void redditApiModelSubredditCommonAutoAccessorSetSubmitLinkLabel(
      {required Common that, String? submitLinkLabel});

  void redditApiModelSubredditCommonAutoAccessorSetSubmitTextLabel(
      {required Common that, String? submitTextLabel});

  void redditApiModelSubredditCommonAutoAccessorSetSubredditType(
      {required Common that, String? subredditType});

  void redditApiModelSubredditCommonAutoAccessorSetSubscribers(
      {required Common that, required PlatformInt64 subscribers});

  void redditApiModelSubredditCommonAutoAccessorSetTitle(
      {required Common that, String? title});

  void redditApiModelSubredditCommonAutoAccessorSetUrl(
      {required Common that, required String url});

  void redditApiModelSubredditCommonAutoAccessorSetUserIsBanned(
      {required Common that, required bool userIsBanned});

  void redditApiModelSubredditCommonAutoAccessorSetUserIsContributor(
      {required Common that, required bool userIsContributor});

  void redditApiModelSubredditCommonAutoAccessorSetUserIsModerator(
      {required Common that, required bool userIsModerator});

  void redditApiModelSubredditCommonAutoAccessorSetUserIsMuted(
      {required Common that, required bool userIsMuted});

  void redditApiModelSubredditCommonAutoAccessorSetUserIsSubscriber(
      {required Common that, required bool userIsSubscriber});

  Future<Common> redditApiModelSubredditCommonDefault();

  SubredditIcon redditApiModelSubredditCommonIcon({required Common that});

  bool redditApiModelSubredditDetailsAutoAccessorGetDefaultSet(
      {required Details that});

  String? redditApiModelSubredditDetailsAutoAccessorGetDescription(
      {required Details that});

  String? redditApiModelSubredditDetailsAutoAccessorGetIconColor(
      {required Details that});

  Common redditApiModelSubredditDetailsAutoAccessorGetOther(
      {required Details that});

  bool redditApiModelSubredditDetailsAutoAccessorGetOver18(
      {required Details that});

  List<String> redditApiModelSubredditDetailsAutoAccessorGetPreviousNames(
      {required Details that});

  void redditApiModelSubredditDetailsAutoAccessorSetDefaultSet(
      {required Details that, required bool defaultSet});

  void redditApiModelSubredditDetailsAutoAccessorSetDescription(
      {required Details that, String? description});

  void redditApiModelSubredditDetailsAutoAccessorSetIconColor(
      {required Details that, String? iconColor});

  void redditApiModelSubredditDetailsAutoAccessorSetOther(
      {required Details that, required Common other});

  void redditApiModelSubredditDetailsAutoAccessorSetOver18(
      {required Details that, required bool over18});

  void redditApiModelSubredditDetailsAutoAccessorSetPreviousNames(
      {required Details that, required List<String> previousNames});

  Future<Details> redditApiModelSubredditDetailsDefault();

  SubredditIcon redditApiModelSubredditDetailsIcon({required Details that});

  Future<BoxFeedStream> redditApiModelFeedFeedStreamNew(
      {required Client client,
      required Feed feed,
      required FeedSort sort,
      required Url baseUrl});

  Future<Fullname> redditApiModelFullnameDefault();

  Future<GalleryData> redditApiModelGalleryGalleryDataDefault();

  String redditApiModelGalleryGalleryMediaAutoAccessorGetMediaType(
      {required GalleryMedia that});

  void redditApiModelGalleryGalleryMediaAutoAccessorSetMediaType(
      {required GalleryMedia that, required String mediaType});

  Future<Gallery> redditApiModelGalleryGalleryDefault();

  Source redditApiModelGalleryGalleryGet(
      {required Gallery that, required int index});

  double redditApiModelGalleryGalleryGetAspectRatio({required Gallery that});

  int redditApiModelGalleryGalleryGetLength({required Gallery that});

  String? redditApiModelListingAutoAccessorGetAfter({required Listing that});

  String? redditApiModelListingAutoAccessorGetBefore({required Listing that});

  List<Thing> redditApiModelListingAutoAccessorGetChildren(
      {required Listing that});

  int? redditApiModelListingAutoAccessorGetDist({required Listing that});

  String? redditApiModelListingAutoAccessorGetModhash({required Listing that});

  void redditApiModelListingAutoAccessorSetAfter(
      {required Listing that, String? after});

  void redditApiModelListingAutoAccessorSetBefore(
      {required Listing that, String? before});

  void redditApiModelListingAutoAccessorSetChildren(
      {required Listing that, required List<Thing> children});

  void redditApiModelListingAutoAccessorSetDist(
      {required Listing that, int? dist});

  void redditApiModelListingAutoAccessorSetModhash(
      {required Listing that, String? modhash});

  Future<Listing> redditApiModelListingDefault();

  Future<BoxMultiStream> redditApiModelMultiMultiStreamNew(
      {required Client client,
      required Multi multi,
      required FeedSort sort,
      required Url baseUrl});

  bool redditApiModelMultiMultiAutoAccessorGetCanEdit({required Multi that});

  String? redditApiModelMultiMultiAutoAccessorGetCopiedFrom(
      {required Multi that});

  double redditApiModelMultiMultiAutoAccessorGetCreated({required Multi that});

  double redditApiModelMultiMultiAutoAccessorGetCreatedUtc(
      {required Multi that});

  String redditApiModelMultiMultiAutoAccessorGetDescriptionHtml(
      {required Multi that});

  String redditApiModelMultiMultiAutoAccessorGetDescriptionMd(
      {required Multi that});

  String redditApiModelMultiMultiAutoAccessorGetDisplayName(
      {required Multi that});

  String redditApiModelMultiMultiAutoAccessorGetIconUrl({required Multi that});

  bool redditApiModelMultiMultiAutoAccessorGetIsFavorited(
      {required Multi that});

  bool redditApiModelMultiMultiAutoAccessorGetIsSubscriber(
      {required Multi that});

  String? redditApiModelMultiMultiAutoAccessorGetKeyColor(
      {required Multi that});

  Fullname redditApiModelMultiMultiAutoAccessorGetName({required Multi that});

  PlatformInt64 redditApiModelMultiMultiAutoAccessorGetNumSubscribers(
      {required Multi that});

  bool redditApiModelMultiMultiAutoAccessorGetOver18({required Multi that});

  String redditApiModelMultiMultiAutoAccessorGetOwner({required Multi that});

  String redditApiModelMultiMultiAutoAccessorGetOwnerId({required Multi that});

  String redditApiModelMultiMultiAutoAccessorGetPath({required Multi that});

  List<SubredditDetails> redditApiModelMultiMultiAutoAccessorGetSubreddits(
      {required Multi that});

  String redditApiModelMultiMultiAutoAccessorGetVisibility(
      {required Multi that});

  void redditApiModelMultiMultiAutoAccessorSetCanEdit(
      {required Multi that, required bool canEdit});

  void redditApiModelMultiMultiAutoAccessorSetCopiedFrom(
      {required Multi that, String? copiedFrom});

  void redditApiModelMultiMultiAutoAccessorSetCreated(
      {required Multi that, required double created});

  void redditApiModelMultiMultiAutoAccessorSetCreatedUtc(
      {required Multi that, required double createdUtc});

  void redditApiModelMultiMultiAutoAccessorSetDescriptionHtml(
      {required Multi that, required String descriptionHtml});

  void redditApiModelMultiMultiAutoAccessorSetDescriptionMd(
      {required Multi that, required String descriptionMd});

  void redditApiModelMultiMultiAutoAccessorSetDisplayName(
      {required Multi that, required String displayName});

  void redditApiModelMultiMultiAutoAccessorSetIconUrl(
      {required Multi that, required String iconUrl});

  void redditApiModelMultiMultiAutoAccessorSetIsFavorited(
      {required Multi that, required bool isFavorited});

  void redditApiModelMultiMultiAutoAccessorSetIsSubscriber(
      {required Multi that, required bool isSubscriber});

  void redditApiModelMultiMultiAutoAccessorSetKeyColor(
      {required Multi that, String? keyColor});

  void redditApiModelMultiMultiAutoAccessorSetName(
      {required Multi that, required Fullname name});

  void redditApiModelMultiMultiAutoAccessorSetNumSubscribers(
      {required Multi that, required PlatformInt64 numSubscribers});

  void redditApiModelMultiMultiAutoAccessorSetOver18(
      {required Multi that, required bool over18});

  void redditApiModelMultiMultiAutoAccessorSetOwner(
      {required Multi that, required String owner});

  void redditApiModelMultiMultiAutoAccessorSetOwnerId(
      {required Multi that, required String ownerId});

  void redditApiModelMultiMultiAutoAccessorSetPath(
      {required Multi that, required String path});

  void redditApiModelMultiMultiAutoAccessorSetSubreddits(
      {required Multi that, required List<SubredditDetails> subreddits});

  void redditApiModelMultiMultiAutoAccessorSetVisibility(
      {required Multi that, required String visibility});

  Future<Multi> redditApiModelMultiMultiDefault();

  Future<Url> redditApiClientPagerAddToUrl(
      {required Pager that, required Url url});

  Future<void> redditApiClientPagerAfter({required Pager that, String? after});

  Future<void> redditApiClientPagerBefore(
      {required Pager that, String? before});

  Future<Pager> redditApiClientPagerDefault();

  Future<PostId> redditApiModelPostPostIdDefault();

  Future<Post> redditApiModelPostPostDefault();

  Future<List<String?>> redditApiModelPostPostGetAllAwardings(
      {required Post that});

  Future<bool> redditApiModelPostPostGetAllowLiveComments({required Post that});

  Future<double?> redditApiModelPostPostGetApprovedAtUtc({required Post that});

  Future<String?> redditApiModelPostPostGetApprovedBy({required Post that});

  Future<bool> redditApiModelPostPostGetArchived({required Post that});

  AuthorInfo? redditApiModelPostPostGetAuthor({required Post that});

  Future<List<String?>> redditApiModelPostPostGetAwarders({required Post that});

  Future<double?> redditApiModelPostPostGetBannedAtUtc({required Post that});

  Future<bool> redditApiModelPostPostGetCanGild({required Post that});

  Future<bool> redditApiModelPostPostGetCanModPost({required Post that});

  Future<String?> redditApiModelPostPostGetCategory({required Post that});

  Future<bool> redditApiModelPostPostGetClicked({required Post that});

  Future<List<String>> redditApiModelPostPostGetContentCategories(
      {required Post that});

  Future<bool> redditApiModelPostPostGetContestMode({required Post that});

  Future<DateTime> redditApiModelPostPostGetCreated({required Post that});

  DateTime redditApiModelPostPostGetCreatedUtc({required Post that});

  List<Post> redditApiModelPostPostGetCrosspostParentList({required Post that});

  Future<String?> redditApiModelPostPostGetDiscussionType({required Post that});

  Future<String?> redditApiModelPostPostGetDistinguished({required Post that});

  String redditApiModelPostPostGetDomain({required Post that});

  int redditApiModelPostPostGetDowns({required Post that});

  double? redditApiModelPostPostGetEdited({required Post that});

  Gallery? redditApiModelPostPostGetGallery({required Post that});

  Future<int> redditApiModelPostPostGetGilded({required Post that});

  Future<Gildings> redditApiModelPostPostGetGildings({required Post that});

  Future<bool> redditApiModelPostPostGetHidden({required Post that});

  Future<bool> redditApiModelPostPostGetHideScore({required Post that});

  PostId redditApiModelPostPostGetId({required Post that});

  Future<bool> redditApiModelPostPostGetIsCreatedFromAdsUi(
      {required Post that});

  Future<bool> redditApiModelPostPostGetIsCrosspostable({required Post that});

  Future<bool> redditApiModelPostPostGetIsGallery({required Post that});

  Future<bool> redditApiModelPostPostGetIsMeta({required Post that});

  Future<bool> redditApiModelPostPostGetIsOriginalContent({required Post that});

  bool redditApiModelPostPostGetIsRedditMediaDomain({required Post that});

  Future<bool> redditApiModelPostPostGetIsRobotIndexable({required Post that});

  bool redditApiModelPostPostGetIsSelf({required Post that});

  Future<bool> redditApiModelPostPostGetIsVideo({required Post that});

  bool? redditApiModelPostPostGetLikes({required Post that});

  Flair redditApiModelPostPostGetLinkFlair({required Post that});

  bool redditApiModelPostPostGetLocked({required Post that});

  Media? redditApiModelPostPostGetMedia({required Post that});

  MediaEmbed? redditApiModelPostPostGetMediaEmbed({required Post that});

  Future<bool> redditApiModelPostPostGetMediaOnly({required Post that});

  Future<String?> redditApiModelPostPostGetModNote({required Post that});

  Future<String?> redditApiModelPostPostGetModReasonBy({required Post that});

  Future<String?> redditApiModelPostPostGetModReasonTitle({required Post that});

  Future<List<String?>> redditApiModelPostPostGetModReports(
      {required Post that});

  Fullname redditApiModelPostPostGetName({required Post that});

  Future<bool> redditApiModelPostPostGetNoFollow({required Post that});

  int redditApiModelPostPostGetNumComments({required Post that});

  Future<int?> redditApiModelPostPostGetNumCrossposts({required Post that});

  Future<int?> redditApiModelPostPostGetNumDuplicates({required Post that});

  Future<int?> redditApiModelPostPostGetNumReports({required Post that});

  bool redditApiModelPostPostGetOver18({required Post that});

  String redditApiModelPostPostGetPermalink({required Post that});

  bool redditApiModelPostPostGetPinned({required Post that});

  Future<String?> redditApiModelPostPostGetPostHint({required Post that});

  Preview? redditApiModelPostPostGetPreview({required Post that});

  Future<int?> redditApiModelPostPostGetPwls({required Post that});

  Future<bool> redditApiModelPostPostGetQuarantine({required Post that});

  Future<String?> redditApiModelPostPostGetRemovalReason({required Post that});

  Future<String?> redditApiModelPostPostGetRemovedBy({required Post that});

  Future<String?> redditApiModelPostPostGetRemovedByCategory(
      {required Post that});

  Future<List<String>> redditApiModelPostPostGetReportReasons(
      {required Post that});

  bool redditApiModelPostPostGetSaved({required Post that});

  int redditApiModelPostPostGetScore({required Post that});

  Media? redditApiModelPostPostGetSecureMedia({required Post that});

  SecureMediaEmbed? redditApiModelPostPostGetSecureMediaEmbed(
      {required Post that});

  String? redditApiModelPostPostGetSelftext({required Post that});

  String? redditApiModelPostPostGetSelftextHtml({required Post that});

  Future<bool> redditApiModelPostPostGetSendReplies({required Post that});

  bool redditApiModelPostPostGetSpoiler({required Post that});

  bool redditApiModelPostPostGetStickied({required Post that});

  SubredditInfo redditApiModelPostPostGetSubreddit({required Post that});

  CommentSort? redditApiModelPostPostGetSuggestedSort({required Post that});

  String redditApiModelPostPostGetTitle({required Post that});

  Future<String?> redditApiModelPostPostGetTopAwardedType({required Post that});

  Future<int?> redditApiModelPostPostGetTotalAwardsReceived(
      {required Post that});

  Future<List<String?>> redditApiModelPostPostGetTreatmentTags(
      {required Post that});

  int redditApiModelPostPostGetUps({required Post that});

  double redditApiModelPostPostGetUpvoteRatio({required Post that});

  String redditApiModelPostPostGetUrl({required Post that});

  String? redditApiModelPostPostGetUrlOverriddenByDest({required Post that});

  Future<List<String?>> redditApiModelPostPostGetUserReports(
      {required Post that});

  Future<String?> redditApiModelPostPostGetViewCount({required Post that});

  Future<bool> redditApiModelPostPostGetVisited({required Post that});

  Future<int?> redditApiModelPostPostGetWls({required Post that});

  bool redditApiModelPostPostIsCrosspost({required Post that});

  Kind redditApiModelPostPostKind({required Post that});

  Future<void> redditApiModelPostPostSave(
      {required Post that, required Client client});

  Thumbnail? redditApiModelPostPostThumbnail({required Post that});

  Future<void> redditApiModelPostPostUnsave(
      {required Post that, required Client client});

  Future<void> redditApiModelPostPostVote(
      {required Post that,
      required VoteDirection direction,
      required Client client});

  SearchPost redditApiSearchSearchPostNew(
      {required Client client,
      String? subreddit,
      Flair? flair,
      String? query,
      required PostSearchSort sort});

  SearchSubreddit redditApiSearchSearchSubredditNew(
      {required Client client,
      required String query,
      required SubredditSearchSort sort});

  List<Thing> redditApiStreamableStreamableGetAll({required Streamable that});

  int redditApiStreamableStreamableGetLength({required Streamable that});

  Future<bool> redditApiStreamableStreamableNext({required Streamable that});

  Thing? redditApiStreamableStreamableNth(
      {required Streamable that, required int n});

  Future<void> redditApiStreamableStreamableRefresh({required Streamable that});

  Future<void> redditApiStreamableStreamableSave(
      {required Streamable that,
      required Fullname name,
      required bool save,
      required Client client});

  Future<void> redditApiStreamableStreamableVote(
      {required Streamable that,
      required Fullname name,
      required VoteDirection direction,
      required Client client});

  Future<SubredditId> redditApiModelSubredditSubredditIdDefault();

  Details? redditApiModelSubredditSubredditInfoAutoAccessorGetDetails(
      {required SubredditInfo that});

  String redditApiModelSubredditSubredditInfoAutoAccessorGetSubreddit(
      {required SubredditInfo that});

  SubredditId redditApiModelSubredditSubredditInfoAutoAccessorGetSubredditId(
      {required SubredditInfo that});

  String
      redditApiModelSubredditSubredditInfoAutoAccessorGetSubredditNamePrefixed(
          {required SubredditInfo that});

  int redditApiModelSubredditSubredditInfoAutoAccessorGetSubscribers(
      {required SubredditInfo that});

  void redditApiModelSubredditSubredditInfoAutoAccessorSetDetails(
      {required SubredditInfo that, Details? details});

  void redditApiModelSubredditSubredditInfoAutoAccessorSetSubreddit(
      {required SubredditInfo that, required String subreddit});

  void redditApiModelSubredditSubredditInfoAutoAccessorSetSubredditId(
      {required SubredditInfo that, required SubredditId subredditId});

  void redditApiModelSubredditSubredditInfoAutoAccessorSetSubredditNamePrefixed(
      {required SubredditInfo that, required String subredditNamePrefixed});

  void redditApiModelSubredditSubredditInfoAutoAccessorSetSubscribers(
      {required SubredditInfo that, required int subscribers});

  Future<SubredditInfo> redditApiModelSubredditSubredditInfoDefault();

  int? redditApiModelSubredditSubredditAutoAccessorGetAccountsActive(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAccountsActiveIsFuzzed(
      {required Subreddit that});

  int redditApiModelSubredditSubredditAutoAccessorGetActiveUserCount(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetAdvertiserCategory(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllOriginalContent(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowDiscovery(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowGalleries(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowImages(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowPolls(
      {required Subreddit that});

  bool
      redditApiModelSubredditSubredditAutoAccessorGetAllowPredictionContributors(
          {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowPredictions(
      {required Subreddit that});

  bool
      redditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsTournament(
          {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowTalks(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowVideogifs(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowVideos(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundColor(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundImage(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetCanAssignLinkFlair(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetCanAssignUserFlair(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetCollapseDeletedComments(
      {required Subreddit that});

  CommentContributionSettings
      redditApiModelSubredditSubredditAutoAccessorGetCommentContributionSettings(
          {required Subreddit that});

  PlatformInt64?
      redditApiModelSubredditSubredditAutoAccessorGetCommentScoreHideMins(
          {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetCommunityReviewed(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetDescription(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetDescriptionHtml(
      {required Subreddit that});

  Int64List? redditApiModelSubredditSubredditAutoAccessorGetEmojisCustomSize(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetEmojisEnabled(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetHasMenuWidget(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetHeaderTitle(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetHideAds(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetId(
      {required Subreddit that});

  bool? redditApiModelSubredditSubredditAutoAccessorGetIsCrosspostableSubreddit(
      {required Subreddit that});

  bool? redditApiModelSubredditSubredditAutoAccessorGetIsEnrolledInNewModmail(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetLang(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetMobileBannerImage(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetNotificationLevel(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetOriginalContentTagEnabled(
      {required Subreddit that});

  Common redditApiModelSubredditSubredditAutoAccessorGetOther(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetOver18(
      {required Subreddit that});

  PlatformInt64
      redditApiModelSubredditSubredditAutoAccessorGetPredictionLeaderboardEntryType(
          {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetPublicDescriptionHtml(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetPublicTraffic(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetShouldArchivePosts(
      {required Subreddit that});

  bool
      redditApiModelSubredditSubredditAutoAccessorGetShouldShowMediaInCommentsSetting(
          {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetShowMediaPreview(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetSpoilersEnabled(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetSubmissionType(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetSubmitText(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetSubmitTextHtml(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetSuggestedCommentSort(
      {required Subreddit that});

  bool? redditApiModelSubredditSubredditAutoAccessorGetUserCanFlairInSr(
      {required Subreddit that});

  Flair redditApiModelSubredditSubredditAutoAccessorGetUserFlair(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetUserFlairEnabledInSr(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetUserHasFavorited(
      {required Subreddit that});

  bool? redditApiModelSubredditSubredditAutoAccessorGetUserSrFlairEnabled(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetUserSrThemeEnabled(
      {required Subreddit that});

  bool? redditApiModelSubredditSubredditAutoAccessorGetWikiEnabled(
      {required Subreddit that});

  int? redditApiModelSubredditSubredditAutoAccessorGetWls(
      {required Subreddit that});

  void redditApiModelSubredditSubredditAutoAccessorSetAccountsActive(
      {required Subreddit that, int? accountsActive});

  void redditApiModelSubredditSubredditAutoAccessorSetAccountsActiveIsFuzzed(
      {required Subreddit that, required bool accountsActiveIsFuzzed});

  void redditApiModelSubredditSubredditAutoAccessorSetActiveUserCount(
      {required Subreddit that, required int activeUserCount});

  void redditApiModelSubredditSubredditAutoAccessorSetAdvertiserCategory(
      {required Subreddit that, String? advertiserCategory});

  void redditApiModelSubredditSubredditAutoAccessorSetAllOriginalContent(
      {required Subreddit that, required bool allOriginalContent});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowDiscovery(
      {required Subreddit that, required bool allowDiscovery});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowGalleries(
      {required Subreddit that, required bool allowGalleries});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowImages(
      {required Subreddit that, required bool allowImages});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowPolls(
      {required Subreddit that, required bool allowPolls});

  void
      redditApiModelSubredditSubredditAutoAccessorSetAllowPredictionContributors(
          {required Subreddit that, required bool allowPredictionContributors});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowPredictions(
      {required Subreddit that, required bool allowPredictions});

  void
      redditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsTournament(
          {required Subreddit that, required bool allowPredictionsTournament});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowTalks(
      {required Subreddit that, required bool allowTalks});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowVideogifs(
      {required Subreddit that, required bool allowVideogifs});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowVideos(
      {required Subreddit that, required bool allowVideos});

  void redditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundColor(
      {required Subreddit that, String? bannerBackgroundColor});

  void redditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundImage(
      {required Subreddit that, String? bannerBackgroundImage});

  void redditApiModelSubredditSubredditAutoAccessorSetCanAssignLinkFlair(
      {required Subreddit that, required bool canAssignLinkFlair});

  void redditApiModelSubredditSubredditAutoAccessorSetCanAssignUserFlair(
      {required Subreddit that, required bool canAssignUserFlair});

  void redditApiModelSubredditSubredditAutoAccessorSetCollapseDeletedComments(
      {required Subreddit that, required bool collapseDeletedComments});

  void
      redditApiModelSubredditSubredditAutoAccessorSetCommentContributionSettings(
          {required Subreddit that,
          required CommentContributionSettings commentContributionSettings});

  void redditApiModelSubredditSubredditAutoAccessorSetCommentScoreHideMins(
      {required Subreddit that, PlatformInt64? commentScoreHideMins});

  void redditApiModelSubredditSubredditAutoAccessorSetCommunityReviewed(
      {required Subreddit that, required bool communityReviewed});

  void redditApiModelSubredditSubredditAutoAccessorSetDescription(
      {required Subreddit that, String? description});

  void redditApiModelSubredditSubredditAutoAccessorSetDescriptionHtml(
      {required Subreddit that, String? descriptionHtml});

  void redditApiModelSubredditSubredditAutoAccessorSetEmojisCustomSize(
      {required Subreddit that, Int64List? emojisCustomSize});

  void redditApiModelSubredditSubredditAutoAccessorSetEmojisEnabled(
      {required Subreddit that, required bool emojisEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetHasMenuWidget(
      {required Subreddit that, required bool hasMenuWidget});

  void redditApiModelSubredditSubredditAutoAccessorSetHeaderTitle(
      {required Subreddit that, String? headerTitle});

  void redditApiModelSubredditSubredditAutoAccessorSetHideAds(
      {required Subreddit that, required bool hideAds});

  void redditApiModelSubredditSubredditAutoAccessorSetId(
      {required Subreddit that, required String id});

  void redditApiModelSubredditSubredditAutoAccessorSetIsCrosspostableSubreddit(
      {required Subreddit that, bool? isCrosspostableSubreddit});

  void redditApiModelSubredditSubredditAutoAccessorSetIsEnrolledInNewModmail(
      {required Subreddit that, bool? isEnrolledInNewModmail});

  void redditApiModelSubredditSubredditAutoAccessorSetLang(
      {required Subreddit that, String? lang});

  void redditApiModelSubredditSubredditAutoAccessorSetMobileBannerImage(
      {required Subreddit that, String? mobileBannerImage});

  void redditApiModelSubredditSubredditAutoAccessorSetNotificationLevel(
      {required Subreddit that, String? notificationLevel});

  void redditApiModelSubredditSubredditAutoAccessorSetOriginalContentTagEnabled(
      {required Subreddit that, required bool originalContentTagEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetOther(
      {required Subreddit that, required Common other});

  void redditApiModelSubredditSubredditAutoAccessorSetOver18(
      {required Subreddit that, required bool over18});

  void
      redditApiModelSubredditSubredditAutoAccessorSetPredictionLeaderboardEntryType(
          {required Subreddit that,
          required PlatformInt64 predictionLeaderboardEntryType});

  void redditApiModelSubredditSubredditAutoAccessorSetPublicDescriptionHtml(
      {required Subreddit that, String? publicDescriptionHtml});

  void redditApiModelSubredditSubredditAutoAccessorSetPublicTraffic(
      {required Subreddit that, required bool publicTraffic});

  void redditApiModelSubredditSubredditAutoAccessorSetShouldArchivePosts(
      {required Subreddit that, required bool shouldArchivePosts});

  void
      redditApiModelSubredditSubredditAutoAccessorSetShouldShowMediaInCommentsSetting(
          {required Subreddit that,
          required bool shouldShowMediaInCommentsSetting});

  void redditApiModelSubredditSubredditAutoAccessorSetShowMediaPreview(
      {required Subreddit that, required bool showMediaPreview});

  void redditApiModelSubredditSubredditAutoAccessorSetSpoilersEnabled(
      {required Subreddit that, required bool spoilersEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetSubmissionType(
      {required Subreddit that, String? submissionType});

  void redditApiModelSubredditSubredditAutoAccessorSetSubmitText(
      {required Subreddit that, String? submitText});

  void redditApiModelSubredditSubredditAutoAccessorSetSubmitTextHtml(
      {required Subreddit that, String? submitTextHtml});

  void redditApiModelSubredditSubredditAutoAccessorSetSuggestedCommentSort(
      {required Subreddit that, String? suggestedCommentSort});

  void redditApiModelSubredditSubredditAutoAccessorSetUserCanFlairInSr(
      {required Subreddit that, bool? userCanFlairInSr});

  void redditApiModelSubredditSubredditAutoAccessorSetUserFlair(
      {required Subreddit that, required Flair userFlair});

  void redditApiModelSubredditSubredditAutoAccessorSetUserFlairEnabledInSr(
      {required Subreddit that, required bool userFlairEnabledInSr});

  void redditApiModelSubredditSubredditAutoAccessorSetUserHasFavorited(
      {required Subreddit that, required bool userHasFavorited});

  void redditApiModelSubredditSubredditAutoAccessorSetUserSrFlairEnabled(
      {required Subreddit that, bool? userSrFlairEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetUserSrThemeEnabled(
      {required Subreddit that, required bool userSrThemeEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetWikiEnabled(
      {required Subreddit that, bool? wikiEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetWls(
      {required Subreddit that, int? wls});

  Future<Subreddit> redditApiModelSubredditSubredditDefault();

  SubredditIcon redditApiModelSubredditSubredditIcon({required Subreddit that});

  Future<AnimatedImage> redditApiModelGalleryAnimatedImageDefault();

  Future<AuthorInfo> redditApiModelAuthorAuthorInfoDefault();

  Future<CommentContributionSettings>
      redditApiModelSubredditCommentContributionSettingsDefault();

  void crateApiSimpleDebugComment({required Comment comment});

  void crateApiSimpleDebugPost({required Post post});

  Future<Feed> redditApiModelFeedFeedDefault();

  Future<Flair> redditApiModelFlairFlairDefault();

  Future<Gildings> redditApiModelPostGildingsDefault();

  Future<ImageBase> redditApiModelPostImageBaseDefault();

  Future<Image> redditApiModelGalleryImageDefault();

  Future<void> crateApiSimpleInitApp();

  Future<MediaEmbed> redditApiModelPostMediaEmbedDefault();

  Future<NotificationLevel> redditApiModelSubredditNotificationLevelDefault();

  Future<Oembed> redditApiModelPostOembedDefault();

  Future<Preview> redditApiModelPostPreviewDefault();

  Client crateApiSimpleRedditApiClient();

  Future<RedditImage> redditApiModelPostRedditImageDefault();

  Future<RedditVideo> redditApiModelPostRedditVideoDefault();

  Future<SecureMediaEmbed> redditApiModelPostSecureMediaEmbedDefault();

  Future<Snoovatar> redditApiModelUserModelSnoovatarDefault();

  Future<SubredditDetails> redditApiModelMultiSubredditDetailsDefault();

  Fullname? redditApiModelThingName({required Thing that});

  Future<ThumbnailOption> redditApiModelPostThumbnailOptionDefault();

  Future<ThumbnailURL> redditApiModelPostThumbnailUrlDefault();

  Future<User> redditApiModelUserModelUserDefault();

  Future<UserInfo> redditApiModelUserModelUserInfoDefault();

  Future<UserSubreddit> redditApiModelUserModelUserSubredditDefault();

  Future<VariantInner> redditApiModelPostVariantInnerDefault();

  Future<Variants> redditApiModelPostVariantsDefault();

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BoxFeedStream;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BoxFeedStream;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_BoxFeedStreamPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BoxMultiStream;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BoxMultiStream;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_BoxMultiStreamPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Client;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Client;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ClientPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Comment;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Comment;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_CommentPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Common;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Common;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_CommonPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Details;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Details;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_DetailsPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_FeedStream;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_FeedStream;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FeedStreamPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Fullname;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Fullname;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FullnamePtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Gallery;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Gallery;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_GalleryPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_GalleryData;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_GalleryData;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_GalleryDataPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_GalleryMedia;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_GalleryMedia;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_GalleryMediaPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Listing;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Listing;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ListingPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Multi;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Multi;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MultiPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MultiStream;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MultiStream;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MultiStreamPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Pager;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Pager;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PagerPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Post;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Post;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PostPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PostId;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PostId;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PostIdPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SearchPost;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SearchPost;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SearchPostPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SearchSubreddit;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SearchSubreddit;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_SearchSubredditPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Streamable;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Streamable;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_StreamablePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Subreddit;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Subreddit;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SubredditPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SubredditId;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SubredditId;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SubredditIdPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SubredditInfo;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SubredditInfo;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_SubredditInfoPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Url;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Url;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_UrlPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> redditApiClientClientAuthenticate(
      {required Client that, required String refreshToken}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(refreshToken, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientAuthenticateConstMeta,
      argValues: [that, refreshToken],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientAuthenticateConstMeta =>
      const TaskConstMeta(
        debugName: "Client_authenticate",
        argNames: ["that", "refreshToken"],
      );

  @override
  Future<(Post, List<Thing>)> redditApiClientClientComments(
      {required Client that, required String permalink, CommentSort? sort}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(permalink, serializer);
        sse_encode_opt_box_autoadd_comment_sort(sort, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_post_list_thing,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientCommentsConstMeta,
      argValues: [that, permalink, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientCommentsConstMeta =>
      const TaskConstMeta(
        debugName: "Client_comments",
        argNames: ["that", "permalink", "sort"],
      );

  @override
  Future<Client> redditApiClientClientDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Client_default",
        argNames: [],
      );

  @override
  Streamable redditApiClientClientFeedStream(
      {required Client that, required Feed feed, required FeedSort sort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_box_autoadd_feed(feed, serializer);
        sse_encode_box_autoadd_feed_sort(sort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientFeedStreamConstMeta,
      argValues: [that, feed, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientFeedStreamConstMeta =>
      const TaskConstMeta(
        debugName: "Client_feed_stream",
        argNames: ["that", "feed", "sort"],
      );

  @override
  Future<Client> redditApiClientClientFromRefreshToken(
      {required String refreshToken}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(refreshToken, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientFromRefreshTokenConstMeta,
      argValues: [refreshToken],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientFromRefreshTokenConstMeta =>
      const TaskConstMeta(
        debugName: "Client_from_refresh_token",
        argNames: ["refreshToken"],
      );

  @override
  Future<Post> redditApiClientClientGetPost(
      {required Client that, required String permalink}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(permalink, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientGetPostConstMeta,
      argValues: [that, permalink],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientGetPostConstMeta =>
      const TaskConstMeta(
        debugName: "Client_get_post",
        argNames: ["that", "permalink"],
      );

  @override
  Future<List<Thing>> redditApiClientClientLoadMoreComments(
      {required Client that,
      required Fullname parentId,
      required List<String> children,
      CommentSort? sort}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            parentId, serializer);
        sse_encode_list_String(children, serializer);
        sse_encode_opt_box_autoadd_comment_sort(sort, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_thing,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientLoadMoreCommentsConstMeta,
      argValues: [that, parentId, children, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientLoadMoreCommentsConstMeta =>
      const TaskConstMeta(
        debugName: "Client_load_more_comments",
        argNames: ["that", "parentId", "children", "sort"],
      );

  @override
  Future<UserInfo> redditApiClientClientLoggedUserInfo({required Client that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_user_info,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientLoggedUserInfoConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientLoggedUserInfoConstMeta =>
      const TaskConstMeta(
        debugName: "Client_logged_user_info",
        argNames: ["that"],
      );

  @override
  Streamable redditApiClientClientMultiPosts(
      {required Client that, required Multi multi, required FeedSort sort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            multi, serializer);
        sse_encode_box_autoadd_feed_sort(sort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientMultiPostsConstMeta,
      argValues: [that, multi, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientMultiPostsConstMeta =>
      const TaskConstMeta(
        debugName: "Client_multi_posts",
        argNames: ["that", "multi", "sort"],
      );

  @override
  Future<List<Multi>> redditApiClientClientMultis({required Client that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientMultisConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientMultisConstMeta =>
      const TaskConstMeta(
        debugName: "Client_multis",
        argNames: ["that"],
      );

  @override
  Future<Client> redditApiClientClientNewAnonymous() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientNewAnonymousConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientNewAnonymousConstMeta =>
      const TaskConstMeta(
        debugName: "Client_new_anonymous",
        argNames: [],
      );

  @override
  Future<void> redditApiClientClientNewLoggedOutUserToken(
      {required Client that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientNewLoggedOutUserTokenConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientNewLoggedOutUserTokenConstMeta =>
      const TaskConstMeta(
        debugName: "Client_new_logged_out_user_token",
        argNames: ["that"],
      );

  @override
  Future<void> redditApiClientClientSave(
      {required Client that, required Fullname thing}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            thing, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientSaveConstMeta,
      argValues: [that, thing],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientSaveConstMeta => const TaskConstMeta(
        debugName: "Client_save",
        argNames: ["that", "thing"],
      );

  @override
  Streamable redditApiClientClientSearchPost(
      {required Client that,
      String? subreddit,
      Flair? flair,
      String? query,
      required PostSearchSort sort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_opt_String(subreddit, serializer);
        sse_encode_opt_box_autoadd_flair(flair, serializer);
        sse_encode_opt_String(query, serializer);
        sse_encode_box_autoadd_post_search_sort(sort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientSearchPostConstMeta,
      argValues: [that, subreddit, flair, query, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientSearchPostConstMeta =>
      const TaskConstMeta(
        debugName: "Client_search_post",
        argNames: ["that", "subreddit", "flair", "query", "sort"],
      );

  @override
  Streamable redditApiClientClientSearchSubreddits(
      {required Client that,
      required String query,
      required SubredditSearchSort sort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(query, serializer);
        sse_encode_subreddit_search_sort(sort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientSearchSubredditsConstMeta,
      argValues: [that, query, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientSearchSubredditsConstMeta =>
      const TaskConstMeta(
        debugName: "Client_search_subreddits",
        argNames: ["that", "query", "sort"],
      );

  @override
  Future<List<Subreddit>> redditApiClientClientSubsriptions(
      {required Client that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientSubsriptionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientSubsriptionsConstMeta =>
      const TaskConstMeta(
        debugName: "Client_subsriptions",
        argNames: ["that"],
      );

  @override
  Future<void> redditApiClientClientUnsave(
      {required Client that, required Fullname thing}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            thing, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientUnsaveConstMeta,
      argValues: [that, thing],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientUnsaveConstMeta =>
      const TaskConstMeta(
        debugName: "Client_unsave",
        argNames: ["that", "thing"],
      );

  @override
  Future<UserInfo> redditApiClientClientUserAbout(
      {required Client that, required String username}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(username, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_user_info,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientUserAboutConstMeta,
      argValues: [that, username],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientUserAboutConstMeta =>
      const TaskConstMeta(
        debugName: "Client_user_about",
        argNames: ["that", "username"],
      );

  @override
  Streamable redditApiClientClientUserComments(
      {required Client that,
      required String username,
      required UserStreamSort sort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(username, serializer);
        sse_encode_box_autoadd_user_stream_sort(sort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientUserCommentsConstMeta,
      argValues: [that, username, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientUserCommentsConstMeta =>
      const TaskConstMeta(
        debugName: "Client_user_comments",
        argNames: ["that", "username", "sort"],
      );

  @override
  Streamable redditApiClientClientUserDownvoted(
      {required Client that, required String username}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(username, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientUserDownvotedConstMeta,
      argValues: [that, username],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientUserDownvotedConstMeta =>
      const TaskConstMeta(
        debugName: "Client_user_downvoted",
        argNames: ["that", "username"],
      );

  @override
  Streamable redditApiClientClientUserGilded(
      {required Client that, required String username}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(username, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 21)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientUserGildedConstMeta,
      argValues: [that, username],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientUserGildedConstMeta =>
      const TaskConstMeta(
        debugName: "Client_user_gilded",
        argNames: ["that", "username"],
      );

  @override
  Streamable redditApiClientClientUserHidden(
      {required Client that, required String username}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(username, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientUserHiddenConstMeta,
      argValues: [that, username],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientUserHiddenConstMeta =>
      const TaskConstMeta(
        debugName: "Client_user_hidden",
        argNames: ["that", "username"],
      );

  @override
  Streamable redditApiClientClientUserOverview(
      {required Client that,
      required String username,
      required UserStreamSort sort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(username, serializer);
        sse_encode_box_autoadd_user_stream_sort(sort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 23)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientUserOverviewConstMeta,
      argValues: [that, username, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientUserOverviewConstMeta =>
      const TaskConstMeta(
        debugName: "Client_user_overview",
        argNames: ["that", "username", "sort"],
      );

  @override
  Streamable redditApiClientClientUserSaved(
      {required Client that, required String username}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(username, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientUserSavedConstMeta,
      argValues: [that, username],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientUserSavedConstMeta =>
      const TaskConstMeta(
        debugName: "Client_user_saved",
        argNames: ["that", "username"],
      );

  @override
  Streamable redditApiClientClientUserSubmitted(
      {required Client that,
      required String username,
      required UserStreamSort sort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(username, serializer);
        sse_encode_box_autoadd_user_stream_sort(sort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientUserSubmittedConstMeta,
      argValues: [that, username, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientUserSubmittedConstMeta =>
      const TaskConstMeta(
        debugName: "Client_user_submitted",
        argNames: ["that", "username", "sort"],
      );

  @override
  Streamable redditApiClientClientUserUpvoted(
      {required Client that, required String username}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(username, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientUserUpvotedConstMeta,
      argValues: [that, username],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientUserUpvotedConstMeta =>
      const TaskConstMeta(
        debugName: "Client_user_upvoted",
        argNames: ["that", "username"],
      );

  @override
  Future<void> redditApiClientClientVote(
      {required Client that,
      required Fullname fullname,
      required VoteDirection direction}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            fullname, serializer);
        sse_encode_vote_direction(direction, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientVoteConstMeta,
      argValues: [that, fullname, direction],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientVoteConstMeta => const TaskConstMeta(
        debugName: "Client_vote",
        argNames: ["that", "fullname", "direction"],
      );

  @override
  bool redditApiModelCommentCommentAutoAccessorGetArchived(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetArchivedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetArchivedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_archived",
            argNames: ["that"],
          );

  @override
  AuthorInfo? redditApiModelCommentCommentAutoAccessorGetAuthor(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_author_info,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetAuthorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetAuthorConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_author",
            argNames: ["that"],
          );

  @override
  String redditApiModelCommentCommentAutoAccessorGetBody(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 30)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetBodyConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentAutoAccessorGetBodyConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_auto_accessor_get_body",
        argNames: ["that"],
      );

  @override
  String redditApiModelCommentCommentAutoAccessorGetBodyHtml(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 31)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetBodyHtmlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetBodyHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_body_html",
            argNames: ["that"],
          );

  @override
  bool redditApiModelCommentCommentAutoAccessorGetCanGild(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 32)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetCanGildConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetCanGildConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_can_gild",
            argNames: ["that"],
          );

  @override
  bool redditApiModelCommentCommentAutoAccessorGetCanModPost(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 33)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorGetCanModPostConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetCanModPostConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_can_mod_post",
            argNames: ["that"],
          );

  @override
  bool redditApiModelCommentCommentAutoAccessorGetCollapsed(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 34)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetCollapsedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetCollapsedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_collapsed",
            argNames: ["that"],
          );

  @override
  int redditApiModelCommentCommentAutoAccessorGetControversiality(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 35)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorGetControversialityConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetControversialityConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_controversiality",
            argNames: ["that"],
          );

  @override
  DateTime redditApiModelCommentCommentAutoAccessorGetCreated(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Chrono_Local,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetCreatedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetCreatedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_created",
            argNames: ["that"],
          );

  @override
  DateTime redditApiModelCommentCommentAutoAccessorGetCreatedUtc(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Chrono_Utc,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorGetCreatedUtcConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetCreatedUtcConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_created_utc",
            argNames: ["that"],
          );

  @override
  int redditApiModelCommentCommentAutoAccessorGetDepth(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetDepthConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetDepthConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_depth",
            argNames: ["that"],
          );

  @override
  String? redditApiModelCommentCommentAutoAccessorGetDistinguished(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorGetDistinguishedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetDistinguishedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_distinguished",
            argNames: ["that"],
          );

  @override
  int redditApiModelCommentCommentAutoAccessorGetDowns(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetDownsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetDownsConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_downs",
            argNames: ["that"],
          );

  @override
  double? redditApiModelCommentCommentAutoAccessorGetEdited(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_f_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetEditedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetEditedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_edited",
            argNames: ["that"],
          );

  @override
  int redditApiModelCommentCommentAutoAccessorGetGilded(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetGildedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetGildedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_gilded",
            argNames: ["that"],
          );

  @override
  String redditApiModelCommentCommentAutoAccessorGetId(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentAutoAccessorGetIdConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_auto_accessor_get_id",
        argNames: ["that"],
      );

  @override
  bool redditApiModelCommentCommentAutoAccessorGetIsSubmitter(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorGetIsSubmitterConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetIsSubmitterConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_is_submitter",
            argNames: ["that"],
          );

  @override
  bool? redditApiModelCommentCommentAutoAccessorGetLikes(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetLikesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetLikesConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_likes",
            argNames: ["that"],
          );

  @override
  String redditApiModelCommentCommentAutoAccessorGetLinkId(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 46)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetLinkIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetLinkIdConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_link_id",
            argNames: ["that"],
          );

  @override
  bool redditApiModelCommentCommentAutoAccessorGetLocked(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 47)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetLockedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetLockedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_locked",
            argNames: ["that"],
          );

  @override
  Fullname redditApiModelCommentCommentAutoAccessorGetName(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 48)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentAutoAccessorGetNameConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_auto_accessor_get_name",
        argNames: ["that"],
      );

  @override
  bool redditApiModelCommentCommentAutoAccessorGetNoFollow(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 49)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetNoFollowConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetNoFollowConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_no_follow",
            argNames: ["that"],
          );

  @override
  String redditApiModelCommentCommentAutoAccessorGetParentId(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 50)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetParentIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetParentIdConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_parent_id",
            argNames: ["that"],
          );

  @override
  String redditApiModelCommentCommentAutoAccessorGetPermalink(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 51)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetPermalinkConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetPermalinkConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_permalink",
            argNames: ["that"],
          );

  @override
  bool redditApiModelCommentCommentAutoAccessorGetSaved(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 52)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetSavedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetSavedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_saved",
            argNames: ["that"],
          );

  @override
  int redditApiModelCommentCommentAutoAccessorGetScore(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 53)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetScoreConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetScoreConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_score",
            argNames: ["that"],
          );

  @override
  bool redditApiModelCommentCommentAutoAccessorGetScoreHidden(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 54)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorGetScoreHiddenConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetScoreHiddenConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_score_hidden",
            argNames: ["that"],
          );

  @override
  bool redditApiModelCommentCommentAutoAccessorGetSendReplies(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 55)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorGetSendRepliesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetSendRepliesConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_send_replies",
            argNames: ["that"],
          );

  @override
  bool redditApiModelCommentCommentAutoAccessorGetStickied(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 56)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetStickiedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetStickiedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_stickied",
            argNames: ["that"],
          );

  @override
  String redditApiModelCommentCommentAutoAccessorGetSubreddit(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 57)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetSubredditConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetSubredditConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_subreddit",
            argNames: ["that"],
          );

  @override
  String redditApiModelCommentCommentAutoAccessorGetSubredditId(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 58)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorGetSubredditIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetSubredditIdConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_subreddit_id",
            argNames: ["that"],
          );

  @override
  String redditApiModelCommentCommentAutoAccessorGetSubredditNamePrefixed(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 59)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorGetSubredditNamePrefixedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetSubredditNamePrefixedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_subreddit_name_prefixed",
            argNames: ["that"],
          );

  @override
  String redditApiModelCommentCommentAutoAccessorGetSubredditType(
      {required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 60)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorGetSubredditTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorGetSubredditTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_get_subreddit_type",
            argNames: ["that"],
          );

  @override
  int redditApiModelCommentCommentAutoAccessorGetUps({required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 61)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorGetUpsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentAutoAccessorGetUpsConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_auto_accessor_get_ups",
        argNames: ["that"],
      );

  @override
  void redditApiModelCommentCommentAutoAccessorSetArchived(
      {required Comment that, required bool archived}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_bool(archived, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 62)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetArchivedConstMeta,
      argValues: [that, archived],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetArchivedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_archived",
            argNames: ["that", "archived"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetAuthor(
      {required Comment that, AuthorInfo? author}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_opt_box_autoadd_author_info(author, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 63)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetAuthorConstMeta,
      argValues: [that, author],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetAuthorConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_author",
            argNames: ["that", "author"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetBody(
      {required Comment that, required String body}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_String(body, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 64)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetBodyConstMeta,
      argValues: [that, body],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentAutoAccessorSetBodyConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_auto_accessor_set_body",
        argNames: ["that", "body"],
      );

  @override
  void redditApiModelCommentCommentAutoAccessorSetBodyHtml(
      {required Comment that, required String bodyHtml}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_String(bodyHtml, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 65)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetBodyHtmlConstMeta,
      argValues: [that, bodyHtml],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetBodyHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_body_html",
            argNames: ["that", "bodyHtml"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetCanGild(
      {required Comment that, required bool canGild}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_bool(canGild, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 66)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetCanGildConstMeta,
      argValues: [that, canGild],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetCanGildConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_can_gild",
            argNames: ["that", "canGild"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetCanModPost(
      {required Comment that, required bool canModPost}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_bool(canModPost, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 67)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorSetCanModPostConstMeta,
      argValues: [that, canModPost],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetCanModPostConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_can_mod_post",
            argNames: ["that", "canModPost"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetCollapsed(
      {required Comment that, required bool collapsed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_bool(collapsed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 68)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetCollapsedConstMeta,
      argValues: [that, collapsed],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetCollapsedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_collapsed",
            argNames: ["that", "collapsed"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetControversiality(
      {required Comment that, required int controversiality}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_i_32(controversiality, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 69)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorSetControversialityConstMeta,
      argValues: [that, controversiality],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetControversialityConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_controversiality",
            argNames: ["that", "controversiality"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetCreated(
      {required Comment that, required DateTime created}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_Chrono_Local(created, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 70)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetCreatedConstMeta,
      argValues: [that, created],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetCreatedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_created",
            argNames: ["that", "created"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetCreatedUtc(
      {required Comment that, required DateTime createdUtc}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_Chrono_Utc(createdUtc, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 71)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorSetCreatedUtcConstMeta,
      argValues: [that, createdUtc],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetCreatedUtcConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_created_utc",
            argNames: ["that", "createdUtc"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetDepth(
      {required Comment that, required int depth}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_i_32(depth, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 72)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetDepthConstMeta,
      argValues: [that, depth],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetDepthConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_depth",
            argNames: ["that", "depth"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetDistinguished(
      {required Comment that, String? distinguished}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_opt_String(distinguished, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 73)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorSetDistinguishedConstMeta,
      argValues: [that, distinguished],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetDistinguishedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_distinguished",
            argNames: ["that", "distinguished"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetDowns(
      {required Comment that, required int downs}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_i_32(downs, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 74)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetDownsConstMeta,
      argValues: [that, downs],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetDownsConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_downs",
            argNames: ["that", "downs"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetEdited(
      {required Comment that, double? edited}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_opt_box_autoadd_f_64(edited, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 75)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetEditedConstMeta,
      argValues: [that, edited],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetEditedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_edited",
            argNames: ["that", "edited"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetGilded(
      {required Comment that, required int gilded}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_i_32(gilded, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 76)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetGildedConstMeta,
      argValues: [that, gilded],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetGildedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_gilded",
            argNames: ["that", "gilded"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetId(
      {required Comment that, required String id}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_String(id, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 77)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetIdConstMeta,
      argValues: [that, id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentAutoAccessorSetIdConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_auto_accessor_set_id",
        argNames: ["that", "id"],
      );

  @override
  void redditApiModelCommentCommentAutoAccessorSetIsSubmitter(
      {required Comment that, required bool isSubmitter}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_bool(isSubmitter, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 78)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorSetIsSubmitterConstMeta,
      argValues: [that, isSubmitter],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetIsSubmitterConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_is_submitter",
            argNames: ["that", "isSubmitter"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetLikes(
      {required Comment that, bool? likes}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_opt_box_autoadd_bool(likes, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 79)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetLikesConstMeta,
      argValues: [that, likes],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetLikesConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_likes",
            argNames: ["that", "likes"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetLinkId(
      {required Comment that, required String linkId}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_String(linkId, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 80)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetLinkIdConstMeta,
      argValues: [that, linkId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetLinkIdConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_link_id",
            argNames: ["that", "linkId"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetLocked(
      {required Comment that, required bool locked}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_bool(locked, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 81)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetLockedConstMeta,
      argValues: [that, locked],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetLockedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_locked",
            argNames: ["that", "locked"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetName(
      {required Comment that, required Fullname name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 82)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetNameConstMeta,
      argValues: [that, name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentAutoAccessorSetNameConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_auto_accessor_set_name",
        argNames: ["that", "name"],
      );

  @override
  void redditApiModelCommentCommentAutoAccessorSetNoFollow(
      {required Comment that, required bool noFollow}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_bool(noFollow, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 83)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetNoFollowConstMeta,
      argValues: [that, noFollow],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetNoFollowConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_no_follow",
            argNames: ["that", "noFollow"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetParentId(
      {required Comment that, required String parentId}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_String(parentId, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 84)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetParentIdConstMeta,
      argValues: [that, parentId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetParentIdConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_parent_id",
            argNames: ["that", "parentId"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetPermalink(
      {required Comment that, required String permalink}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_String(permalink, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 85)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetPermalinkConstMeta,
      argValues: [that, permalink],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetPermalinkConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_permalink",
            argNames: ["that", "permalink"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetSaved(
      {required Comment that, required bool saved}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_bool(saved, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 86)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetSavedConstMeta,
      argValues: [that, saved],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetSavedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_saved",
            argNames: ["that", "saved"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetScore(
      {required Comment that, required int score}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_i_32(score, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 87)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetScoreConstMeta,
      argValues: [that, score],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetScoreConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_score",
            argNames: ["that", "score"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetScoreHidden(
      {required Comment that, required bool scoreHidden}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_bool(scoreHidden, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 88)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorSetScoreHiddenConstMeta,
      argValues: [that, scoreHidden],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetScoreHiddenConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_score_hidden",
            argNames: ["that", "scoreHidden"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetSendReplies(
      {required Comment that, required bool sendReplies}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_bool(sendReplies, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 89)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorSetSendRepliesConstMeta,
      argValues: [that, sendReplies],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetSendRepliesConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_send_replies",
            argNames: ["that", "sendReplies"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetStickied(
      {required Comment that, required bool stickied}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_bool(stickied, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 90)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetStickiedConstMeta,
      argValues: [that, stickied],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetStickiedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_stickied",
            argNames: ["that", "stickied"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetSubreddit(
      {required Comment that, required String subreddit}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_String(subreddit, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 91)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetSubredditConstMeta,
      argValues: [that, subreddit],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetSubredditConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_subreddit",
            argNames: ["that", "subreddit"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetSubredditId(
      {required Comment that, required String subredditId}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_String(subredditId, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 92)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorSetSubredditIdConstMeta,
      argValues: [that, subredditId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetSubredditIdConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_subreddit_id",
            argNames: ["that", "subredditId"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetSubredditNamePrefixed(
      {required Comment that, required String subredditNamePrefixed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_String(subredditNamePrefixed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 93)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorSetSubredditNamePrefixedConstMeta,
      argValues: [that, subredditNamePrefixed],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetSubredditNamePrefixedConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_subreddit_name_prefixed",
            argNames: ["that", "subredditNamePrefixed"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetSubredditType(
      {required Comment that, required String subredditType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_String(subredditType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 94)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelCommentCommentAutoAccessorSetSubredditTypeConstMeta,
      argValues: [that, subredditType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelCommentCommentAutoAccessorSetSubredditTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Comment_auto_accessor_set_subreddit_type",
            argNames: ["that", "subredditType"],
          );

  @override
  void redditApiModelCommentCommentAutoAccessorSetUps(
      {required Comment that, required int ups}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_i_32(ups, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 95)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentAutoAccessorSetUpsConstMeta,
      argValues: [that, ups],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentAutoAccessorSetUpsConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_auto_accessor_set_ups",
        argNames: ["that", "ups"],
      );

  @override
  Future<Comment> redditApiModelCommentCommentDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 96, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_default",
        argNames: [],
      );

  @override
  void redditApiModelCommentCommentReplaceMore(
      {required Comment that,
      required Thing more,
      required List<Thing> newThings}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_box_autoadd_thing(more, serializer);
        sse_encode_list_thing(newThings, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 97)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentReplaceMoreConstMeta,
      argValues: [that, more, newThings],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentReplaceMoreConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_replace_more",
        argNames: ["that", "more", "newThings"],
      );

  @override
  List<Thing> redditApiModelCommentCommentReplies({required Comment that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 98)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_thing,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelCommentCommentRepliesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentRepliesConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_replies",
        argNames: ["that"],
      );

  @override
  Future<void> redditApiModelCommentCommentSave(
      {required Comment that, required Client client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 99, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiModelCommentCommentSaveConstMeta,
      argValues: [that, client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentSaveConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_save",
        argNames: ["that", "client"],
      );

  @override
  Future<void> redditApiModelCommentCommentUnsave(
      {required Comment that, required Client client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 100, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiModelCommentCommentUnsaveConstMeta,
      argValues: [that, client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentUnsaveConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_unsave",
        argNames: ["that", "client"],
      );

  @override
  Future<void> redditApiModelCommentCommentVote(
      {required Comment that,
      required VoteDirection direction,
      required Client client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            that, serializer);
        sse_encode_vote_direction(direction, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 101, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiModelCommentCommentVoteConstMeta,
      argValues: [that, direction, client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelCommentCommentVoteConstMeta =>
      const TaskConstMeta(
        debugName: "Comment_vote",
        argNames: ["that", "direction", "client"],
      );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetAcceptFollowers(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 102)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetAcceptFollowersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetAcceptFollowersConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_accept_followers",
            argNames: ["that"],
          );

  @override
  List<String>
      redditApiModelSubredditCommonAutoAccessorGetAllowedMediaInComments(
          {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 103)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetAllowedMediaInCommentsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetAllowedMediaInCommentsConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_allowed_media_in_comments",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditCommonAutoAccessorGetBannerImg(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 104)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetBannerImgConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetBannerImgConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_banner_img",
            argNames: ["that"],
          );

  @override
  Int64List? redditApiModelSubredditCommonAutoAccessorGetBannerSize(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 105)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_list_prim_i_64_strict,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetBannerSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetBannerSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_banner_size",
            argNames: ["that"],
          );

  @override
  double redditApiModelSubredditCommonAutoAccessorGetCreated(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 106)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditCommonAutoAccessorGetCreatedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetCreatedConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_created",
            argNames: ["that"],
          );

  @override
  double redditApiModelSubredditCommonAutoAccessorGetCreatedUtc(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 107)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetCreatedUtcConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetCreatedUtcConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_created_utc",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetDisableContributorRequests(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 108)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetDisableContributorRequestsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetDisableContributorRequestsConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_disable_contributor_requests",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditCommonAutoAccessorGetDisplayName(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 109)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetDisplayNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetDisplayNameConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_display_name",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditCommonAutoAccessorGetDisplayNamePrefixed(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 110)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetDisplayNamePrefixedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetDisplayNamePrefixedConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_display_name_prefixed",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetFreeFormReports(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 111)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetFreeFormReportsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetFreeFormReportsConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_free_form_reports",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditCommonAutoAccessorGetHeaderImg(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 112)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetHeaderImgConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetHeaderImgConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_header_img",
            argNames: ["that"],
          );

  @override
  Int64List? redditApiModelSubredditCommonAutoAccessorGetHeaderSize(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 113)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_list_prim_i_64_strict,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetHeaderSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetHeaderSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_header_size",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditCommonAutoAccessorGetKeyColor(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 114)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditCommonAutoAccessorGetKeyColorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetKeyColorConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_key_color",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetLinkFlairEnabled(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 115)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetLinkFlairEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetLinkFlairEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_link_flair_enabled",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditCommonAutoAccessorGetLinkFlairPosition(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 116)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetLinkFlairPositionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetLinkFlairPositionConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_link_flair_position",
            argNames: ["that"],
          );

  @override
  Fullname redditApiModelSubredditCommonAutoAccessorGetName(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 117)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditCommonAutoAccessorGetNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetNameConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_name",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditCommonAutoAccessorGetPrimaryColor(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 118)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetPrimaryColorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetPrimaryColorConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_primary_color",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditCommonAutoAccessorGetPublicDescription(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 119)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetPublicDescriptionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetPublicDescriptionConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_public_description",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetQuarantine(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 120)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetQuarantineConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetQuarantineConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_quarantine",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetRestrictCommenting(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 121)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetRestrictCommentingConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetRestrictCommentingConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_restrict_commenting",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetRestrictPosting(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 122)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetRestrictPostingConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetRestrictPostingConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_restrict_posting",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetShowMedia(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 123)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetShowMediaConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetShowMediaConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_show_media",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditCommonAutoAccessorGetSubmitLinkLabel(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 124)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetSubmitLinkLabelConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetSubmitLinkLabelConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_submit_link_label",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditCommonAutoAccessorGetSubmitTextLabel(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 125)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetSubmitTextLabelConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetSubmitTextLabelConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_submit_text_label",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditCommonAutoAccessorGetSubredditType(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 126)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetSubredditTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetSubredditTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_subreddit_type",
            argNames: ["that"],
          );

  @override
  PlatformInt64 redditApiModelSubredditCommonAutoAccessorGetSubscribers(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 127)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetSubscribersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetSubscribersConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_subscribers",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditCommonAutoAccessorGetTitle(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 128)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditCommonAutoAccessorGetTitleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetTitleConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_title",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditCommonAutoAccessorGetUrl(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 129)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditCommonAutoAccessorGetUrlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditCommonAutoAccessorGetUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Common_auto_accessor_get_url",
        argNames: ["that"],
      );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetUserIsBanned(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 130)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetUserIsBannedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetUserIsBannedConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_user_is_banned",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetUserIsContributor(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 131)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetUserIsContributorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetUserIsContributorConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_user_is_contributor",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetUserIsModerator(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 132)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetUserIsModeratorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetUserIsModeratorConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_user_is_moderator",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetUserIsMuted(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 133)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetUserIsMutedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetUserIsMutedConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_user_is_muted",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditCommonAutoAccessorGetUserIsSubscriber(
      {required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 134)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorGetUserIsSubscriberConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorGetUserIsSubscriberConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_get_user_is_subscriber",
            argNames: ["that"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetAcceptFollowers(
      {required Common that, required bool acceptFollowers}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(acceptFollowers, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 135)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetAcceptFollowersConstMeta,
      argValues: [that, acceptFollowers],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetAcceptFollowersConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_accept_followers",
            argNames: ["that", "acceptFollowers"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetAllowedMediaInComments(
      {required Common that, required List<String> allowedMediaInComments}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_list_String(allowedMediaInComments, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 136)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetAllowedMediaInCommentsConstMeta,
      argValues: [that, allowedMediaInComments],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetAllowedMediaInCommentsConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_allowed_media_in_comments",
            argNames: ["that", "allowedMediaInComments"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetBannerImg(
      {required Common that, String? bannerImg}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_opt_String(bannerImg, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 137)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetBannerImgConstMeta,
      argValues: [that, bannerImg],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetBannerImgConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_banner_img",
            argNames: ["that", "bannerImg"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetBannerSize(
      {required Common that, Int64List? bannerSize}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_opt_list_prim_i_64_strict(bannerSize, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 138)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetBannerSizeConstMeta,
      argValues: [that, bannerSize],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetBannerSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_banner_size",
            argNames: ["that", "bannerSize"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetCreated(
      {required Common that, required double created}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_f_64(created, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 139)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditCommonAutoAccessorSetCreatedConstMeta,
      argValues: [that, created],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetCreatedConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_created",
            argNames: ["that", "created"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetCreatedUtc(
      {required Common that, required double createdUtc}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_f_64(createdUtc, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 140)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetCreatedUtcConstMeta,
      argValues: [that, createdUtc],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetCreatedUtcConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_created_utc",
            argNames: ["that", "createdUtc"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetDisableContributorRequests(
      {required Common that, required bool disableContributorRequests}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(disableContributorRequests, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 141)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetDisableContributorRequestsConstMeta,
      argValues: [that, disableContributorRequests],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetDisableContributorRequestsConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_disable_contributor_requests",
            argNames: ["that", "disableContributorRequests"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetDisplayName(
      {required Common that, required String displayName}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_String(displayName, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 142)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetDisplayNameConstMeta,
      argValues: [that, displayName],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetDisplayNameConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_display_name",
            argNames: ["that", "displayName"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetDisplayNamePrefixed(
      {required Common that, required String displayNamePrefixed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_String(displayNamePrefixed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 143)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetDisplayNamePrefixedConstMeta,
      argValues: [that, displayNamePrefixed],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetDisplayNamePrefixedConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_display_name_prefixed",
            argNames: ["that", "displayNamePrefixed"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetFreeFormReports(
      {required Common that, required bool freeFormReports}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(freeFormReports, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 144)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetFreeFormReportsConstMeta,
      argValues: [that, freeFormReports],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetFreeFormReportsConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_free_form_reports",
            argNames: ["that", "freeFormReports"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetHeaderImg(
      {required Common that, String? headerImg}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_opt_String(headerImg, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 145)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetHeaderImgConstMeta,
      argValues: [that, headerImg],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetHeaderImgConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_header_img",
            argNames: ["that", "headerImg"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetHeaderSize(
      {required Common that, Int64List? headerSize}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_opt_list_prim_i_64_strict(headerSize, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 146)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetHeaderSizeConstMeta,
      argValues: [that, headerSize],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetHeaderSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_header_size",
            argNames: ["that", "headerSize"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetKeyColor(
      {required Common that, String? keyColor}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_opt_String(keyColor, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 147)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditCommonAutoAccessorSetKeyColorConstMeta,
      argValues: [that, keyColor],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetKeyColorConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_key_color",
            argNames: ["that", "keyColor"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetLinkFlairEnabled(
      {required Common that, required bool linkFlairEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(linkFlairEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 148)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetLinkFlairEnabledConstMeta,
      argValues: [that, linkFlairEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetLinkFlairEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_link_flair_enabled",
            argNames: ["that", "linkFlairEnabled"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetLinkFlairPosition(
      {required Common that, String? linkFlairPosition}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_opt_String(linkFlairPosition, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 149)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetLinkFlairPositionConstMeta,
      argValues: [that, linkFlairPosition],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetLinkFlairPositionConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_link_flair_position",
            argNames: ["that", "linkFlairPosition"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetName(
      {required Common that, required Fullname name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 150)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditCommonAutoAccessorSetNameConstMeta,
      argValues: [that, name],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetNameConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_name",
            argNames: ["that", "name"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetPrimaryColor(
      {required Common that, String? primaryColor}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_opt_String(primaryColor, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 151)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetPrimaryColorConstMeta,
      argValues: [that, primaryColor],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetPrimaryColorConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_primary_color",
            argNames: ["that", "primaryColor"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetPublicDescription(
      {required Common that, String? publicDescription}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_opt_String(publicDescription, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 152)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetPublicDescriptionConstMeta,
      argValues: [that, publicDescription],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetPublicDescriptionConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_public_description",
            argNames: ["that", "publicDescription"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetQuarantine(
      {required Common that, required bool quarantine}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(quarantine, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 153)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetQuarantineConstMeta,
      argValues: [that, quarantine],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetQuarantineConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_quarantine",
            argNames: ["that", "quarantine"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetRestrictCommenting(
      {required Common that, required bool restrictCommenting}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(restrictCommenting, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 154)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetRestrictCommentingConstMeta,
      argValues: [that, restrictCommenting],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetRestrictCommentingConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_restrict_commenting",
            argNames: ["that", "restrictCommenting"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetRestrictPosting(
      {required Common that, required bool restrictPosting}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(restrictPosting, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 155)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetRestrictPostingConstMeta,
      argValues: [that, restrictPosting],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetRestrictPostingConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_restrict_posting",
            argNames: ["that", "restrictPosting"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetShowMedia(
      {required Common that, required bool showMedia}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(showMedia, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 156)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetShowMediaConstMeta,
      argValues: [that, showMedia],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetShowMediaConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_show_media",
            argNames: ["that", "showMedia"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetSubmitLinkLabel(
      {required Common that, String? submitLinkLabel}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_opt_String(submitLinkLabel, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 157)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetSubmitLinkLabelConstMeta,
      argValues: [that, submitLinkLabel],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetSubmitLinkLabelConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_submit_link_label",
            argNames: ["that", "submitLinkLabel"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetSubmitTextLabel(
      {required Common that, String? submitTextLabel}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_opt_String(submitTextLabel, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 158)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetSubmitTextLabelConstMeta,
      argValues: [that, submitTextLabel],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetSubmitTextLabelConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_submit_text_label",
            argNames: ["that", "submitTextLabel"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetSubredditType(
      {required Common that, String? subredditType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_opt_String(subredditType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 159)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetSubredditTypeConstMeta,
      argValues: [that, subredditType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetSubredditTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_subreddit_type",
            argNames: ["that", "subredditType"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetSubscribers(
      {required Common that, required PlatformInt64 subscribers}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_i_64(subscribers, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 160)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetSubscribersConstMeta,
      argValues: [that, subscribers],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetSubscribersConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_subscribers",
            argNames: ["that", "subscribers"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetTitle(
      {required Common that, String? title}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_opt_String(title, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 161)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditCommonAutoAccessorSetTitleConstMeta,
      argValues: [that, title],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetTitleConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_title",
            argNames: ["that", "title"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetUrl(
      {required Common that, required String url}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_String(url, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 162)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditCommonAutoAccessorSetUrlConstMeta,
      argValues: [that, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditCommonAutoAccessorSetUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Common_auto_accessor_set_url",
        argNames: ["that", "url"],
      );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetUserIsBanned(
      {required Common that, required bool userIsBanned}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(userIsBanned, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 163)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetUserIsBannedConstMeta,
      argValues: [that, userIsBanned],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetUserIsBannedConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_user_is_banned",
            argNames: ["that", "userIsBanned"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetUserIsContributor(
      {required Common that, required bool userIsContributor}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(userIsContributor, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 164)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetUserIsContributorConstMeta,
      argValues: [that, userIsContributor],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetUserIsContributorConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_user_is_contributor",
            argNames: ["that", "userIsContributor"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetUserIsModerator(
      {required Common that, required bool userIsModerator}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(userIsModerator, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 165)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetUserIsModeratorConstMeta,
      argValues: [that, userIsModerator],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetUserIsModeratorConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_user_is_moderator",
            argNames: ["that", "userIsModerator"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetUserIsMuted(
      {required Common that, required bool userIsMuted}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(userIsMuted, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 166)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetUserIsMutedConstMeta,
      argValues: [that, userIsMuted],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetUserIsMutedConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_user_is_muted",
            argNames: ["that", "userIsMuted"],
          );

  @override
  void redditApiModelSubredditCommonAutoAccessorSetUserIsSubscriber(
      {required Common that, required bool userIsSubscriber}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        sse_encode_bool(userIsSubscriber, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 167)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommonAutoAccessorSetUserIsSubscriberConstMeta,
      argValues: [that, userIsSubscriber],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommonAutoAccessorSetUserIsSubscriberConstMeta =>
          const TaskConstMeta(
            debugName: "Common_auto_accessor_set_user_is_subscriber",
            argNames: ["that", "userIsSubscriber"],
          );

  @override
  Future<Common> redditApiModelSubredditCommonDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 168, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditCommonDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditCommonDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Common_default",
        argNames: [],
      );

  @override
  SubredditIcon redditApiModelSubredditCommonIcon({required Common that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 169)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_subreddit_icon,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditCommonIconConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditCommonIconConstMeta =>
      const TaskConstMeta(
        debugName: "Common_icon",
        argNames: ["that"],
      );

  @override
  bool redditApiModelSubredditDetailsAutoAccessorGetDefaultSet(
      {required Details that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 170)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditDetailsAutoAccessorGetDefaultSetConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditDetailsAutoAccessorGetDefaultSetConstMeta =>
          const TaskConstMeta(
            debugName: "Details_auto_accessor_get_default_set",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditDetailsAutoAccessorGetDescription(
      {required Details that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 171)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditDetailsAutoAccessorGetDescriptionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditDetailsAutoAccessorGetDescriptionConstMeta =>
          const TaskConstMeta(
            debugName: "Details_auto_accessor_get_description",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditDetailsAutoAccessorGetIconColor(
      {required Details that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 172)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditDetailsAutoAccessorGetIconColorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditDetailsAutoAccessorGetIconColorConstMeta =>
          const TaskConstMeta(
            debugName: "Details_auto_accessor_get_icon_color",
            argNames: ["that"],
          );

  @override
  Common redditApiModelSubredditDetailsAutoAccessorGetOther(
      {required Details that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 173)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditDetailsAutoAccessorGetOtherConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditDetailsAutoAccessorGetOtherConstMeta =>
          const TaskConstMeta(
            debugName: "Details_auto_accessor_get_other",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditDetailsAutoAccessorGetOver18(
      {required Details that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 174)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditDetailsAutoAccessorGetOver18ConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditDetailsAutoAccessorGetOver18ConstMeta =>
          const TaskConstMeta(
            debugName: "Details_auto_accessor_get_over_18",
            argNames: ["that"],
          );

  @override
  List<String> redditApiModelSubredditDetailsAutoAccessorGetPreviousNames(
      {required Details that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 175)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditDetailsAutoAccessorGetPreviousNamesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditDetailsAutoAccessorGetPreviousNamesConstMeta =>
          const TaskConstMeta(
            debugName: "Details_auto_accessor_get_previous_names",
            argNames: ["that"],
          );

  @override
  void redditApiModelSubredditDetailsAutoAccessorSetDefaultSet(
      {required Details that, required bool defaultSet}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        sse_encode_bool(defaultSet, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 176)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditDetailsAutoAccessorSetDefaultSetConstMeta,
      argValues: [that, defaultSet],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditDetailsAutoAccessorSetDefaultSetConstMeta =>
          const TaskConstMeta(
            debugName: "Details_auto_accessor_set_default_set",
            argNames: ["that", "defaultSet"],
          );

  @override
  void redditApiModelSubredditDetailsAutoAccessorSetDescription(
      {required Details that, String? description}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        sse_encode_opt_String(description, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 177)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditDetailsAutoAccessorSetDescriptionConstMeta,
      argValues: [that, description],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditDetailsAutoAccessorSetDescriptionConstMeta =>
          const TaskConstMeta(
            debugName: "Details_auto_accessor_set_description",
            argNames: ["that", "description"],
          );

  @override
  void redditApiModelSubredditDetailsAutoAccessorSetIconColor(
      {required Details that, String? iconColor}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        sse_encode_opt_String(iconColor, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 178)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditDetailsAutoAccessorSetIconColorConstMeta,
      argValues: [that, iconColor],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditDetailsAutoAccessorSetIconColorConstMeta =>
          const TaskConstMeta(
            debugName: "Details_auto_accessor_set_icon_color",
            argNames: ["that", "iconColor"],
          );

  @override
  void redditApiModelSubredditDetailsAutoAccessorSetOther(
      {required Details that, required Common other}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            other, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 179)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditDetailsAutoAccessorSetOtherConstMeta,
      argValues: [that, other],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditDetailsAutoAccessorSetOtherConstMeta =>
          const TaskConstMeta(
            debugName: "Details_auto_accessor_set_other",
            argNames: ["that", "other"],
          );

  @override
  void redditApiModelSubredditDetailsAutoAccessorSetOver18(
      {required Details that, required bool over18}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        sse_encode_bool(over18, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 180)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditDetailsAutoAccessorSetOver18ConstMeta,
      argValues: [that, over18],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditDetailsAutoAccessorSetOver18ConstMeta =>
          const TaskConstMeta(
            debugName: "Details_auto_accessor_set_over_18",
            argNames: ["that", "over18"],
          );

  @override
  void redditApiModelSubredditDetailsAutoAccessorSetPreviousNames(
      {required Details that, required List<String> previousNames}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        sse_encode_list_String(previousNames, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 181)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditDetailsAutoAccessorSetPreviousNamesConstMeta,
      argValues: [that, previousNames],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditDetailsAutoAccessorSetPreviousNamesConstMeta =>
          const TaskConstMeta(
            debugName: "Details_auto_accessor_set_previous_names",
            argNames: ["that", "previousNames"],
          );

  @override
  Future<Details> redditApiModelSubredditDetailsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 182, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditDetailsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditDetailsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Details_default",
        argNames: [],
      );

  @override
  SubredditIcon redditApiModelSubredditDetailsIcon({required Details that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 183)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_subreddit_icon,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditDetailsIconConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditDetailsIconConstMeta =>
      const TaskConstMeta(
        debugName: "Details_icon",
        argNames: ["that"],
      );

  @override
  Future<BoxFeedStream> redditApiModelFeedFeedStreamNew(
      {required Client client,
      required Feed feed,
      required FeedSort sort,
      required Url baseUrl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        sse_encode_box_autoadd_feed(feed, serializer);
        sse_encode_box_autoadd_feed_sort(sort, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
            baseUrl, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 184, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxFeedStream,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFeedFeedStreamNewConstMeta,
      argValues: [client, feed, sort, baseUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFeedFeedStreamNewConstMeta =>
      const TaskConstMeta(
        debugName: "FeedStream_new",
        argNames: ["client", "feed", "sort", "baseUrl"],
      );

  @override
  Future<Fullname> redditApiModelFullnameDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 185, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFullnameDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFullnameDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Fullname_default",
        argNames: [],
      );

  @override
  Future<GalleryData> redditApiModelGalleryGalleryDataDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 186, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryData,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelGalleryGalleryDataDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelGalleryGalleryDataDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "GalleryData_default",
        argNames: [],
      );

  @override
  String redditApiModelGalleryGalleryMediaAutoAccessorGetMediaType(
      {required GalleryMedia that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 187)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelGalleryGalleryMediaAutoAccessorGetMediaTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelGalleryGalleryMediaAutoAccessorGetMediaTypeConstMeta =>
          const TaskConstMeta(
            debugName: "GalleryMedia_auto_accessor_get_media_type",
            argNames: ["that"],
          );

  @override
  void redditApiModelGalleryGalleryMediaAutoAccessorSetMediaType(
      {required GalleryMedia that, required String mediaType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
            that, serializer);
        sse_encode_String(mediaType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 188)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelGalleryGalleryMediaAutoAccessorSetMediaTypeConstMeta,
      argValues: [that, mediaType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelGalleryGalleryMediaAutoAccessorSetMediaTypeConstMeta =>
          const TaskConstMeta(
            debugName: "GalleryMedia_auto_accessor_set_media_type",
            argNames: ["that", "mediaType"],
          );

  @override
  Future<Gallery> redditApiModelGalleryGalleryDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 189, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelGalleryGalleryDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelGalleryGalleryDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Gallery_default",
        argNames: [],
      );

  @override
  Source redditApiModelGalleryGalleryGet(
      {required Gallery that, required int index}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
            that, serializer);
        sse_encode_u_32(index, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 190)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_source,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelGalleryGalleryGetConstMeta,
      argValues: [that, index],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelGalleryGalleryGetConstMeta =>
      const TaskConstMeta(
        debugName: "Gallery_get",
        argNames: ["that", "index"],
      );

  @override
  double redditApiModelGalleryGalleryGetAspectRatio({required Gallery that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 191)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelGalleryGalleryGetAspectRatioConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelGalleryGalleryGetAspectRatioConstMeta =>
      const TaskConstMeta(
        debugName: "Gallery_get_aspect_ratio(dart_style=aspect_ratio)",
        argNames: ["that"],
      );

  @override
  int redditApiModelGalleryGalleryGetLength({required Gallery that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 192)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelGalleryGalleryGetLengthConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelGalleryGalleryGetLengthConstMeta =>
      const TaskConstMeta(
        debugName: "Gallery_get_length(dart_style=length)",
        argNames: ["that"],
      );

  @override
  String? redditApiModelListingAutoAccessorGetAfter({required Listing that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 193)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorGetAfterConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorGetAfterConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_get_after",
        argNames: ["that"],
      );

  @override
  String? redditApiModelListingAutoAccessorGetBefore({required Listing that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 194)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorGetBeforeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorGetBeforeConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_get_before",
        argNames: ["that"],
      );

  @override
  List<Thing> redditApiModelListingAutoAccessorGetChildren(
      {required Listing that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 195)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_thing,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorGetChildrenConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorGetChildrenConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_get_children",
        argNames: ["that"],
      );

  @override
  int? redditApiModelListingAutoAccessorGetDist({required Listing that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 196)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorGetDistConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorGetDistConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_get_dist",
        argNames: ["that"],
      );

  @override
  String? redditApiModelListingAutoAccessorGetModhash({required Listing that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 197)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorGetModhashConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorGetModhashConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_get_modhash",
        argNames: ["that"],
      );

  @override
  void redditApiModelListingAutoAccessorSetAfter(
      {required Listing that, String? after}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        sse_encode_opt_String(after, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 198)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorSetAfterConstMeta,
      argValues: [that, after],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorSetAfterConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_set_after",
        argNames: ["that", "after"],
      );

  @override
  void redditApiModelListingAutoAccessorSetBefore(
      {required Listing that, String? before}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        sse_encode_opt_String(before, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 199)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorSetBeforeConstMeta,
      argValues: [that, before],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorSetBeforeConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_set_before",
        argNames: ["that", "before"],
      );

  @override
  void redditApiModelListingAutoAccessorSetChildren(
      {required Listing that, required List<Thing> children}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        sse_encode_list_thing(children, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 200)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorSetChildrenConstMeta,
      argValues: [that, children],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorSetChildrenConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_set_children",
        argNames: ["that", "children"],
      );

  @override
  void redditApiModelListingAutoAccessorSetDist(
      {required Listing that, int? dist}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        sse_encode_opt_box_autoadd_u_32(dist, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 201)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorSetDistConstMeta,
      argValues: [that, dist],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorSetDistConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_set_dist",
        argNames: ["that", "dist"],
      );

  @override
  void redditApiModelListingAutoAccessorSetModhash(
      {required Listing that, String? modhash}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        sse_encode_opt_String(modhash, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 202)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorSetModhashConstMeta,
      argValues: [that, modhash],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorSetModhashConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_set_modhash",
        argNames: ["that", "modhash"],
      );

  @override
  Future<Listing> redditApiModelListingDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 203, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_default",
        argNames: [],
      );

  @override
  Future<BoxMultiStream> redditApiModelMultiMultiStreamNew(
      {required Client client,
      required Multi multi,
      required FeedSort sort,
      required Url baseUrl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            multi, serializer);
        sse_encode_box_autoadd_feed_sort(sort, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
            baseUrl, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 204, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxMultiStream,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiStreamNewConstMeta,
      argValues: [client, multi, sort, baseUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiStreamNewConstMeta =>
      const TaskConstMeta(
        debugName: "MultiStream_new",
        argNames: ["client", "multi", "sort", "baseUrl"],
      );

  @override
  bool redditApiModelMultiMultiAutoAccessorGetCanEdit({required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 205)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetCanEditConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorGetCanEditConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_get_can_edit",
        argNames: ["that"],
      );

  @override
  String? redditApiModelMultiMultiAutoAccessorGetCopiedFrom(
      {required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 206)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetCopiedFromConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorGetCopiedFromConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_get_copied_from",
            argNames: ["that"],
          );

  @override
  double redditApiModelMultiMultiAutoAccessorGetCreated({required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 207)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetCreatedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorGetCreatedConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_get_created",
        argNames: ["that"],
      );

  @override
  double redditApiModelMultiMultiAutoAccessorGetCreatedUtc(
      {required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 208)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetCreatedUtcConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorGetCreatedUtcConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_get_created_utc",
            argNames: ["that"],
          );

  @override
  String redditApiModelMultiMultiAutoAccessorGetDescriptionHtml(
      {required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 209)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelMultiMultiAutoAccessorGetDescriptionHtmlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorGetDescriptionHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_get_description_html",
            argNames: ["that"],
          );

  @override
  String redditApiModelMultiMultiAutoAccessorGetDescriptionMd(
      {required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 210)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetDescriptionMdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorGetDescriptionMdConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_get_description_md",
            argNames: ["that"],
          );

  @override
  String redditApiModelMultiMultiAutoAccessorGetDisplayName(
      {required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 211)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetDisplayNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorGetDisplayNameConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_get_display_name",
            argNames: ["that"],
          );

  @override
  String redditApiModelMultiMultiAutoAccessorGetIconUrl({required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 212)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetIconUrlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorGetIconUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_get_icon_url",
        argNames: ["that"],
      );

  @override
  bool redditApiModelMultiMultiAutoAccessorGetIsFavorited(
      {required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 213)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetIsFavoritedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorGetIsFavoritedConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_get_is_favorited",
            argNames: ["that"],
          );

  @override
  bool redditApiModelMultiMultiAutoAccessorGetIsSubscriber(
      {required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 214)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetIsSubscriberConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorGetIsSubscriberConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_get_is_subscriber",
            argNames: ["that"],
          );

  @override
  String? redditApiModelMultiMultiAutoAccessorGetKeyColor(
      {required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 215)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetKeyColorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorGetKeyColorConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_get_key_color",
        argNames: ["that"],
      );

  @override
  Fullname redditApiModelMultiMultiAutoAccessorGetName({required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 216)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorGetNameConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_get_name",
        argNames: ["that"],
      );

  @override
  PlatformInt64 redditApiModelMultiMultiAutoAccessorGetNumSubscribers(
      {required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 217)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelMultiMultiAutoAccessorGetNumSubscribersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorGetNumSubscribersConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_get_num_subscribers",
            argNames: ["that"],
          );

  @override
  bool redditApiModelMultiMultiAutoAccessorGetOver18({required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 218)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetOver18ConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorGetOver18ConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_get_over_18",
        argNames: ["that"],
      );

  @override
  String redditApiModelMultiMultiAutoAccessorGetOwner({required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 219)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetOwnerConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorGetOwnerConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_get_owner",
        argNames: ["that"],
      );

  @override
  String redditApiModelMultiMultiAutoAccessorGetOwnerId({required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 220)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetOwnerIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorGetOwnerIdConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_get_owner_id",
        argNames: ["that"],
      );

  @override
  String redditApiModelMultiMultiAutoAccessorGetPath({required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 221)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetPathConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorGetPathConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_get_path",
        argNames: ["that"],
      );

  @override
  List<SubredditDetails> redditApiModelMultiMultiAutoAccessorGetSubreddits(
      {required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 222)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_subreddit_details,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetSubredditsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorGetSubredditsConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_get_subreddits",
            argNames: ["that"],
          );

  @override
  String redditApiModelMultiMultiAutoAccessorGetVisibility(
      {required Multi that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 223)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorGetVisibilityConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorGetVisibilityConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_get_visibility",
            argNames: ["that"],
          );

  @override
  void redditApiModelMultiMultiAutoAccessorSetCanEdit(
      {required Multi that, required bool canEdit}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_bool(canEdit, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 224)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetCanEditConstMeta,
      argValues: [that, canEdit],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorSetCanEditConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_set_can_edit",
        argNames: ["that", "canEdit"],
      );

  @override
  void redditApiModelMultiMultiAutoAccessorSetCopiedFrom(
      {required Multi that, String? copiedFrom}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_opt_String(copiedFrom, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 225)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetCopiedFromConstMeta,
      argValues: [that, copiedFrom],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorSetCopiedFromConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_set_copied_from",
            argNames: ["that", "copiedFrom"],
          );

  @override
  void redditApiModelMultiMultiAutoAccessorSetCreated(
      {required Multi that, required double created}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_f_64(created, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 226)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetCreatedConstMeta,
      argValues: [that, created],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorSetCreatedConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_set_created",
        argNames: ["that", "created"],
      );

  @override
  void redditApiModelMultiMultiAutoAccessorSetCreatedUtc(
      {required Multi that, required double createdUtc}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_f_64(createdUtc, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 227)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetCreatedUtcConstMeta,
      argValues: [that, createdUtc],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorSetCreatedUtcConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_set_created_utc",
            argNames: ["that", "createdUtc"],
          );

  @override
  void redditApiModelMultiMultiAutoAccessorSetDescriptionHtml(
      {required Multi that, required String descriptionHtml}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_String(descriptionHtml, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 228)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelMultiMultiAutoAccessorSetDescriptionHtmlConstMeta,
      argValues: [that, descriptionHtml],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorSetDescriptionHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_set_description_html",
            argNames: ["that", "descriptionHtml"],
          );

  @override
  void redditApiModelMultiMultiAutoAccessorSetDescriptionMd(
      {required Multi that, required String descriptionMd}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_String(descriptionMd, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 229)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetDescriptionMdConstMeta,
      argValues: [that, descriptionMd],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorSetDescriptionMdConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_set_description_md",
            argNames: ["that", "descriptionMd"],
          );

  @override
  void redditApiModelMultiMultiAutoAccessorSetDisplayName(
      {required Multi that, required String displayName}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_String(displayName, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 230)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetDisplayNameConstMeta,
      argValues: [that, displayName],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorSetDisplayNameConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_set_display_name",
            argNames: ["that", "displayName"],
          );

  @override
  void redditApiModelMultiMultiAutoAccessorSetIconUrl(
      {required Multi that, required String iconUrl}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_String(iconUrl, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 231)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetIconUrlConstMeta,
      argValues: [that, iconUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorSetIconUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_set_icon_url",
        argNames: ["that", "iconUrl"],
      );

  @override
  void redditApiModelMultiMultiAutoAccessorSetIsFavorited(
      {required Multi that, required bool isFavorited}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_bool(isFavorited, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 232)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetIsFavoritedConstMeta,
      argValues: [that, isFavorited],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorSetIsFavoritedConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_set_is_favorited",
            argNames: ["that", "isFavorited"],
          );

  @override
  void redditApiModelMultiMultiAutoAccessorSetIsSubscriber(
      {required Multi that, required bool isSubscriber}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_bool(isSubscriber, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 233)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetIsSubscriberConstMeta,
      argValues: [that, isSubscriber],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorSetIsSubscriberConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_set_is_subscriber",
            argNames: ["that", "isSubscriber"],
          );

  @override
  void redditApiModelMultiMultiAutoAccessorSetKeyColor(
      {required Multi that, String? keyColor}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_opt_String(keyColor, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 234)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetKeyColorConstMeta,
      argValues: [that, keyColor],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorSetKeyColorConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_set_key_color",
        argNames: ["that", "keyColor"],
      );

  @override
  void redditApiModelMultiMultiAutoAccessorSetName(
      {required Multi that, required Fullname name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 235)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetNameConstMeta,
      argValues: [that, name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorSetNameConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_set_name",
        argNames: ["that", "name"],
      );

  @override
  void redditApiModelMultiMultiAutoAccessorSetNumSubscribers(
      {required Multi that, required PlatformInt64 numSubscribers}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_i_64(numSubscribers, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 236)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelMultiMultiAutoAccessorSetNumSubscribersConstMeta,
      argValues: [that, numSubscribers],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorSetNumSubscribersConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_set_num_subscribers",
            argNames: ["that", "numSubscribers"],
          );

  @override
  void redditApiModelMultiMultiAutoAccessorSetOver18(
      {required Multi that, required bool over18}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_bool(over18, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 237)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetOver18ConstMeta,
      argValues: [that, over18],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorSetOver18ConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_set_over_18",
        argNames: ["that", "over18"],
      );

  @override
  void redditApiModelMultiMultiAutoAccessorSetOwner(
      {required Multi that, required String owner}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_String(owner, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 238)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetOwnerConstMeta,
      argValues: [that, owner],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorSetOwnerConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_set_owner",
        argNames: ["that", "owner"],
      );

  @override
  void redditApiModelMultiMultiAutoAccessorSetOwnerId(
      {required Multi that, required String ownerId}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_String(ownerId, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 239)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetOwnerIdConstMeta,
      argValues: [that, ownerId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorSetOwnerIdConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_set_owner_id",
        argNames: ["that", "ownerId"],
      );

  @override
  void redditApiModelMultiMultiAutoAccessorSetPath(
      {required Multi that, required String path}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_String(path, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 240)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetPathConstMeta,
      argValues: [that, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiAutoAccessorSetPathConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_auto_accessor_set_path",
        argNames: ["that", "path"],
      );

  @override
  void redditApiModelMultiMultiAutoAccessorSetSubreddits(
      {required Multi that, required List<SubredditDetails> subreddits}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_list_subreddit_details(subreddits, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 241)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetSubredditsConstMeta,
      argValues: [that, subreddits],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorSetSubredditsConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_set_subreddits",
            argNames: ["that", "subreddits"],
          );

  @override
  void redditApiModelMultiMultiAutoAccessorSetVisibility(
      {required Multi that, required String visibility}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            that, serializer);
        sse_encode_String(visibility, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 242)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiAutoAccessorSetVisibilityConstMeta,
      argValues: [that, visibility],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelMultiMultiAutoAccessorSetVisibilityConstMeta =>
          const TaskConstMeta(
            debugName: "Multi_auto_accessor_set_visibility",
            argNames: ["that", "visibility"],
          );

  @override
  Future<Multi> redditApiModelMultiMultiDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 243, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Multi_default",
        argNames: [],
      );

  @override
  Future<Url> redditApiClientPagerAddToUrl(
      {required Pager that, required Url url}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
            url, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 244, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientPagerAddToUrlConstMeta,
      argValues: [that, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientPagerAddToUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Pager_add_to_url",
        argNames: ["that", "url"],
      );

  @override
  Future<void> redditApiClientPagerAfter({required Pager that, String? after}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
            that, serializer);
        sse_encode_opt_String(after, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 245, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientPagerAfterConstMeta,
      argValues: [that, after],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientPagerAfterConstMeta => const TaskConstMeta(
        debugName: "Pager_after",
        argNames: ["that", "after"],
      );

  @override
  Future<void> redditApiClientPagerBefore(
      {required Pager that, String? before}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
            that, serializer);
        sse_encode_opt_String(before, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 246, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientPagerBeforeConstMeta,
      argValues: [that, before],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientPagerBeforeConstMeta => const TaskConstMeta(
        debugName: "Pager_before",
        argNames: ["that", "before"],
      );

  @override
  Future<Pager> redditApiClientPagerDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 247, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientPagerDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientPagerDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Pager_default",
        argNames: [],
      );

  @override
  Future<PostId> redditApiModelPostPostIdDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 248, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostIdDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostIdDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "PostId_default",
        argNames: [],
      );

  @override
  Future<Post> redditApiModelPostPostDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 249, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Post_default",
        argNames: [],
      );

  @override
  Future<List<String?>> redditApiModelPostPostGetAllAwardings(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 250, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetAllAwardingsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetAllAwardingsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_all_awardings",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetAllowLiveComments(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 251, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetAllowLiveCommentsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetAllowLiveCommentsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_allow_live_comments",
        argNames: ["that"],
      );

  @override
  Future<double?> redditApiModelPostPostGetApprovedAtUtc({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 252, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_f_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetApprovedAtUtcConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetApprovedAtUtcConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_approved_at_utc",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetApprovedBy({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 253, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetApprovedByConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetApprovedByConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_approved_by",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetArchived({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 254, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetArchivedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetArchivedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_archived",
        argNames: ["that"],
      );

  @override
  AuthorInfo? redditApiModelPostPostGetAuthor({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 255)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_author_info,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetAuthorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetAuthorConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_author(dart_style=author)",
        argNames: ["that"],
      );

  @override
  Future<List<String?>> redditApiModelPostPostGetAwarders(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 256, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetAwardersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetAwardersConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_awarders",
        argNames: ["that"],
      );

  @override
  Future<double?> redditApiModelPostPostGetBannedAtUtc({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 257, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_f_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetBannedAtUtcConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetBannedAtUtcConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_banned_at_utc",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetCanGild({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 258, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetCanGildConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetCanGildConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_can_gild",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetCanModPost({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 259, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetCanModPostConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetCanModPostConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_can_mod_post",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetCategory({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 260, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetCategoryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetCategoryConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_category",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetClicked({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 261, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetClickedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetClickedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_clicked",
        argNames: ["that"],
      );

  @override
  Future<List<String>> redditApiModelPostPostGetContentCategories(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 262, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetContentCategoriesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetContentCategoriesConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_content_categories",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetContestMode({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 263, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetContestModeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetContestModeConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_contest_mode",
        argNames: ["that"],
      );

  @override
  Future<DateTime> redditApiModelPostPostGetCreated({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 264, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Chrono_Local,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetCreatedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetCreatedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_created",
        argNames: ["that"],
      );

  @override
  DateTime redditApiModelPostPostGetCreatedUtc({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 265)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Chrono_Utc,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetCreatedUtcConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetCreatedUtcConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_created_utc(dart_style=created_utc)",
        argNames: ["that"],
      );

  @override
  List<Post> redditApiModelPostPostGetCrosspostParentList(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 266)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetCrosspostParentListConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetCrosspostParentListConstMeta =>
      const TaskConstMeta(
        debugName:
            "Post_get_crosspost_parent_list(dart_style=crosspost_parent_list)",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetDiscussionType(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 267, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetDiscussionTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetDiscussionTypeConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_discussion_type",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetDistinguished({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 268, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetDistinguishedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetDistinguishedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_distinguished",
        argNames: ["that"],
      );

  @override
  String redditApiModelPostPostGetDomain({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 269)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetDomainConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetDomainConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_domain(dart_style=domain)",
        argNames: ["that"],
      );

  @override
  int redditApiModelPostPostGetDowns({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 270)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetDownsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetDownsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_downs(dart_style=downs)",
        argNames: ["that"],
      );

  @override
  double? redditApiModelPostPostGetEdited({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 271)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_f_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetEditedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetEditedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_edited(dart_style=edited)",
        argNames: ["that"],
      );

  @override
  Gallery? redditApiModelPostPostGetGallery({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 272)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetGalleryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetGalleryConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_gallery(dart_style=gallery)",
        argNames: ["that"],
      );

  @override
  Future<int> redditApiModelPostPostGetGilded({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 273, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetGildedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetGildedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_gilded",
        argNames: ["that"],
      );

  @override
  Future<Gildings> redditApiModelPostPostGetGildings({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 274, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_gildings,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetGildingsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetGildingsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_gildings",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetHidden({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 275, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetHiddenConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetHiddenConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_hidden",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetHideScore({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 276, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetHideScoreConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetHideScoreConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_hide_score",
        argNames: ["that"],
      );

  @override
  PostId redditApiModelPostPostGetId({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 277)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetIdConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_id(dart_style=id)",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetIsCreatedFromAdsUi(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 278, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetIsCreatedFromAdsUiConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetIsCreatedFromAdsUiConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_is_created_from_ads_ui",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetIsCrosspostable({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 279, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetIsCrosspostableConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetIsCrosspostableConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_is_crosspostable",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetIsGallery({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 280, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetIsGalleryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetIsGalleryConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_is_gallery",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetIsMeta({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 281, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetIsMetaConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetIsMetaConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_is_meta",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetIsOriginalContent(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 282, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetIsOriginalContentConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetIsOriginalContentConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_is_original_content",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostGetIsRedditMediaDomain({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 283)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetIsRedditMediaDomainConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetIsRedditMediaDomainConstMeta =>
      const TaskConstMeta(
        debugName:
            "Post_get_is_reddit_media_domain(dart_style=is_reddit_media_domain)",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetIsRobotIndexable({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 284, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetIsRobotIndexableConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetIsRobotIndexableConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_is_robot_indexable",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostGetIsSelf({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 285)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetIsSelfConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetIsSelfConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_is_self(dart_style=is_self)",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetIsVideo({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 286, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetIsVideoConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetIsVideoConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_is_video",
        argNames: ["that"],
      );

  @override
  bool? redditApiModelPostPostGetLikes({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 287)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetLikesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetLikesConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_likes(dart_style=likes)",
        argNames: ["that"],
      );

  @override
  Flair redditApiModelPostPostGetLinkFlair({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 288)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_flair,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetLinkFlairConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetLinkFlairConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_link_flair(dart_style=link_flair)",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostGetLocked({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 289)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetLockedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetLockedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_locked(dart_style=locked)",
        argNames: ["that"],
      );

  @override
  Media? redditApiModelPostPostGetMedia({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 290)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_media,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetMediaConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetMediaConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_media(dart_style=media)",
        argNames: ["that"],
      );

  @override
  MediaEmbed? redditApiModelPostPostGetMediaEmbed({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 291)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_media_embed,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetMediaEmbedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetMediaEmbedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_media_embed(dart_style=media_embed)",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetMediaOnly({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 292, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetMediaOnlyConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetMediaOnlyConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_media_only",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetModNote({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 293, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetModNoteConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetModNoteConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_mod_note",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetModReasonBy({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 294, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetModReasonByConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetModReasonByConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_mod_reason_by",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetModReasonTitle(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 295, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetModReasonTitleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetModReasonTitleConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_mod_reason_title",
        argNames: ["that"],
      );

  @override
  Future<List<String?>> redditApiModelPostPostGetModReports(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 296, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetModReportsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetModReportsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_mod_reports",
        argNames: ["that"],
      );

  @override
  Fullname redditApiModelPostPostGetName({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 297)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetNameConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_name(dart_style=name)",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetNoFollow({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 298, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetNoFollowConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetNoFollowConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_no_follow",
        argNames: ["that"],
      );

  @override
  int redditApiModelPostPostGetNumComments({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 299)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetNumCommentsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetNumCommentsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_num_comments(dart_style=num_comments)",
        argNames: ["that"],
      );

  @override
  Future<int?> redditApiModelPostPostGetNumCrossposts({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 300, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetNumCrosspostsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetNumCrosspostsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_num_crossposts",
        argNames: ["that"],
      );

  @override
  Future<int?> redditApiModelPostPostGetNumDuplicates({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 301, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetNumDuplicatesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetNumDuplicatesConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_num_duplicates",
        argNames: ["that"],
      );

  @override
  Future<int?> redditApiModelPostPostGetNumReports({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 302, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetNumReportsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetNumReportsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_num_reports",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostGetOver18({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 303)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetOver18ConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetOver18ConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_over_18(dart_style=over_18)",
        argNames: ["that"],
      );

  @override
  String redditApiModelPostPostGetPermalink({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 304)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetPermalinkConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetPermalinkConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_permalink(dart_style=permalink)",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostGetPinned({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 305)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetPinnedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetPinnedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_pinned(dart_style=pinned)",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetPostHint({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 306, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetPostHintConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetPostHintConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_post_hint",
        argNames: ["that"],
      );

  @override
  Preview? redditApiModelPostPostGetPreview({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 307)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_preview,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetPreviewConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetPreviewConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_preview(dart_style=preview)",
        argNames: ["that"],
      );

  @override
  Future<int?> redditApiModelPostPostGetPwls({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 308, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_i_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetPwlsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetPwlsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_pwls",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetQuarantine({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 309, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetQuarantineConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetQuarantineConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_quarantine",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetRemovalReason({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 310, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetRemovalReasonConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetRemovalReasonConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_removal_reason",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetRemovedBy({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 311, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetRemovedByConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetRemovedByConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_removed_by",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetRemovedByCategory(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 312, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetRemovedByCategoryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetRemovedByCategoryConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_removed_by_category",
        argNames: ["that"],
      );

  @override
  Future<List<String>> redditApiModelPostPostGetReportReasons(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 313, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetReportReasonsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetReportReasonsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_report_reasons",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostGetSaved({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 314)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetSavedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetSavedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_saved(dart_style=saved)",
        argNames: ["that"],
      );

  @override
  int redditApiModelPostPostGetScore({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 315)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetScoreConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetScoreConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_score(dart_style=score)",
        argNames: ["that"],
      );

  @override
  Media? redditApiModelPostPostGetSecureMedia({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 316)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_media,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetSecureMediaConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetSecureMediaConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_secure_media(dart_style=secure_media)",
        argNames: ["that"],
      );

  @override
  SecureMediaEmbed? redditApiModelPostPostGetSecureMediaEmbed(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 317)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_secure_media_embed,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetSecureMediaEmbedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetSecureMediaEmbedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_secure_media_embed(dart_style=secure_media_embed)",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostGetSelftext({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 318)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetSelftextConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetSelftextConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_selftext(dart_style=selftext)",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostGetSelftextHtml({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 319)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetSelftextHtmlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetSelftextHtmlConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_selftext_html(dart_style=selftext_html)",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetSendReplies({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 320, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetSendRepliesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetSendRepliesConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_send_replies",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostGetSpoiler({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 321)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetSpoilerConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetSpoilerConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_spoiler(dart_style=spoiler)",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostGetStickied({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 322)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetStickiedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetStickiedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_stickied(dart_style=stickied)",
        argNames: ["that"],
      );

  @override
  SubredditInfo redditApiModelPostPostGetSubreddit({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 323)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetSubredditConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetSubredditConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_subreddit(dart_style=subreddit)",
        argNames: ["that"],
      );

  @override
  CommentSort? redditApiModelPostPostGetSuggestedSort({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 324)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_comment_sort,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetSuggestedSortConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetSuggestedSortConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_suggested_sort(dart_style=suggested_sort)",
        argNames: ["that"],
      );

  @override
  String redditApiModelPostPostGetTitle({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 325)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetTitleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetTitleConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_title(dart_style=title)",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetTopAwardedType(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 326, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetTopAwardedTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetTopAwardedTypeConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_top_awarded_type",
        argNames: ["that"],
      );

  @override
  Future<int?> redditApiModelPostPostGetTotalAwardsReceived(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 327, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetTotalAwardsReceivedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetTotalAwardsReceivedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_total_awards_received",
        argNames: ["that"],
      );

  @override
  Future<List<String?>> redditApiModelPostPostGetTreatmentTags(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 328, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetTreatmentTagsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetTreatmentTagsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_treatment_tags",
        argNames: ["that"],
      );

  @override
  int redditApiModelPostPostGetUps({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 329)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetUpsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetUpsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_ups(dart_style=ups)",
        argNames: ["that"],
      );

  @override
  double redditApiModelPostPostGetUpvoteRatio({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 330)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetUpvoteRatioConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetUpvoteRatioConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_upvote_ratio(dart_style=upvote_ratio)",
        argNames: ["that"],
      );

  @override
  String redditApiModelPostPostGetUrl({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 331)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetUrlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_url(dart_style=url)",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostGetUrlOverriddenByDest({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 332)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetUrlOverriddenByDestConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetUrlOverriddenByDestConstMeta =>
      const TaskConstMeta(
        debugName:
            "Post_get_url_overridden_by_dest(dart_style=url_overridden_by_dest)",
        argNames: ["that"],
      );

  @override
  Future<List<String?>> redditApiModelPostPostGetUserReports(
      {required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 333, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetUserReportsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetUserReportsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_user_reports",
        argNames: ["that"],
      );

  @override
  Future<String?> redditApiModelPostPostGetViewCount({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 334, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetViewCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetViewCountConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_view_count",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiModelPostPostGetVisited({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 335, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetVisitedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetVisitedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_visited",
        argNames: ["that"],
      );

  @override
  Future<int?> redditApiModelPostPostGetWls({required Post that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 336, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_i_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostGetWlsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostGetWlsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_get_wls",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostIsCrosspost({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 337)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostIsCrosspostConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostIsCrosspostConstMeta =>
      const TaskConstMeta(
        debugName: "Post_is_crosspost",
        argNames: ["that"],
      );

  @override
  Kind redditApiModelPostPostKind({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 338)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_kind,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostKindConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostKindConstMeta => const TaskConstMeta(
        debugName: "Post_kind",
        argNames: ["that"],
      );

  @override
  Future<void> redditApiModelPostPostSave(
      {required Post that, required Client client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 339, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiModelPostPostSaveConstMeta,
      argValues: [that, client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostSaveConstMeta => const TaskConstMeta(
        debugName: "Post_save",
        argNames: ["that", "client"],
      );

  @override
  Thumbnail? redditApiModelPostPostThumbnail({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 340)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_thumbnail,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostThumbnailConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostThumbnailConstMeta =>
      const TaskConstMeta(
        debugName: "Post_thumbnail",
        argNames: ["that"],
      );

  @override
  Future<void> redditApiModelPostPostUnsave(
      {required Post that, required Client client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 341, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiModelPostPostUnsaveConstMeta,
      argValues: [that, client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostUnsaveConstMeta =>
      const TaskConstMeta(
        debugName: "Post_unsave",
        argNames: ["that", "client"],
      );

  @override
  Future<void> redditApiModelPostPostVote(
      {required Post that,
      required VoteDirection direction,
      required Client client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_vote_direction(direction, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 342, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiModelPostPostVoteConstMeta,
      argValues: [that, direction, client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostVoteConstMeta => const TaskConstMeta(
        debugName: "Post_vote",
        argNames: ["that", "direction", "client"],
      );

  @override
  SearchPost redditApiSearchSearchPostNew(
      {required Client client,
      String? subreddit,
      Flair? flair,
      String? query,
      required PostSearchSort sort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        sse_encode_opt_String(subreddit, serializer);
        sse_encode_opt_box_autoadd_flair(flair, serializer);
        sse_encode_opt_String(query, serializer);
        sse_encode_box_autoadd_post_search_sort(sort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 343)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchPost,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiSearchSearchPostNewConstMeta,
      argValues: [client, subreddit, flair, query, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiSearchSearchPostNewConstMeta =>
      const TaskConstMeta(
        debugName: "SearchPost_new",
        argNames: ["client", "subreddit", "flair", "query", "sort"],
      );

  @override
  SearchSubreddit redditApiSearchSearchSubredditNew(
      {required Client client,
      required String query,
      required SubredditSearchSort sort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        sse_encode_String(query, serializer);
        sse_encode_subreddit_search_sort(sort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 344)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchSubreddit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiSearchSearchSubredditNewConstMeta,
      argValues: [client, query, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiSearchSearchSubredditNewConstMeta =>
      const TaskConstMeta(
        debugName: "SearchSubreddit_new",
        argNames: ["client", "query", "sort"],
      );

  @override
  List<Thing> redditApiStreamableStreamableGetAll({required Streamable that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 345)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_thing,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiStreamableStreamableGetAllConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiStreamableStreamableGetAllConstMeta =>
      const TaskConstMeta(
        debugName: "Streamable_get_all",
        argNames: ["that"],
      );

  @override
  int redditApiStreamableStreamableGetLength({required Streamable that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 346)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiStreamableStreamableGetLengthConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiStreamableStreamableGetLengthConstMeta =>
      const TaskConstMeta(
        debugName: "Streamable_get_length(dart_style=length)",
        argNames: ["that"],
      );

  @override
  Future<bool> redditApiStreamableStreamableNext({required Streamable that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 347, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiStreamableStreamableNextConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiStreamableStreamableNextConstMeta =>
      const TaskConstMeta(
        debugName: "Streamable_next",
        argNames: ["that"],
      );

  @override
  Thing? redditApiStreamableStreamableNth(
      {required Streamable that, required int n}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
            that, serializer);
        sse_encode_u_32(n, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 348)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_thing,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiStreamableStreamableNthConstMeta,
      argValues: [that, n],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiStreamableStreamableNthConstMeta =>
      const TaskConstMeta(
        debugName: "Streamable_nth",
        argNames: ["that", "n"],
      );

  @override
  Future<void> redditApiStreamableStreamableRefresh(
      {required Streamable that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 349, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiStreamableStreamableRefreshConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiStreamableStreamableRefreshConstMeta =>
      const TaskConstMeta(
        debugName: "Streamable_refresh",
        argNames: ["that"],
      );

  @override
  Future<void> redditApiStreamableStreamableSave(
      {required Streamable that,
      required Fullname name,
      required bool save,
      required Client client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            name, serializer);
        sse_encode_bool(save, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 350, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiStreamableStreamableSaveConstMeta,
      argValues: [that, name, save, client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiStreamableStreamableSaveConstMeta =>
      const TaskConstMeta(
        debugName: "Streamable_save",
        argNames: ["that", "name", "save", "client"],
      );

  @override
  Future<void> redditApiStreamableStreamableVote(
      {required Streamable that,
      required Fullname name,
      required VoteDirection direction,
      required Client client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            name, serializer);
        sse_encode_vote_direction(direction, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 351, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiStreamableStreamableVoteConstMeta,
      argValues: [that, name, direction, client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiStreamableStreamableVoteConstMeta =>
      const TaskConstMeta(
        debugName: "Streamable_vote",
        argNames: ["that", "name", "direction", "client"],
      );

  @override
  Future<SubredditId> redditApiModelSubredditSubredditIdDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 352, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditIdDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditSubredditIdDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "SubredditId_default",
        argNames: [],
      );

  @override
  Details? redditApiModelSubredditSubredditInfoAutoAccessorGetDetails(
      {required SubredditInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 353)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditInfoAutoAccessorGetDetailsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditInfoAutoAccessorGetDetailsConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_get_details",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditInfoAutoAccessorGetSubreddit(
      {required SubredditInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 354)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditInfoAutoAccessorGetSubredditConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditInfoAutoAccessorGetSubredditConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_get_subreddit",
            argNames: ["that"],
          );

  @override
  SubredditId redditApiModelSubredditSubredditInfoAutoAccessorGetSubredditId(
      {required SubredditInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 355)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditInfoAutoAccessorGetSubredditIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditInfoAutoAccessorGetSubredditIdConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_get_subreddit_id",
            argNames: ["that"],
          );

  @override
  String
      redditApiModelSubredditSubredditInfoAutoAccessorGetSubredditNamePrefixed(
          {required SubredditInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 356)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditInfoAutoAccessorGetSubredditNamePrefixedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditInfoAutoAccessorGetSubredditNamePrefixedConstMeta =>
          const TaskConstMeta(
            debugName:
                "SubredditInfo_auto_accessor_get_subreddit_name_prefixed",
            argNames: ["that"],
          );

  @override
  int redditApiModelSubredditSubredditInfoAutoAccessorGetSubscribers(
      {required SubredditInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 357)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditInfoAutoAccessorGetSubscribersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditInfoAutoAccessorGetSubscribersConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_get_subscribers",
            argNames: ["that"],
          );

  @override
  void redditApiModelSubredditSubredditInfoAutoAccessorSetDetails(
      {required SubredditInfo that, Details? details}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            details, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 358)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditInfoAutoAccessorSetDetailsConstMeta,
      argValues: [that, details],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditInfoAutoAccessorSetDetailsConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_set_details",
            argNames: ["that", "details"],
          );

  @override
  void redditApiModelSubredditSubredditInfoAutoAccessorSetSubreddit(
      {required SubredditInfo that, required String subreddit}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        sse_encode_String(subreddit, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 359)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditInfoAutoAccessorSetSubredditConstMeta,
      argValues: [that, subreddit],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditInfoAutoAccessorSetSubredditConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_set_subreddit",
            argNames: ["that", "subreddit"],
          );

  @override
  void redditApiModelSubredditSubredditInfoAutoAccessorSetSubredditId(
      {required SubredditInfo that, required SubredditId subredditId}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
            subredditId, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 360)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditInfoAutoAccessorSetSubredditIdConstMeta,
      argValues: [that, subredditId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditInfoAutoAccessorSetSubredditIdConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_set_subreddit_id",
            argNames: ["that", "subredditId"],
          );

  @override
  void redditApiModelSubredditSubredditInfoAutoAccessorSetSubredditNamePrefixed(
      {required SubredditInfo that, required String subredditNamePrefixed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        sse_encode_String(subredditNamePrefixed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 361)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditInfoAutoAccessorSetSubredditNamePrefixedConstMeta,
      argValues: [that, subredditNamePrefixed],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditInfoAutoAccessorSetSubredditNamePrefixedConstMeta =>
          const TaskConstMeta(
            debugName:
                "SubredditInfo_auto_accessor_set_subreddit_name_prefixed",
            argNames: ["that", "subredditNamePrefixed"],
          );

  @override
  void redditApiModelSubredditSubredditInfoAutoAccessorSetSubscribers(
      {required SubredditInfo that, required int subscribers}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        sse_encode_u_32(subscribers, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 362)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditInfoAutoAccessorSetSubscribersConstMeta,
      argValues: [that, subscribers],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditInfoAutoAccessorSetSubscribersConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_set_subscribers",
            argNames: ["that", "subscribers"],
          );

  @override
  Future<SubredditInfo> redditApiModelSubredditSubredditInfoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 363, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditInfoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditSubredditInfoDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "SubredditInfo_default",
        argNames: [],
      );

  @override
  int? redditApiModelSubredditSubredditAutoAccessorGetAccountsActive(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 364)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_32,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAccountsActiveConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAccountsActiveConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_accounts_active",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAccountsActiveIsFuzzed(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 365)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAccountsActiveIsFuzzedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAccountsActiveIsFuzzedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_accounts_active_is_fuzzed",
            argNames: ["that"],
          );

  @override
  int redditApiModelSubredditSubredditAutoAccessorGetActiveUserCount(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 366)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetActiveUserCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetActiveUserCountConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_active_user_count",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetAdvertiserCategory(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 367)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAdvertiserCategoryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAdvertiserCategoryConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_advertiser_category",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllOriginalContent(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 368)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllOriginalContentConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllOriginalContentConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_all_original_content",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowDiscovery(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 369)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowDiscoveryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowDiscoveryConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_discovery",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowGalleries(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 370)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowGalleriesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowGalleriesConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_galleries",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowImages(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 371)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowImagesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowImagesConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_images",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowPolls(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 372)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowPollsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowPollsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_polls",
            argNames: ["that"],
          );

  @override
  bool
      redditApiModelSubredditSubredditAutoAccessorGetAllowPredictionContributors(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 373)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowPredictionContributorsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowPredictionContributorsConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_allow_prediction_contributors",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowPredictions(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 374)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_predictions",
            argNames: ["that"],
          );

  @override
  bool
      redditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsTournament(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 375)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsTournamentConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsTournamentConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_allow_predictions_tournament",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowTalks(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 376)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowTalksConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowTalksConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_talks",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowVideogifs(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 377)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowVideogifsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowVideogifsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_videogifs",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowVideos(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 378)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowVideosConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowVideosConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_videos",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundColor(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 379)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundColorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundColorConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_banner_background_color",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundImage(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 380)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundImageConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundImageConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_banner_background_image",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetCanAssignLinkFlair(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 381)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCanAssignLinkFlairConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCanAssignLinkFlairConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_can_assign_link_flair",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetCanAssignUserFlair(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 382)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCanAssignUserFlairConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCanAssignUserFlairConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_can_assign_user_flair",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetCollapseDeletedComments(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 383)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCollapseDeletedCommentsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCollapseDeletedCommentsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_collapse_deleted_comments",
            argNames: ["that"],
          );

  @override
  CommentContributionSettings
      redditApiModelSubredditSubredditAutoAccessorGetCommentContributionSettings(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 384)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_comment_contribution_settings,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCommentContributionSettingsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCommentContributionSettingsConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_comment_contribution_settings",
            argNames: ["that"],
          );

  @override
  PlatformInt64?
      redditApiModelSubredditSubredditAutoAccessorGetCommentScoreHideMins(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 385)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_i_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCommentScoreHideMinsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCommentScoreHideMinsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_comment_score_hide_mins",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetCommunityReviewed(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 386)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCommunityReviewedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCommunityReviewedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_community_reviewed",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetDescription(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 387)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetDescriptionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetDescriptionConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_description",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetDescriptionHtml(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 388)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetDescriptionHtmlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetDescriptionHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_description_html",
            argNames: ["that"],
          );

  @override
  Int64List? redditApiModelSubredditSubredditAutoAccessorGetEmojisCustomSize(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 389)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_list_prim_i_64_strict,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetEmojisCustomSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetEmojisCustomSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_emojis_custom_size",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetEmojisEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 390)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetEmojisEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetEmojisEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_emojis_enabled",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetHasMenuWidget(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 391)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetHasMenuWidgetConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetHasMenuWidgetConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_has_menu_widget",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetHeaderTitle(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 392)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetHeaderTitleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetHeaderTitleConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_header_title",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetHideAds(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 393)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetHideAdsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetHideAdsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_hide_ads",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetId(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 394)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorGetIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetIdConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_id",
            argNames: ["that"],
          );

  @override
  bool? redditApiModelSubredditSubredditAutoAccessorGetIsCrosspostableSubreddit(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 395)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetIsCrosspostableSubredditConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetIsCrosspostableSubredditConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_is_crosspostable_subreddit",
            argNames: ["that"],
          );

  @override
  bool? redditApiModelSubredditSubredditAutoAccessorGetIsEnrolledInNewModmail(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 396)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetIsEnrolledInNewModmailConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetIsEnrolledInNewModmailConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_is_enrolled_in_new_modmail",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetLang(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 397)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorGetLangConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetLangConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_lang",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetMobileBannerImage(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 398)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetMobileBannerImageConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetMobileBannerImageConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_mobile_banner_image",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetNotificationLevel(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 399)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetNotificationLevelConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetNotificationLevelConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_notification_level",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetOriginalContentTagEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 400)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetOriginalContentTagEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetOriginalContentTagEnabledConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_original_content_tag_enabled",
            argNames: ["that"],
          );

  @override
  Common redditApiModelSubredditSubredditAutoAccessorGetOther(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 401)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorGetOtherConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetOtherConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_other",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetOver18(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 402)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetOver18ConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetOver18ConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_over18",
            argNames: ["that"],
          );

  @override
  PlatformInt64
      redditApiModelSubredditSubredditAutoAccessorGetPredictionLeaderboardEntryType(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 403)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetPredictionLeaderboardEntryTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetPredictionLeaderboardEntryTypeConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_prediction_leaderboard_entry_type",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetPublicDescriptionHtml(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 404)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetPublicDescriptionHtmlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetPublicDescriptionHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_public_description_html",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetPublicTraffic(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 405)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetPublicTrafficConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetPublicTrafficConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_public_traffic",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetShouldArchivePosts(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 406)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetShouldArchivePostsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetShouldArchivePostsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_should_archive_posts",
            argNames: ["that"],
          );

  @override
  bool
      redditApiModelSubredditSubredditAutoAccessorGetShouldShowMediaInCommentsSetting(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 407)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetShouldShowMediaInCommentsSettingConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetShouldShowMediaInCommentsSettingConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_should_show_media_in_comments_setting",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetShowMediaPreview(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 408)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetShowMediaPreviewConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetShowMediaPreviewConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_show_media_preview",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetSpoilersEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 409)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSpoilersEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSpoilersEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_spoilers_enabled",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetSubmissionType(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 410)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSubmissionTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSubmissionTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_submission_type",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetSubmitText(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 411)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSubmitTextConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSubmitTextConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_submit_text",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetSubmitTextHtml(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 412)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSubmitTextHtmlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSubmitTextHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_submit_text_html",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetSuggestedCommentSort(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 413)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSuggestedCommentSortConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSuggestedCommentSortConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_suggested_comment_sort",
            argNames: ["that"],
          );

  @override
  bool? redditApiModelSubredditSubredditAutoAccessorGetUserCanFlairInSr(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 414)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserCanFlairInSrConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserCanFlairInSrConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_can_flair_in_sr",
            argNames: ["that"],
          );

  @override
  Flair redditApiModelSubredditSubredditAutoAccessorGetUserFlair(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 415)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_flair,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserFlairConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserFlairConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_flair",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetUserFlairEnabledInSr(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 416)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserFlairEnabledInSrConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserFlairEnabledInSrConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_flair_enabled_in_sr",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetUserHasFavorited(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 417)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserHasFavoritedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserHasFavoritedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_has_favorited",
            argNames: ["that"],
          );

  @override
  bool? redditApiModelSubredditSubredditAutoAccessorGetUserSrFlairEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 418)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserSrFlairEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserSrFlairEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_sr_flair_enabled",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetUserSrThemeEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 419)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserSrThemeEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserSrThemeEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_sr_theme_enabled",
            argNames: ["that"],
          );

  @override
  bool? redditApiModelSubredditSubredditAutoAccessorGetWikiEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 420)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetWikiEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetWikiEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_wiki_enabled",
            argNames: ["that"],
          );

  @override
  int? redditApiModelSubredditSubredditAutoAccessorGetWls(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 421)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorGetWlsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetWlsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_wls",
            argNames: ["that"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAccountsActive(
      {required Subreddit that, int? accountsActive}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_u_32(accountsActive, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 422)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAccountsActiveConstMeta,
      argValues: [that, accountsActive],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAccountsActiveConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_accounts_active",
            argNames: ["that", "accountsActive"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAccountsActiveIsFuzzed(
      {required Subreddit that, required bool accountsActiveIsFuzzed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(accountsActiveIsFuzzed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 423)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAccountsActiveIsFuzzedConstMeta,
      argValues: [that, accountsActiveIsFuzzed],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAccountsActiveIsFuzzedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_accounts_active_is_fuzzed",
            argNames: ["that", "accountsActiveIsFuzzed"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetActiveUserCount(
      {required Subreddit that, required int activeUserCount}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_u_32(activeUserCount, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 424)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetActiveUserCountConstMeta,
      argValues: [that, activeUserCount],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetActiveUserCountConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_active_user_count",
            argNames: ["that", "activeUserCount"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAdvertiserCategory(
      {required Subreddit that, String? advertiserCategory}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(advertiserCategory, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 425)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAdvertiserCategoryConstMeta,
      argValues: [that, advertiserCategory],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAdvertiserCategoryConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_advertiser_category",
            argNames: ["that", "advertiserCategory"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllOriginalContent(
      {required Subreddit that, required bool allOriginalContent}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allOriginalContent, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 426)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllOriginalContentConstMeta,
      argValues: [that, allOriginalContent],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllOriginalContentConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_all_original_content",
            argNames: ["that", "allOriginalContent"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowDiscovery(
      {required Subreddit that, required bool allowDiscovery}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowDiscovery, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 427)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowDiscoveryConstMeta,
      argValues: [that, allowDiscovery],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowDiscoveryConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_discovery",
            argNames: ["that", "allowDiscovery"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowGalleries(
      {required Subreddit that, required bool allowGalleries}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowGalleries, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 428)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowGalleriesConstMeta,
      argValues: [that, allowGalleries],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowGalleriesConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_galleries",
            argNames: ["that", "allowGalleries"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowImages(
      {required Subreddit that, required bool allowImages}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowImages, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 429)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowImagesConstMeta,
      argValues: [that, allowImages],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowImagesConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_images",
            argNames: ["that", "allowImages"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowPolls(
      {required Subreddit that, required bool allowPolls}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowPolls, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 430)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowPollsConstMeta,
      argValues: [that, allowPolls],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowPollsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_polls",
            argNames: ["that", "allowPolls"],
          );

  @override
  void
      redditApiModelSubredditSubredditAutoAccessorSetAllowPredictionContributors(
          {required Subreddit that,
          required bool allowPredictionContributors}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowPredictionContributors, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 431)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowPredictionContributorsConstMeta,
      argValues: [that, allowPredictionContributors],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowPredictionContributorsConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_allow_prediction_contributors",
            argNames: ["that", "allowPredictionContributors"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowPredictions(
      {required Subreddit that, required bool allowPredictions}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowPredictions, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 432)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsConstMeta,
      argValues: [that, allowPredictions],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_predictions",
            argNames: ["that", "allowPredictions"],
          );

  @override
  void
      redditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsTournament(
          {required Subreddit that, required bool allowPredictionsTournament}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowPredictionsTournament, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 433)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsTournamentConstMeta,
      argValues: [that, allowPredictionsTournament],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsTournamentConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_allow_predictions_tournament",
            argNames: ["that", "allowPredictionsTournament"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowTalks(
      {required Subreddit that, required bool allowTalks}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowTalks, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 434)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowTalksConstMeta,
      argValues: [that, allowTalks],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowTalksConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_talks",
            argNames: ["that", "allowTalks"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowVideogifs(
      {required Subreddit that, required bool allowVideogifs}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowVideogifs, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 435)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowVideogifsConstMeta,
      argValues: [that, allowVideogifs],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowVideogifsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_videogifs",
            argNames: ["that", "allowVideogifs"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowVideos(
      {required Subreddit that, required bool allowVideos}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowVideos, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 436)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowVideosConstMeta,
      argValues: [that, allowVideos],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowVideosConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_videos",
            argNames: ["that", "allowVideos"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundColor(
      {required Subreddit that, String? bannerBackgroundColor}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(bannerBackgroundColor, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 437)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundColorConstMeta,
      argValues: [that, bannerBackgroundColor],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundColorConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_banner_background_color",
            argNames: ["that", "bannerBackgroundColor"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundImage(
      {required Subreddit that, String? bannerBackgroundImage}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(bannerBackgroundImage, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 438)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundImageConstMeta,
      argValues: [that, bannerBackgroundImage],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundImageConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_banner_background_image",
            argNames: ["that", "bannerBackgroundImage"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCanAssignLinkFlair(
      {required Subreddit that, required bool canAssignLinkFlair}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(canAssignLinkFlair, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 439)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCanAssignLinkFlairConstMeta,
      argValues: [that, canAssignLinkFlair],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCanAssignLinkFlairConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_can_assign_link_flair",
            argNames: ["that", "canAssignLinkFlair"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCanAssignUserFlair(
      {required Subreddit that, required bool canAssignUserFlair}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(canAssignUserFlair, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 440)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCanAssignUserFlairConstMeta,
      argValues: [that, canAssignUserFlair],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCanAssignUserFlairConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_can_assign_user_flair",
            argNames: ["that", "canAssignUserFlair"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCollapseDeletedComments(
      {required Subreddit that, required bool collapseDeletedComments}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(collapseDeletedComments, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 441)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCollapseDeletedCommentsConstMeta,
      argValues: [that, collapseDeletedComments],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCollapseDeletedCommentsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_collapse_deleted_comments",
            argNames: ["that", "collapseDeletedComments"],
          );

  @override
  void
      redditApiModelSubredditSubredditAutoAccessorSetCommentContributionSettings(
          {required Subreddit that,
          required CommentContributionSettings commentContributionSettings}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_comment_contribution_settings(
            commentContributionSettings, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 442)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCommentContributionSettingsConstMeta,
      argValues: [that, commentContributionSettings],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCommentContributionSettingsConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_comment_contribution_settings",
            argNames: ["that", "commentContributionSettings"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCommentScoreHideMins(
      {required Subreddit that, PlatformInt64? commentScoreHideMins}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_i_64(commentScoreHideMins, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 443)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCommentScoreHideMinsConstMeta,
      argValues: [that, commentScoreHideMins],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCommentScoreHideMinsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_comment_score_hide_mins",
            argNames: ["that", "commentScoreHideMins"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCommunityReviewed(
      {required Subreddit that, required bool communityReviewed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(communityReviewed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 444)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCommunityReviewedConstMeta,
      argValues: [that, communityReviewed],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCommunityReviewedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_community_reviewed",
            argNames: ["that", "communityReviewed"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetDescription(
      {required Subreddit that, String? description}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(description, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 445)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetDescriptionConstMeta,
      argValues: [that, description],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetDescriptionConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_description",
            argNames: ["that", "description"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetDescriptionHtml(
      {required Subreddit that, String? descriptionHtml}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(descriptionHtml, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 446)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetDescriptionHtmlConstMeta,
      argValues: [that, descriptionHtml],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetDescriptionHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_description_html",
            argNames: ["that", "descriptionHtml"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetEmojisCustomSize(
      {required Subreddit that, Int64List? emojisCustomSize}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_list_prim_i_64_strict(emojisCustomSize, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 447)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetEmojisCustomSizeConstMeta,
      argValues: [that, emojisCustomSize],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetEmojisCustomSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_emojis_custom_size",
            argNames: ["that", "emojisCustomSize"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetEmojisEnabled(
      {required Subreddit that, required bool emojisEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(emojisEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 448)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetEmojisEnabledConstMeta,
      argValues: [that, emojisEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetEmojisEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_emojis_enabled",
            argNames: ["that", "emojisEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetHasMenuWidget(
      {required Subreddit that, required bool hasMenuWidget}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(hasMenuWidget, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 449)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetHasMenuWidgetConstMeta,
      argValues: [that, hasMenuWidget],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetHasMenuWidgetConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_has_menu_widget",
            argNames: ["that", "hasMenuWidget"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetHeaderTitle(
      {required Subreddit that, String? headerTitle}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(headerTitle, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 450)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetHeaderTitleConstMeta,
      argValues: [that, headerTitle],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetHeaderTitleConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_header_title",
            argNames: ["that", "headerTitle"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetHideAds(
      {required Subreddit that, required bool hideAds}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(hideAds, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 451)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetHideAdsConstMeta,
      argValues: [that, hideAds],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetHideAdsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_hide_ads",
            argNames: ["that", "hideAds"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetId(
      {required Subreddit that, required String id}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(id, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 452)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorSetIdConstMeta,
      argValues: [that, id],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetIdConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_id",
            argNames: ["that", "id"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetIsCrosspostableSubreddit(
      {required Subreddit that, bool? isCrosspostableSubreddit}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_bool(isCrosspostableSubreddit, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 453)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetIsCrosspostableSubredditConstMeta,
      argValues: [that, isCrosspostableSubreddit],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetIsCrosspostableSubredditConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_is_crosspostable_subreddit",
            argNames: ["that", "isCrosspostableSubreddit"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetIsEnrolledInNewModmail(
      {required Subreddit that, bool? isEnrolledInNewModmail}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_bool(isEnrolledInNewModmail, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 454)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetIsEnrolledInNewModmailConstMeta,
      argValues: [that, isEnrolledInNewModmail],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetIsEnrolledInNewModmailConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_is_enrolled_in_new_modmail",
            argNames: ["that", "isEnrolledInNewModmail"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetLang(
      {required Subreddit that, String? lang}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(lang, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 455)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorSetLangConstMeta,
      argValues: [that, lang],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetLangConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_lang",
            argNames: ["that", "lang"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetMobileBannerImage(
      {required Subreddit that, String? mobileBannerImage}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(mobileBannerImage, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 456)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetMobileBannerImageConstMeta,
      argValues: [that, mobileBannerImage],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetMobileBannerImageConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_mobile_banner_image",
            argNames: ["that", "mobileBannerImage"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetNotificationLevel(
      {required Subreddit that, String? notificationLevel}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(notificationLevel, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 457)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetNotificationLevelConstMeta,
      argValues: [that, notificationLevel],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetNotificationLevelConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_notification_level",
            argNames: ["that", "notificationLevel"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetOriginalContentTagEnabled(
      {required Subreddit that, required bool originalContentTagEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(originalContentTagEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 458)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetOriginalContentTagEnabledConstMeta,
      argValues: [that, originalContentTagEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetOriginalContentTagEnabledConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_original_content_tag_enabled",
            argNames: ["that", "originalContentTagEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetOther(
      {required Subreddit that, required Common other}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
            other, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 459)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorSetOtherConstMeta,
      argValues: [that, other],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetOtherConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_other",
            argNames: ["that", "other"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetOver18(
      {required Subreddit that, required bool over18}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(over18, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 460)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetOver18ConstMeta,
      argValues: [that, over18],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetOver18ConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_over18",
            argNames: ["that", "over18"],
          );

  @override
  void
      redditApiModelSubredditSubredditAutoAccessorSetPredictionLeaderboardEntryType(
          {required Subreddit that,
          required PlatformInt64 predictionLeaderboardEntryType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_i_64(predictionLeaderboardEntryType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 461)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetPredictionLeaderboardEntryTypeConstMeta,
      argValues: [that, predictionLeaderboardEntryType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetPredictionLeaderboardEntryTypeConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_prediction_leaderboard_entry_type",
            argNames: ["that", "predictionLeaderboardEntryType"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetPublicDescriptionHtml(
      {required Subreddit that, String? publicDescriptionHtml}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(publicDescriptionHtml, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 462)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetPublicDescriptionHtmlConstMeta,
      argValues: [that, publicDescriptionHtml],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetPublicDescriptionHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_public_description_html",
            argNames: ["that", "publicDescriptionHtml"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetPublicTraffic(
      {required Subreddit that, required bool publicTraffic}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(publicTraffic, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 463)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetPublicTrafficConstMeta,
      argValues: [that, publicTraffic],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetPublicTrafficConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_public_traffic",
            argNames: ["that", "publicTraffic"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetShouldArchivePosts(
      {required Subreddit that, required bool shouldArchivePosts}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(shouldArchivePosts, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 464)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetShouldArchivePostsConstMeta,
      argValues: [that, shouldArchivePosts],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetShouldArchivePostsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_should_archive_posts",
            argNames: ["that", "shouldArchivePosts"],
          );

  @override
  void
      redditApiModelSubredditSubredditAutoAccessorSetShouldShowMediaInCommentsSetting(
          {required Subreddit that,
          required bool shouldShowMediaInCommentsSetting}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(shouldShowMediaInCommentsSetting, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 465)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetShouldShowMediaInCommentsSettingConstMeta,
      argValues: [that, shouldShowMediaInCommentsSetting],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetShouldShowMediaInCommentsSettingConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_should_show_media_in_comments_setting",
            argNames: ["that", "shouldShowMediaInCommentsSetting"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetShowMediaPreview(
      {required Subreddit that, required bool showMediaPreview}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(showMediaPreview, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 466)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetShowMediaPreviewConstMeta,
      argValues: [that, showMediaPreview],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetShowMediaPreviewConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_show_media_preview",
            argNames: ["that", "showMediaPreview"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSpoilersEnabled(
      {required Subreddit that, required bool spoilersEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(spoilersEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 467)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSpoilersEnabledConstMeta,
      argValues: [that, spoilersEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSpoilersEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_spoilers_enabled",
            argNames: ["that", "spoilersEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSubmissionType(
      {required Subreddit that, String? submissionType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(submissionType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 468)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSubmissionTypeConstMeta,
      argValues: [that, submissionType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSubmissionTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_submission_type",
            argNames: ["that", "submissionType"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSubmitText(
      {required Subreddit that, String? submitText}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(submitText, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 469)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSubmitTextConstMeta,
      argValues: [that, submitText],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSubmitTextConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_submit_text",
            argNames: ["that", "submitText"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSubmitTextHtml(
      {required Subreddit that, String? submitTextHtml}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(submitTextHtml, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 470)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSubmitTextHtmlConstMeta,
      argValues: [that, submitTextHtml],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSubmitTextHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_submit_text_html",
            argNames: ["that", "submitTextHtml"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSuggestedCommentSort(
      {required Subreddit that, String? suggestedCommentSort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(suggestedCommentSort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 471)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSuggestedCommentSortConstMeta,
      argValues: [that, suggestedCommentSort],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSuggestedCommentSortConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_suggested_comment_sort",
            argNames: ["that", "suggestedCommentSort"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserCanFlairInSr(
      {required Subreddit that, bool? userCanFlairInSr}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_bool(userCanFlairInSr, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 472)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserCanFlairInSrConstMeta,
      argValues: [that, userCanFlairInSr],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserCanFlairInSrConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_can_flair_in_sr",
            argNames: ["that", "userCanFlairInSr"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserFlair(
      {required Subreddit that, required Flair userFlair}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_flair(userFlair, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 473)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserFlairConstMeta,
      argValues: [that, userFlair],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserFlairConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_flair",
            argNames: ["that", "userFlair"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserFlairEnabledInSr(
      {required Subreddit that, required bool userFlairEnabledInSr}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(userFlairEnabledInSr, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 474)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserFlairEnabledInSrConstMeta,
      argValues: [that, userFlairEnabledInSr],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserFlairEnabledInSrConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_flair_enabled_in_sr",
            argNames: ["that", "userFlairEnabledInSr"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserHasFavorited(
      {required Subreddit that, required bool userHasFavorited}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(userHasFavorited, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 475)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserHasFavoritedConstMeta,
      argValues: [that, userHasFavorited],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserHasFavoritedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_has_favorited",
            argNames: ["that", "userHasFavorited"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserSrFlairEnabled(
      {required Subreddit that, bool? userSrFlairEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_bool(userSrFlairEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 476)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserSrFlairEnabledConstMeta,
      argValues: [that, userSrFlairEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserSrFlairEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_sr_flair_enabled",
            argNames: ["that", "userSrFlairEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserSrThemeEnabled(
      {required Subreddit that, required bool userSrThemeEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(userSrThemeEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 477)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserSrThemeEnabledConstMeta,
      argValues: [that, userSrThemeEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserSrThemeEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_sr_theme_enabled",
            argNames: ["that", "userSrThemeEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetWikiEnabled(
      {required Subreddit that, bool? wikiEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_bool(wikiEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 478)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetWikiEnabledConstMeta,
      argValues: [that, wikiEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetWikiEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_wiki_enabled",
            argNames: ["that", "wikiEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetWls(
      {required Subreddit that, int? wls}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_u_32(wls, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 479)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorSetWlsConstMeta,
      argValues: [that, wls],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetWlsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_wls",
            argNames: ["that", "wls"],
          );

  @override
  Future<Subreddit> redditApiModelSubredditSubredditDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 480, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditSubredditDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Subreddit_default",
        argNames: [],
      );

  @override
  SubredditIcon redditApiModelSubredditSubredditIcon(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 481)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_subreddit_icon,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditIconConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditSubredditIconConstMeta =>
      const TaskConstMeta(
        debugName: "Subreddit_icon",
        argNames: ["that"],
      );

  @override
  Future<AnimatedImage> redditApiModelGalleryAnimatedImageDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 485, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_animated_image,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelGalleryAnimatedImageDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelGalleryAnimatedImageDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "animated_image_default",
        argNames: [],
      );

  @override
  Future<AuthorInfo> redditApiModelAuthorAuthorInfoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 486, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_author_info,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelAuthorAuthorInfoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelAuthorAuthorInfoDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "author_info_default",
        argNames: [],
      );

  @override
  Future<CommentContributionSettings>
      redditApiModelSubredditCommentContributionSettingsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 487, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_comment_contribution_settings,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommentContributionSettingsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommentContributionSettingsDefaultConstMeta =>
          const TaskConstMeta(
            debugName: "comment_contribution_settings_default",
            argNames: [],
          );

  @override
  void crateApiSimpleDebugComment({required Comment comment}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            comment, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 488)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleDebugCommentConstMeta,
      argValues: [comment],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleDebugCommentConstMeta => const TaskConstMeta(
        debugName: "debug_comment",
        argNames: ["comment"],
      );

  @override
  void crateApiSimpleDebugPost({required Post post}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            post, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 489)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleDebugPostConstMeta,
      argValues: [post],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleDebugPostConstMeta => const TaskConstMeta(
        debugName: "debug_post",
        argNames: ["post"],
      );

  @override
  Future<Feed> redditApiModelFeedFeedDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 490, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_feed,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFeedFeedDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFeedFeedDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "feed_default",
        argNames: [],
      );

  @override
  Future<Flair> redditApiModelFlairFlairDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 491, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_flair,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFlairFlairDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "flair_default",
        argNames: [],
      );

  @override
  Future<Gildings> redditApiModelPostGildingsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 492, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_gildings,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostGildingsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostGildingsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "gildings_default",
        argNames: [],
      );

  @override
  Future<ImageBase> redditApiModelPostImageBaseDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 493, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_image_base,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostImageBaseDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostImageBaseDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "image_base_default",
        argNames: [],
      );

  @override
  Future<Image> redditApiModelGalleryImageDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 494, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_image,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelGalleryImageDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelGalleryImageDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "image_default",
        argNames: [],
      );

  @override
  Future<void> crateApiSimpleInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 495, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<MediaEmbed> redditApiModelPostMediaEmbedDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 496, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_media_embed,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostMediaEmbedDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostMediaEmbedDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "media_embed_default",
        argNames: [],
      );

  @override
  Future<NotificationLevel> redditApiModelSubredditNotificationLevelDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 497, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_notification_level,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditNotificationLevelDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditNotificationLevelDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "notification_level_default",
        argNames: [],
      );

  @override
  Future<Oembed> redditApiModelPostOembedDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 498, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_oembed,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostOembedDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "oembed_default",
        argNames: [],
      );

  @override
  Future<Preview> redditApiModelPostPreviewDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 499, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_preview,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPreviewDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPreviewDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "preview_default",
        argNames: [],
      );

  @override
  Client crateApiSimpleRedditApiClient() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 500)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleRedditApiClientConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleRedditApiClientConstMeta =>
      const TaskConstMeta(
        debugName: "reddit_api_client",
        argNames: [],
      );

  @override
  Future<RedditImage> redditApiModelPostRedditImageDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 501, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_reddit_image,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostRedditImageDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostRedditImageDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "reddit_image_default",
        argNames: [],
      );

  @override
  Future<RedditVideo> redditApiModelPostRedditVideoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 502, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_reddit_video,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostRedditVideoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostRedditVideoDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "reddit_video_default",
        argNames: [],
      );

  @override
  Future<SecureMediaEmbed> redditApiModelPostSecureMediaEmbedDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 503, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_secure_media_embed,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostSecureMediaEmbedDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostSecureMediaEmbedDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "secure_media_embed_default",
        argNames: [],
      );

  @override
  Future<Snoovatar> redditApiModelUserModelSnoovatarDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 504, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_snoovatar,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelUserModelSnoovatarDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelUserModelSnoovatarDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "snoovatar_default",
        argNames: [],
      );

  @override
  Future<SubredditDetails> redditApiModelMultiSubredditDetailsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 505, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_subreddit_details,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiSubredditDetailsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiSubredditDetailsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "subreddit_details_default",
        argNames: [],
      );

  @override
  Fullname? redditApiModelThingName({required Thing that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_thing(that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 506)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelThingNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelThingNameConstMeta => const TaskConstMeta(
        debugName: "thing_name",
        argNames: ["that"],
      );

  @override
  Future<ThumbnailOption> redditApiModelPostThumbnailOptionDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 507, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_thumbnail_option,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostThumbnailOptionDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostThumbnailOptionDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "thumbnail_option_default",
        argNames: [],
      );

  @override
  Future<ThumbnailURL> redditApiModelPostThumbnailUrlDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 508, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_thumbnail_url,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostThumbnailUrlDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostThumbnailUrlDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "thumbnail_url_default",
        argNames: [],
      );

  @override
  Future<User> redditApiModelUserModelUserDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 509, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_user,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelUserModelUserDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelUserModelUserDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "user_default",
        argNames: [],
      );

  @override
  Future<UserInfo> redditApiModelUserModelUserInfoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 510, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_user_info,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelUserModelUserInfoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelUserModelUserInfoDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "user_info_default",
        argNames: [],
      );

  @override
  Future<UserSubreddit> redditApiModelUserModelUserSubredditDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 511, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_user_subreddit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelUserModelUserSubredditDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelUserModelUserSubredditDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "user_subreddit_default",
        argNames: [],
      );

  @override
  Future<VariantInner> redditApiModelPostVariantInnerDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 512, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_variant_inner,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostVariantInnerDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostVariantInnerDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "variant_inner_default",
        argNames: [],
      );

  @override
  Future<Variants> redditApiModelPostVariantsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 513, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_variants,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostVariantsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostVariantsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "variants_default",
        argNames: [],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BoxFeedStream => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxFeedStream;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BoxFeedStream => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxFeedStream;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_BoxMultiStream => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxMultiStream;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_BoxMultiStream => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxMultiStream;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Client => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Client => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Comment => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Comment => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Common => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Common => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Details => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Details => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_FeedStream => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_FeedStream => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Fullname => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Fullname => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Gallery => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Gallery => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_GalleryData => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryData;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_GalleryData => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryData;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_GalleryMedia => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_GalleryMedia => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Listing => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Listing => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Multi =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Multi =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MultiStream => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiStream;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MultiStream => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiStream;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Pager =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Pager =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Post =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Post =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_PostId => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_PostId => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SearchPost => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchPost;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SearchPost => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchPost;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SearchSubreddit => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchSubreddit;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SearchSubreddit => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchSubreddit;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Streamable => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Streamable => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Subreddit => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Subreddit => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SubredditId => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SubredditId => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SubredditInfo => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SubredditInfo => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Url => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Url => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  BoxFeedStream
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxFeedStream(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BoxFeedStreamImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BoxMultiStream
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxMultiStream(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BoxMultiStreamImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Client
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Comment
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CommentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Common
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CommonImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Details
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DetailsImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FeedStream
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FeedStreamImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Fullname
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FullnameImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Gallery
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GalleryImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  GalleryData
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GalleryDataImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  GalleryMedia
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GalleryMediaImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Listing
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ListingImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Multi
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MultiImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MultiStream
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiStream(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MultiStreamImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Pager
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Post
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PostImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PostId
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PostIdImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SearchPost
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SearchPostImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SearchSubreddit
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchSubreddit(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SearchSubredditImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Streamable
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return StreamableImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Subreddit
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubredditId
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditIdImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubredditInfo
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Url dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UrlImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Comment
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CommentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Common
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CommonImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Details
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DetailsImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  GalleryMedia
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GalleryMediaImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Listing
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ListingImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Multi
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MultiImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Pager
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Post
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PostImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Streamable
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return StreamableImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Subreddit
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubredditInfo
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Client
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Comment
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CommentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Common
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CommonImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Details
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DetailsImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Fullname
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FullnameImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Gallery
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GalleryImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  GalleryMedia
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GalleryMediaImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Listing
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ListingImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Multi
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MultiImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Pager
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Post
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PostImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Streamable
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return StreamableImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Subreddit
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubredditInfo
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DateTime dco_decode_Chrono_Local(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeTimestamp(ts: dco_decode_i_64(raw).toInt(), isUtc: false);
  }

  @protected
  DateTime dco_decode_Chrono_Utc(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeTimestamp(ts: dco_decode_i_64(raw).toInt(), isUtc: true);
  }

  @protected
  BoxFeedStream
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxFeedStream(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BoxFeedStreamImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  BoxMultiStream
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxMultiStream(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return BoxMultiStreamImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Client
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Comment
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CommentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Common
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CommonImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Details
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DetailsImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FeedStream
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FeedStreamImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Fullname
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FullnameImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Gallery
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GalleryImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  GalleryData
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GalleryDataImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  GalleryMedia
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return GalleryMediaImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Listing
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ListingImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Multi
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MultiImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MultiStream
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiStream(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MultiStreamImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Pager
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Post
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PostImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PostId
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PostIdImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SearchPost
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SearchPostImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SearchSubreddit
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchSubreddit(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SearchSubredditImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Streamable
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return StreamableImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Subreddit
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubredditId
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditIdImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubredditInfo
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Url dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UrlImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Votable dco_decode_TraitDef_Votable(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  AnimatedImage dco_decode_animated_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return AnimatedImage(
      x: dco_decode_u_32(arr[0]),
      y: dco_decode_u_32(arr[1]),
      gif: dco_decode_String(arr[2]),
      mp4: dco_decode_String(arr[3]),
    );
  }

  @protected
  AuthorInfo dco_decode_author_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return AuthorInfo(
      username: dco_decode_String(arr[0]),
      premium: dco_decode_bool(arr[1]),
      flair: dco_decode_flair(arr[2]),
      fullname: dco_decode_String(arr[3]),
      isBlocked: dco_decode_bool(arr[4]),
      patreonFlair: dco_decode_bool(arr[5]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  Details
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
        raw);
  }

  @protected
  Fullname
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
        raw);
  }

  @protected
  Gallery
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
        raw);
  }

  @protected
  AnimatedImage dco_decode_box_autoadd_animated_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_animated_image(raw);
  }

  @protected
  AuthorInfo dco_decode_box_autoadd_author_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_author_info(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  CommentSort dco_decode_box_autoadd_comment_sort(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_comment_sort(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  Feed dco_decode_box_autoadd_feed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_feed(raw);
  }

  @protected
  FeedSort dco_decode_box_autoadd_feed_sort(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_feed_sort(raw);
  }

  @protected
  Flair dco_decode_box_autoadd_flair(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_flair(raw);
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  Icon dco_decode_box_autoadd_icon(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_icon(raw);
  }

  @protected
  Image dco_decode_box_autoadd_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_image(raw);
  }

  @protected
  Media dco_decode_box_autoadd_media(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media(raw);
  }

  @protected
  MediaEmbed dco_decode_box_autoadd_media_embed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media_embed(raw);
  }

  @protected
  Oembed dco_decode_box_autoadd_oembed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_oembed(raw);
  }

  @protected
  PostSearchSort dco_decode_box_autoadd_post_search_sort(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_post_search_sort(raw);
  }

  @protected
  Preview dco_decode_box_autoadd_preview(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_preview(raw);
  }

  @protected
  RedditVideo dco_decode_box_autoadd_reddit_video(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_reddit_video(raw);
  }

  @protected
  SecureMediaEmbed dco_decode_box_autoadd_secure_media_embed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secure_media_embed(raw);
  }

  @protected
  Thing dco_decode_box_autoadd_thing(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_thing(raw);
  }

  @protected
  Thumbnail dco_decode_box_autoadd_thumbnail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_thumbnail(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  User dco_decode_box_autoadd_user(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_user(raw);
  }

  @protected
  UserStreamSort dco_decode_box_autoadd_user_stream_sort(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_user_stream_sort(raw);
  }

  @protected
  VariantInner dco_decode_box_autoadd_variant_inner(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_variant_inner(raw);
  }

  @protected
  CommentContributionSettings dco_decode_comment_contribution_settings(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return CommentContributionSettings(
      allowedMediaTypes: dco_decode_list_String(arr[0]),
    );
  }

  @protected
  CommentSort dco_decode_comment_sort(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return CommentSort.values[raw as int];
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  Feed dco_decode_feed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Feed_Home();
      case 1:
        return Feed_All();
      case 2:
        return Feed_Popular();
      case 3:
        return Feed_Subreddit(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  FeedSort dco_decode_feed_sort(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return FeedSort_Best();
      case 1:
        return FeedSort_Hot();
      case 2:
        return FeedSort_New(
          dco_decode_timeframe(raw[1]),
        );
      case 3:
        return FeedSort_Top(
          dco_decode_timeframe(raw[1]),
        );
      case 4:
        return FeedSort_Rising();
      case 5:
        return FeedSort_Controversial(
          dco_decode_timeframe(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Flair dco_decode_flair(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return Flair(
      cssClass: dco_decode_opt_String(arr[0]),
      richtext: dco_decode_list_richtext(arr[1]),
      backgroundColor: dco_decode_opt_String(arr[2]),
      textColor: dco_decode_opt_String(arr[3]),
      text: dco_decode_opt_String(arr[4]),
      flairType: dco_decode_opt_String(arr[5]),
      templateId: dco_decode_opt_String(arr[6]),
      position: dco_decode_opt_String(arr[7]),
    );
  }

  @protected
  Gildings dco_decode_gildings(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.isNotEmpty)
      throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return Gildings();
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  Icon dco_decode_icon(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Icon(
      url: dco_decode_String(arr[0]),
      width: dco_decode_usize(arr[1]),
      height: dco_decode_usize(arr[2]),
    );
  }

  @protected
  Image dco_decode_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Image(
      u: dco_decode_String(arr[0]),
      x: dco_decode_u_32(arr[1]),
      y: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  ImageBase dco_decode_image_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ImageBase(
      url: dco_decode_String(arr[0]),
      width: dco_decode_u_32(arr[1]),
      height: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  Kind dco_decode_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Kind.values[raw as int];
  }

  @protected
  List<Multi>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti)
        .toList();
  }

  @protected
  List<Post>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost)
        .toList();
  }

  @protected
  List<Subreddit>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit)
        .toList();
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<ImageBase> dco_decode_list_image_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_image_base).toList();
  }

  @protected
  List<String?> dco_decode_list_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_opt_String).toList();
  }

  @protected
  Int64List dco_decode_list_prim_i_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeInt64List(raw);
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<RedditImage> dco_decode_list_reddit_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_reddit_image).toList();
  }

  @protected
  List<Richtext> dco_decode_list_richtext(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_richtext).toList();
  }

  @protected
  List<SubredditDetails> dco_decode_list_subreddit_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_subreddit_details).toList();
  }

  @protected
  List<Thing> dco_decode_list_thing(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_thing).toList();
  }

  @protected
  Media dco_decode_media(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Media_RedditVideo(
          dco_decode_box_autoadd_reddit_video(raw[1]),
        );
      case 1:
        return Media_Oembed(
          oembed: dco_decode_box_autoadd_oembed(raw[1]),
          typeField: dco_decode_String(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  MediaEmbed dco_decode_media_embed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return MediaEmbed(
      content: dco_decode_String(arr[0]),
      width: dco_decode_u_32(arr[1]),
      scrolling: dco_decode_bool(arr[2]),
      height: dco_decode_u_32(arr[3]),
    );
  }

  @protected
  NotificationLevel dco_decode_notification_level(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NotificationLevel.values[raw as int];
  }

  @protected
  Oembed dco_decode_oembed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return Oembed(
      providerUrl: dco_decode_String(arr[0]),
      title: dco_decode_String(arr[1]),
      html: dco_decode_String(arr[2]),
      height: dco_decode_u_32(arr[3]),
      width: dco_decode_u_32(arr[4]),
      version: dco_decode_String(arr[5]),
      authorName: dco_decode_String(arr[6]),
      providerName: dco_decode_String(arr[7]),
      typeField: dco_decode_String(arr[8]),
      authorUrl: dco_decode_String(arr[9]),
      thumbnail: dco_decode_thumbnail_option(arr[10]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  Details?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
            raw);
  }

  @protected
  Fullname?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            raw);
  }

  @protected
  Gallery?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
            raw);
  }

  @protected
  AuthorInfo? dco_decode_opt_box_autoadd_author_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_author_info(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  CommentSort? dco_decode_opt_box_autoadd_comment_sort(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_comment_sort(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_64(raw);
  }

  @protected
  Flair? dco_decode_opt_box_autoadd_flair(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_flair(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  PlatformInt64? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  Media? dco_decode_opt_box_autoadd_media(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_media(raw);
  }

  @protected
  MediaEmbed? dco_decode_opt_box_autoadd_media_embed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_media_embed(raw);
  }

  @protected
  Preview? dco_decode_opt_box_autoadd_preview(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_preview(raw);
  }

  @protected
  SecureMediaEmbed? dco_decode_opt_box_autoadd_secure_media_embed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_secure_media_embed(raw);
  }

  @protected
  Thing? dco_decode_opt_box_autoadd_thing(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_thing(raw);
  }

  @protected
  Thumbnail? dco_decode_opt_box_autoadd_thumbnail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_thumbnail(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  VariantInner? dco_decode_opt_box_autoadd_variant_inner(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_variant_inner(raw);
  }

  @protected
  Int64List? dco_decode_opt_list_prim_i_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_i_64_strict(raw);
  }

  @protected
  PostSearchSort dco_decode_post_search_sort(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PostSearchSort_Relevance(
          dco_decode_timeframe(raw[1]),
        );
      case 1:
        return PostSearchSort_Hot();
      case 2:
        return PostSearchSort_Top(
          dco_decode_timeframe(raw[1]),
        );
      case 3:
        return PostSearchSort_New();
      case 4:
        return PostSearchSort_Comments(
          dco_decode_timeframe(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Preview dco_decode_preview(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Preview(
      images: dco_decode_list_reddit_image(arr[0]),
      enabled: dco_decode_bool(arr[1]),
    );
  }

  @protected
  (
    Post,
    List<Thing>
  ) dco_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_post_list_thing(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          arr[0]),
      dco_decode_list_thing(arr[1]),
    );
  }

  @protected
  RedditAPI dco_decode_reddit_api(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.isNotEmpty)
      throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return RedditAPI();
  }

  @protected
  RedditImage dco_decode_reddit_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RedditImage(
      source: dco_decode_image_base(arr[0]),
      resolutions: dco_decode_list_image_base(arr[1]),
      variants: dco_decode_variants(arr[2]),
      id: dco_decode_String(arr[3]),
    );
  }

  @protected
  RedditVideo dco_decode_reddit_video(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return RedditVideo(
      bitrateKbps: dco_decode_u_32(arr[0]),
      width: dco_decode_u_32(arr[1]),
      height: dco_decode_u_32(arr[2]),
      hasAudio: dco_decode_bool(arr[3]),
      isGif: dco_decode_bool(arr[4]),
      fallbackUrl: dco_decode_String(arr[5]),
      scrubberMediaUrl: dco_decode_String(arr[6]),
      dashUrl: dco_decode_String(arr[7]),
      hlsUrl: dco_decode_String(arr[8]),
      duration: dco_decode_u_32(arr[9]),
      transcodingStatus: dco_decode_String(arr[10]),
    );
  }

  @protected
  Richtext dco_decode_richtext(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Richtext_Text(
          t: dco_decode_String(raw[1]),
        );
      case 1:
        return Richtext_Emoji(
          a: dco_decode_String(raw[1]),
          u: dco_decode_String(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SecureMediaEmbed dco_decode_secure_media_embed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return SecureMediaEmbed(
      content: dco_decode_String(arr[0]),
      width: dco_decode_u_32(arr[1]),
      scrolling: dco_decode_bool(arr[2]),
      mediaDomainUrl: dco_decode_String(arr[3]),
      height: dco_decode_u_32(arr[4]),
    );
  }

  @protected
  Snoovatar dco_decode_snoovatar(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Snoovatar(
      prefShowSnoovatar: dco_decode_bool(arr[0]),
      snoovatarSize: dco_decode_opt_String(arr[1]),
      snoovatarImg: dco_decode_String(arr[2]),
    );
  }

  @protected
  Source dco_decode_source(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Source_Image(
          source: dco_decode_box_autoadd_image(raw[1]),
        );
      case 1:
        return Source_AnimatedImage(
          source: dco_decode_box_autoadd_animated_image(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SubredditDetails dco_decode_subreddit_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SubredditDetails(
      name: dco_decode_String(arr[0]),
    );
  }

  @protected
  SubredditIcon dco_decode_subreddit_icon(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return SubredditIcon_Image(
          dco_decode_box_autoadd_icon(raw[1]),
        );
      case 1:
        return SubredditIcon_Color(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SubredditSearchSort dco_decode_subreddit_search_sort(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditSearchSort.values[raw as int];
  }

  @protected
  Thing dco_decode_thing(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Thing_Listing(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
              raw[1]),
        );
      case 1:
        return Thing_Comment(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
              raw[1]),
        );
      case 2:
        return Thing_User(
          dco_decode_box_autoadd_user(raw[1]),
        );
      case 3:
        return Thing_Post(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
              raw[1]),
        );
      case 4:
        return Thing_Message();
      case 5:
        return Thing_Subreddit(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
              raw[1]),
        );
      case 6:
        return Thing_Award();
      case 7:
        return Thing_Multi(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
              raw[1]),
        );
      case 8:
        return Thing_More(
          id: dco_decode_String(raw[1]),
          name:
              dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
                  raw[2]),
          count: dco_decode_u_32(raw[3]),
          depth: dco_decode_u_32(raw[4]),
          children: dco_decode_list_String(raw[5]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Thumbnail dco_decode_thumbnail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Thumbnail(
      url: dco_decode_String(arr[0]),
      height: dco_decode_u_32(arr[1]),
      width: dco_decode_u_32(arr[2]),
    );
  }

  @protected
  ThumbnailOption dco_decode_thumbnail_option(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ThumbnailOption(
      url: dco_decode_opt_String(arr[0]),
      height: dco_decode_opt_box_autoadd_u_32(arr[1]),
      width: dco_decode_opt_box_autoadd_u_32(arr[2]),
    );
  }

  @protected
  ThumbnailURL dco_decode_thumbnail_url(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ThumbnailURL(
      url: dco_decode_opt_String(arr[0]),
      height: dco_decode_opt_box_autoadd_u_32(arr[1]),
      width: dco_decode_opt_box_autoadd_u_32(arr[2]),
    );
  }

  @protected
  Timeframe dco_decode_timeframe(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Timeframe.values[raw as int];
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  User dco_decode_user(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 14)
      throw Exception('unexpected arr length: expect 14 but see ${arr.length}');
    return User(
      info: dco_decode_user_info(arr[0]),
      goldExpiration: dco_decode_opt_String(arr[1]),
      isSponsor: dco_decode_bool(arr[2]),
      numFriends: dco_decode_i_64(arr[3]),
      canEditName: dco_decode_bool(arr[4]),
      newModmailExists: dco_decode_opt_box_autoadd_bool(arr[5]),
      coins: dco_decode_i_64(arr[6]),
      canCreateSubreddit: dco_decode_bool(arr[7]),
      suspensionExpirationUtc: dco_decode_opt_box_autoadd_f_32(arr[8]),
      hasModMail: dco_decode_bool(arr[9]),
      hasMail: dco_decode_bool(arr[10]),
      isSuspended: dco_decode_bool(arr[11]),
      inboxCount: dco_decode_i_64(arr[12]),
      goldCreddits: dco_decode_i_64(arr[13]),
    );
  }

  @protected
  UserInfo dco_decode_user_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 19)
      throw Exception('unexpected arr length: expect 19 but see ${arr.length}');
    return UserInfo(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      subreddit: dco_decode_user_subreddit(arr[2]),
      created: dco_decode_f_64(arr[3]),
      over18: dco_decode_bool(arr[4]),
      createdUtc: dco_decode_f_64(arr[5]),
      isBlocked: dco_decode_bool(arr[6]),
      isEmployee: dco_decode_bool(arr[7]),
      isFriend: dco_decode_bool(arr[8]),
      awardeeKarma: dco_decode_i_64(arr[9]),
      verified: dco_decode_bool(arr[10]),
      awarderKarma: dco_decode_i_64(arr[11]),
      iconImg: dco_decode_String(arr[12]),
      linkKarma: dco_decode_i_64(arr[13]),
      totalKarma: dco_decode_i_64(arr[14]),
      commentKarma: dco_decode_i_64(arr[15]),
      acceptFollowers: dco_decode_bool(arr[16]),
      acceptChats: dco_decode_bool(arr[17]),
      acceptPms: dco_decode_bool(arr[18]),
    );
  }

  @protected
  UserStreamSort dco_decode_user_stream_sort(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return UserStreamSort_Hot();
      case 1:
        return UserStreamSort_Top(
          dco_decode_timeframe(raw[1]),
        );
      case 2:
        return UserStreamSort_New();
      case 3:
        return UserStreamSort_Controversial(
          dco_decode_timeframe(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  UserSubreddit dco_decode_user_subreddit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 40)
      throw Exception('unexpected arr length: expect 40 but see ${arr.length}');
    return UserSubreddit(
      defaultSet: dco_decode_bool(arr[0]),
      userIsContributor: dco_decode_bool(arr[1]),
      bannerImg: dco_decode_String(arr[2]),
      allowedMediaInComments: dco_decode_list_String(arr[3]),
      userIsBanned: dco_decode_bool(arr[4]),
      freeFormReports: dco_decode_bool(arr[5]),
      communityIcon: dco_decode_opt_String(arr[6]),
      showMedia: dco_decode_bool(arr[7]),
      iconColor: dco_decode_String(arr[8]),
      userIsMuted: dco_decode_opt_box_autoadd_bool(arr[9]),
      displayName: dco_decode_String(arr[10]),
      headerImg: dco_decode_opt_String(arr[11]),
      title: dco_decode_String(arr[12]),
      coins: dco_decode_i_64(arr[13]),
      previousNames: dco_decode_list_String(arr[14]),
      over18: dco_decode_bool(arr[15]),
      iconSize: dco_decode_list_prim_i_64_strict(arr[16]),
      primaryColor: dco_decode_String(arr[17]),
      iconImg: dco_decode_String(arr[18]),
      description: dco_decode_String(arr[19]),
      submitLinkLabel: dco_decode_String(arr[20]),
      headerSize: dco_decode_opt_String(arr[21]),
      restrictPosting: dco_decode_bool(arr[22]),
      restrictCommenting: dco_decode_bool(arr[23]),
      subscribers: dco_decode_i_64(arr[24]),
      submitTextLabel: dco_decode_String(arr[25]),
      isDefaultIcon: dco_decode_bool(arr[26]),
      linkFlairPosition: dco_decode_String(arr[27]),
      displayNamePrefixed: dco_decode_String(arr[28]),
      keyColor: dco_decode_String(arr[29]),
      isDefaultBanner: dco_decode_bool(arr[30]),
      url: dco_decode_String(arr[31]),
      quarantine: dco_decode_bool(arr[32]),
      bannerSize: dco_decode_opt_String(arr[33]),
      userIsModerator: dco_decode_bool(arr[34]),
      publicDescription: dco_decode_String(arr[35]),
      linkFlairEnabled: dco_decode_bool(arr[36]),
      disableContributorRequests: dco_decode_bool(arr[37]),
      subredditType: dco_decode_String(arr[38]),
      userIsSubscriber: dco_decode_bool(arr[39]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  VariantInner dco_decode_variant_inner(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return VariantInner(
      source: dco_decode_image_base(arr[0]),
      resolutions: dco_decode_list_image_base(arr[1]),
    );
  }

  @protected
  Variants dco_decode_variants(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return Variants(
      gif: dco_decode_opt_box_autoadd_variant_inner(arr[0]),
      mp4: dco_decode_opt_box_autoadd_variant_inner(arr[1]),
      obfuscated: dco_decode_opt_box_autoadd_variant_inner(arr[2]),
      nsfw: dco_decode_opt_box_autoadd_variant_inner(arr[3]),
    );
  }

  @protected
  VoteDirection dco_decode_vote_direction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VoteDirection.values[raw as int];
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  BoxFeedStream
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxFeedStream(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BoxFeedStreamImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BoxMultiStream
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxMultiStream(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BoxMultiStreamImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Client
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Comment
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CommentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Common
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CommonImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Details
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DetailsImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  FeedStream
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FeedStreamImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Fullname
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FullnameImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Gallery
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GalleryImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  GalleryData
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GalleryDataImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  GalleryMedia
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GalleryMediaImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Listing
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ListingImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Multi
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MultiImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MultiStream
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiStream(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MultiStreamImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Pager
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Post
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PostImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PostId
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PostIdImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SearchPost
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SearchPostImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SearchSubreddit
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchSubreddit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SearchSubredditImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Streamable
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return StreamableImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Subreddit
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubredditId
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditIdImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubredditInfo
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Url sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return UrlImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Comment
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CommentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Common
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CommonImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Details
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DetailsImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  GalleryMedia
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GalleryMediaImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Listing
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ListingImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Multi
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MultiImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Pager
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Post
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PostImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Streamable
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return StreamableImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Subreddit
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubredditInfo
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Client
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Comment
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CommentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Common
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CommonImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Details
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DetailsImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Fullname
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FullnameImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Gallery
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GalleryImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  GalleryMedia
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GalleryMediaImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Listing
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ListingImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Multi
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MultiImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Pager
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Post
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PostImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Streamable
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return StreamableImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Subreddit
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubredditInfo
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DateTime sse_decode_Chrono_Local(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_64(deserializer);
    return DateTime.fromMicrosecondsSinceEpoch(inner.toInt(), isUtc: false);
  }

  @protected
  DateTime sse_decode_Chrono_Utc(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_64(deserializer);
    return DateTime.fromMicrosecondsSinceEpoch(inner.toInt(), isUtc: true);
  }

  @protected
  BoxFeedStream
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxFeedStream(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BoxFeedStreamImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  BoxMultiStream
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxMultiStream(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return BoxMultiStreamImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Client
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Comment
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CommentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Common
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return CommonImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Details
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DetailsImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  FeedStream
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FeedStreamImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Fullname
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FullnameImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Gallery
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GalleryImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  GalleryData
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GalleryDataImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  GalleryMedia
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return GalleryMediaImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Listing
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ListingImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Multi
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MultiImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MultiStream
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiStream(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MultiStreamImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Pager
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Post
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PostImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PostId
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PostIdImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SearchPost
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SearchPostImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SearchSubreddit
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchSubreddit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SearchSubredditImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Streamable
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return StreamableImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Subreddit
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubredditId
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditIdImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubredditInfo
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Url sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return UrlImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AnimatedImage sse_decode_animated_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_x = sse_decode_u_32(deserializer);
    var var_y = sse_decode_u_32(deserializer);
    var var_gif = sse_decode_String(deserializer);
    var var_mp4 = sse_decode_String(deserializer);
    return AnimatedImage(x: var_x, y: var_y, gif: var_gif, mp4: var_mp4);
  }

  @protected
  AuthorInfo sse_decode_author_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_username = sse_decode_String(deserializer);
    var var_premium = sse_decode_bool(deserializer);
    var var_flair = sse_decode_flair(deserializer);
    var var_fullname = sse_decode_String(deserializer);
    var var_isBlocked = sse_decode_bool(deserializer);
    var var_patreonFlair = sse_decode_bool(deserializer);
    return AuthorInfo(
        username: var_username,
        premium: var_premium,
        flair: var_flair,
        fullname: var_fullname,
        isBlocked: var_isBlocked,
        patreonFlair: var_patreonFlair);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Details
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
        deserializer));
  }

  @protected
  Fullname
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
        deserializer));
  }

  @protected
  Gallery
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
        deserializer));
  }

  @protected
  AnimatedImage sse_decode_box_autoadd_animated_image(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_animated_image(deserializer));
  }

  @protected
  AuthorInfo sse_decode_box_autoadd_author_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_author_info(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  CommentSort sse_decode_box_autoadd_comment_sort(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_comment_sort(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_64(deserializer));
  }

  @protected
  Feed sse_decode_box_autoadd_feed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_feed(deserializer));
  }

  @protected
  FeedSort sse_decode_box_autoadd_feed_sort(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_feed_sort(deserializer));
  }

  @protected
  Flair sse_decode_box_autoadd_flair(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_flair(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_64(deserializer));
  }

  @protected
  Icon sse_decode_box_autoadd_icon(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_icon(deserializer));
  }

  @protected
  Image sse_decode_box_autoadd_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_image(deserializer));
  }

  @protected
  Media sse_decode_box_autoadd_media(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media(deserializer));
  }

  @protected
  MediaEmbed sse_decode_box_autoadd_media_embed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media_embed(deserializer));
  }

  @protected
  Oembed sse_decode_box_autoadd_oembed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_oembed(deserializer));
  }

  @protected
  PostSearchSort sse_decode_box_autoadd_post_search_sort(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_post_search_sort(deserializer));
  }

  @protected
  Preview sse_decode_box_autoadd_preview(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_preview(deserializer));
  }

  @protected
  RedditVideo sse_decode_box_autoadd_reddit_video(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_reddit_video(deserializer));
  }

  @protected
  SecureMediaEmbed sse_decode_box_autoadd_secure_media_embed(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secure_media_embed(deserializer));
  }

  @protected
  Thing sse_decode_box_autoadd_thing(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_thing(deserializer));
  }

  @protected
  Thumbnail sse_decode_box_autoadd_thumbnail(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_thumbnail(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  User sse_decode_box_autoadd_user(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_user(deserializer));
  }

  @protected
  UserStreamSort sse_decode_box_autoadd_user_stream_sort(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_user_stream_sort(deserializer));
  }

  @protected
  VariantInner sse_decode_box_autoadd_variant_inner(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_variant_inner(deserializer));
  }

  @protected
  CommentContributionSettings sse_decode_comment_contribution_settings(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_allowedMediaTypes = sse_decode_list_String(deserializer);
    return CommentContributionSettings(
        allowedMediaTypes: var_allowedMediaTypes);
  }

  @protected
  CommentSort sse_decode_comment_sort(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return CommentSort.values[inner];
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  Feed sse_decode_feed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return Feed_Home();
      case 1:
        return Feed_All();
      case 2:
        return Feed_Popular();
      case 3:
        var var_field0 = sse_decode_String(deserializer);
        return Feed_Subreddit(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  FeedSort sse_decode_feed_sort(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return FeedSort_Best();
      case 1:
        return FeedSort_Hot();
      case 2:
        var var_field0 = sse_decode_timeframe(deserializer);
        return FeedSort_New(var_field0);
      case 3:
        var var_field0 = sse_decode_timeframe(deserializer);
        return FeedSort_Top(var_field0);
      case 4:
        return FeedSort_Rising();
      case 5:
        var var_field0 = sse_decode_timeframe(deserializer);
        return FeedSort_Controversial(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Flair sse_decode_flair(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_cssClass = sse_decode_opt_String(deserializer);
    var var_richtext = sse_decode_list_richtext(deserializer);
    var var_backgroundColor = sse_decode_opt_String(deserializer);
    var var_textColor = sse_decode_opt_String(deserializer);
    var var_text = sse_decode_opt_String(deserializer);
    var var_flairType = sse_decode_opt_String(deserializer);
    var var_templateId = sse_decode_opt_String(deserializer);
    var var_position = sse_decode_opt_String(deserializer);
    return Flair(
        cssClass: var_cssClass,
        richtext: var_richtext,
        backgroundColor: var_backgroundColor,
        textColor: var_textColor,
        text: var_text,
        flairType: var_flairType,
        templateId: var_templateId,
        position: var_position);
  }

  @protected
  Gildings sse_decode_gildings(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Gildings();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  Icon sse_decode_icon(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_width = sse_decode_usize(deserializer);
    var var_height = sse_decode_usize(deserializer);
    return Icon(url: var_url, width: var_width, height: var_height);
  }

  @protected
  Image sse_decode_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_u = sse_decode_String(deserializer);
    var var_x = sse_decode_u_32(deserializer);
    var var_y = sse_decode_u_32(deserializer);
    return Image(u: var_u, x: var_x, y: var_y);
  }

  @protected
  ImageBase sse_decode_image_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_width = sse_decode_u_32(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    return ImageBase(url: var_url, width: var_width, height: var_height);
  }

  @protected
  Kind sse_decode_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Kind.values[inner];
  }

  @protected
  List<Multi>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Multi>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<Post>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Post>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<Subreddit>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Subreddit>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<ImageBase> sse_decode_list_image_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ImageBase>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_image_base(deserializer));
    }
    return ans_;
  }

  @protected
  List<String?> sse_decode_list_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String?>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_opt_String(deserializer));
    }
    return ans_;
  }

  @protected
  Int64List sse_decode_list_prim_i_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt64List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<RedditImage> sse_decode_list_reddit_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RedditImage>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_reddit_image(deserializer));
    }
    return ans_;
  }

  @protected
  List<Richtext> sse_decode_list_richtext(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Richtext>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_richtext(deserializer));
    }
    return ans_;
  }

  @protected
  List<SubredditDetails> sse_decode_list_subreddit_details(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SubredditDetails>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_subreddit_details(deserializer));
    }
    return ans_;
  }

  @protected
  List<Thing> sse_decode_list_thing(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Thing>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_thing(deserializer));
    }
    return ans_;
  }

  @protected
  Media sse_decode_media(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_box_autoadd_reddit_video(deserializer);
        return Media_RedditVideo(var_field0);
      case 1:
        var var_oembed = sse_decode_box_autoadd_oembed(deserializer);
        var var_typeField = sse_decode_String(deserializer);
        return Media_Oembed(oembed: var_oembed, typeField: var_typeField);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  MediaEmbed sse_decode_media_embed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_content = sse_decode_String(deserializer);
    var var_width = sse_decode_u_32(deserializer);
    var var_scrolling = sse_decode_bool(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    return MediaEmbed(
        content: var_content,
        width: var_width,
        scrolling: var_scrolling,
        height: var_height);
  }

  @protected
  NotificationLevel sse_decode_notification_level(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return NotificationLevel.values[inner];
  }

  @protected
  Oembed sse_decode_oembed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_providerUrl = sse_decode_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_html = sse_decode_String(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    var var_width = sse_decode_u_32(deserializer);
    var var_version = sse_decode_String(deserializer);
    var var_authorName = sse_decode_String(deserializer);
    var var_providerName = sse_decode_String(deserializer);
    var var_typeField = sse_decode_String(deserializer);
    var var_authorUrl = sse_decode_String(deserializer);
    var var_thumbnail = sse_decode_thumbnail_option(deserializer);
    return Oembed(
        providerUrl: var_providerUrl,
        title: var_title,
        html: var_html,
        height: var_height,
        width: var_width,
        version: var_version,
        authorName: var_authorName,
        providerName: var_providerName,
        typeField: var_typeField,
        authorUrl: var_authorUrl,
        thumbnail: var_thumbnail);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Details?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  Fullname?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  Gallery?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  AuthorInfo? sse_decode_opt_box_autoadd_author_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_author_info(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  CommentSort? sse_decode_opt_box_autoadd_comment_sort(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_comment_sort(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Flair? sse_decode_opt_box_autoadd_flair(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_flair(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Media? sse_decode_opt_box_autoadd_media(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_media(deserializer));
    } else {
      return null;
    }
  }

  @protected
  MediaEmbed? sse_decode_opt_box_autoadd_media_embed(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_media_embed(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Preview? sse_decode_opt_box_autoadd_preview(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_preview(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SecureMediaEmbed? sse_decode_opt_box_autoadd_secure_media_embed(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_secure_media_embed(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Thing? sse_decode_opt_box_autoadd_thing(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_thing(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Thumbnail? sse_decode_opt_box_autoadd_thumbnail(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_thumbnail(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  VariantInner? sse_decode_opt_box_autoadd_variant_inner(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_variant_inner(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Int64List? sse_decode_opt_list_prim_i_64_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_i_64_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PostSearchSort sse_decode_post_search_sort(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_timeframe(deserializer);
        return PostSearchSort_Relevance(var_field0);
      case 1:
        return PostSearchSort_Hot();
      case 2:
        var var_field0 = sse_decode_timeframe(deserializer);
        return PostSearchSort_Top(var_field0);
      case 3:
        return PostSearchSort_New();
      case 4:
        var var_field0 = sse_decode_timeframe(deserializer);
        return PostSearchSort_Comments(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Preview sse_decode_preview(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_images = sse_decode_list_reddit_image(deserializer);
    var var_enabled = sse_decode_bool(deserializer);
    return Preview(images: var_images, enabled: var_enabled);
  }

  @protected
  (
    Post,
    List<Thing>
  ) sse_decode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_post_list_thing(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 =
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            deserializer);
    var var_field1 = sse_decode_list_thing(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  RedditAPI sse_decode_reddit_api(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return RedditAPI();
  }

  @protected
  RedditImage sse_decode_reddit_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_source = sse_decode_image_base(deserializer);
    var var_resolutions = sse_decode_list_image_base(deserializer);
    var var_variants = sse_decode_variants(deserializer);
    var var_id = sse_decode_String(deserializer);
    return RedditImage(
        source: var_source,
        resolutions: var_resolutions,
        variants: var_variants,
        id: var_id);
  }

  @protected
  RedditVideo sse_decode_reddit_video(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_bitrateKbps = sse_decode_u_32(deserializer);
    var var_width = sse_decode_u_32(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    var var_hasAudio = sse_decode_bool(deserializer);
    var var_isGif = sse_decode_bool(deserializer);
    var var_fallbackUrl = sse_decode_String(deserializer);
    var var_scrubberMediaUrl = sse_decode_String(deserializer);
    var var_dashUrl = sse_decode_String(deserializer);
    var var_hlsUrl = sse_decode_String(deserializer);
    var var_duration = sse_decode_u_32(deserializer);
    var var_transcodingStatus = sse_decode_String(deserializer);
    return RedditVideo(
        bitrateKbps: var_bitrateKbps,
        width: var_width,
        height: var_height,
        hasAudio: var_hasAudio,
        isGif: var_isGif,
        fallbackUrl: var_fallbackUrl,
        scrubberMediaUrl: var_scrubberMediaUrl,
        dashUrl: var_dashUrl,
        hlsUrl: var_hlsUrl,
        duration: var_duration,
        transcodingStatus: var_transcodingStatus);
  }

  @protected
  Richtext sse_decode_richtext(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_t = sse_decode_String(deserializer);
        return Richtext_Text(t: var_t);
      case 1:
        var var_a = sse_decode_String(deserializer);
        var var_u = sse_decode_String(deserializer);
        return Richtext_Emoji(a: var_a, u: var_u);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SecureMediaEmbed sse_decode_secure_media_embed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_content = sse_decode_String(deserializer);
    var var_width = sse_decode_u_32(deserializer);
    var var_scrolling = sse_decode_bool(deserializer);
    var var_mediaDomainUrl = sse_decode_String(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    return SecureMediaEmbed(
        content: var_content,
        width: var_width,
        scrolling: var_scrolling,
        mediaDomainUrl: var_mediaDomainUrl,
        height: var_height);
  }

  @protected
  Snoovatar sse_decode_snoovatar(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_prefShowSnoovatar = sse_decode_bool(deserializer);
    var var_snoovatarSize = sse_decode_opt_String(deserializer);
    var var_snoovatarImg = sse_decode_String(deserializer);
    return Snoovatar(
        prefShowSnoovatar: var_prefShowSnoovatar,
        snoovatarSize: var_snoovatarSize,
        snoovatarImg: var_snoovatarImg);
  }

  @protected
  Source sse_decode_source(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_source = sse_decode_box_autoadd_image(deserializer);
        return Source_Image(source: var_source);
      case 1:
        var var_source = sse_decode_box_autoadd_animated_image(deserializer);
        return Source_AnimatedImage(source: var_source);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SubredditDetails sse_decode_subreddit_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    return SubredditDetails(name: var_name);
  }

  @protected
  SubredditIcon sse_decode_subreddit_icon(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_box_autoadd_icon(deserializer);
        return SubredditIcon_Image(var_field0);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return SubredditIcon_Color(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SubredditSearchSort sse_decode_subreddit_search_sort(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SubredditSearchSort.values[inner];
  }

  @protected
  Thing sse_decode_thing(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
                deserializer);
        return Thing_Listing(var_field0);
      case 1:
        var var_field0 =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
                deserializer);
        return Thing_Comment(var_field0);
      case 2:
        var var_field0 = sse_decode_box_autoadd_user(deserializer);
        return Thing_User(var_field0);
      case 3:
        var var_field0 =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
                deserializer);
        return Thing_Post(var_field0);
      case 4:
        return Thing_Message();
      case 5:
        var var_field0 =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
                deserializer);
        return Thing_Subreddit(var_field0);
      case 6:
        return Thing_Award();
      case 7:
        var var_field0 =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
                deserializer);
        return Thing_Multi(var_field0);
      case 8:
        var var_id = sse_decode_String(deserializer);
        var var_name =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
                deserializer);
        var var_count = sse_decode_u_32(deserializer);
        var var_depth = sse_decode_u_32(deserializer);
        var var_children = sse_decode_list_String(deserializer);
        return Thing_More(
            id: var_id,
            name: var_name,
            count: var_count,
            depth: var_depth,
            children: var_children);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Thumbnail sse_decode_thumbnail(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    var var_width = sse_decode_u_32(deserializer);
    return Thumbnail(url: var_url, height: var_height, width: var_width);
  }

  @protected
  ThumbnailOption sse_decode_thumbnail_option(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_opt_String(deserializer);
    var var_height = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_width = sse_decode_opt_box_autoadd_u_32(deserializer);
    return ThumbnailOption(url: var_url, height: var_height, width: var_width);
  }

  @protected
  ThumbnailURL sse_decode_thumbnail_url(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_opt_String(deserializer);
    var var_height = sse_decode_opt_box_autoadd_u_32(deserializer);
    var var_width = sse_decode_opt_box_autoadd_u_32(deserializer);
    return ThumbnailURL(url: var_url, height: var_height, width: var_width);
  }

  @protected
  Timeframe sse_decode_timeframe(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Timeframe.values[inner];
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  User sse_decode_user(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_info = sse_decode_user_info(deserializer);
    var var_goldExpiration = sse_decode_opt_String(deserializer);
    var var_isSponsor = sse_decode_bool(deserializer);
    var var_numFriends = sse_decode_i_64(deserializer);
    var var_canEditName = sse_decode_bool(deserializer);
    var var_newModmailExists = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_coins = sse_decode_i_64(deserializer);
    var var_canCreateSubreddit = sse_decode_bool(deserializer);
    var var_suspensionExpirationUtc =
        sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_hasModMail = sse_decode_bool(deserializer);
    var var_hasMail = sse_decode_bool(deserializer);
    var var_isSuspended = sse_decode_bool(deserializer);
    var var_inboxCount = sse_decode_i_64(deserializer);
    var var_goldCreddits = sse_decode_i_64(deserializer);
    return User(
        info: var_info,
        goldExpiration: var_goldExpiration,
        isSponsor: var_isSponsor,
        numFriends: var_numFriends,
        canEditName: var_canEditName,
        newModmailExists: var_newModmailExists,
        coins: var_coins,
        canCreateSubreddit: var_canCreateSubreddit,
        suspensionExpirationUtc: var_suspensionExpirationUtc,
        hasModMail: var_hasModMail,
        hasMail: var_hasMail,
        isSuspended: var_isSuspended,
        inboxCount: var_inboxCount,
        goldCreddits: var_goldCreddits);
  }

  @protected
  UserInfo sse_decode_user_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_subreddit = sse_decode_user_subreddit(deserializer);
    var var_created = sse_decode_f_64(deserializer);
    var var_over18 = sse_decode_bool(deserializer);
    var var_createdUtc = sse_decode_f_64(deserializer);
    var var_isBlocked = sse_decode_bool(deserializer);
    var var_isEmployee = sse_decode_bool(deserializer);
    var var_isFriend = sse_decode_bool(deserializer);
    var var_awardeeKarma = sse_decode_i_64(deserializer);
    var var_verified = sse_decode_bool(deserializer);
    var var_awarderKarma = sse_decode_i_64(deserializer);
    var var_iconImg = sse_decode_String(deserializer);
    var var_linkKarma = sse_decode_i_64(deserializer);
    var var_totalKarma = sse_decode_i_64(deserializer);
    var var_commentKarma = sse_decode_i_64(deserializer);
    var var_acceptFollowers = sse_decode_bool(deserializer);
    var var_acceptChats = sse_decode_bool(deserializer);
    var var_acceptPms = sse_decode_bool(deserializer);
    return UserInfo(
        id: var_id,
        name: var_name,
        subreddit: var_subreddit,
        created: var_created,
        over18: var_over18,
        createdUtc: var_createdUtc,
        isBlocked: var_isBlocked,
        isEmployee: var_isEmployee,
        isFriend: var_isFriend,
        awardeeKarma: var_awardeeKarma,
        verified: var_verified,
        awarderKarma: var_awarderKarma,
        iconImg: var_iconImg,
        linkKarma: var_linkKarma,
        totalKarma: var_totalKarma,
        commentKarma: var_commentKarma,
        acceptFollowers: var_acceptFollowers,
        acceptChats: var_acceptChats,
        acceptPms: var_acceptPms);
  }

  @protected
  UserStreamSort sse_decode_user_stream_sort(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return UserStreamSort_Hot();
      case 1:
        var var_field0 = sse_decode_timeframe(deserializer);
        return UserStreamSort_Top(var_field0);
      case 2:
        return UserStreamSort_New();
      case 3:
        var var_field0 = sse_decode_timeframe(deserializer);
        return UserStreamSort_Controversial(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  UserSubreddit sse_decode_user_subreddit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_defaultSet = sse_decode_bool(deserializer);
    var var_userIsContributor = sse_decode_bool(deserializer);
    var var_bannerImg = sse_decode_String(deserializer);
    var var_allowedMediaInComments = sse_decode_list_String(deserializer);
    var var_userIsBanned = sse_decode_bool(deserializer);
    var var_freeFormReports = sse_decode_bool(deserializer);
    var var_communityIcon = sse_decode_opt_String(deserializer);
    var var_showMedia = sse_decode_bool(deserializer);
    var var_iconColor = sse_decode_String(deserializer);
    var var_userIsMuted = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_displayName = sse_decode_String(deserializer);
    var var_headerImg = sse_decode_opt_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_coins = sse_decode_i_64(deserializer);
    var var_previousNames = sse_decode_list_String(deserializer);
    var var_over18 = sse_decode_bool(deserializer);
    var var_iconSize = sse_decode_list_prim_i_64_strict(deserializer);
    var var_primaryColor = sse_decode_String(deserializer);
    var var_iconImg = sse_decode_String(deserializer);
    var var_description = sse_decode_String(deserializer);
    var var_submitLinkLabel = sse_decode_String(deserializer);
    var var_headerSize = sse_decode_opt_String(deserializer);
    var var_restrictPosting = sse_decode_bool(deserializer);
    var var_restrictCommenting = sse_decode_bool(deserializer);
    var var_subscribers = sse_decode_i_64(deserializer);
    var var_submitTextLabel = sse_decode_String(deserializer);
    var var_isDefaultIcon = sse_decode_bool(deserializer);
    var var_linkFlairPosition = sse_decode_String(deserializer);
    var var_displayNamePrefixed = sse_decode_String(deserializer);
    var var_keyColor = sse_decode_String(deserializer);
    var var_isDefaultBanner = sse_decode_bool(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_quarantine = sse_decode_bool(deserializer);
    var var_bannerSize = sse_decode_opt_String(deserializer);
    var var_userIsModerator = sse_decode_bool(deserializer);
    var var_publicDescription = sse_decode_String(deserializer);
    var var_linkFlairEnabled = sse_decode_bool(deserializer);
    var var_disableContributorRequests = sse_decode_bool(deserializer);
    var var_subredditType = sse_decode_String(deserializer);
    var var_userIsSubscriber = sse_decode_bool(deserializer);
    return UserSubreddit(
        defaultSet: var_defaultSet,
        userIsContributor: var_userIsContributor,
        bannerImg: var_bannerImg,
        allowedMediaInComments: var_allowedMediaInComments,
        userIsBanned: var_userIsBanned,
        freeFormReports: var_freeFormReports,
        communityIcon: var_communityIcon,
        showMedia: var_showMedia,
        iconColor: var_iconColor,
        userIsMuted: var_userIsMuted,
        displayName: var_displayName,
        headerImg: var_headerImg,
        title: var_title,
        coins: var_coins,
        previousNames: var_previousNames,
        over18: var_over18,
        iconSize: var_iconSize,
        primaryColor: var_primaryColor,
        iconImg: var_iconImg,
        description: var_description,
        submitLinkLabel: var_submitLinkLabel,
        headerSize: var_headerSize,
        restrictPosting: var_restrictPosting,
        restrictCommenting: var_restrictCommenting,
        subscribers: var_subscribers,
        submitTextLabel: var_submitTextLabel,
        isDefaultIcon: var_isDefaultIcon,
        linkFlairPosition: var_linkFlairPosition,
        displayNamePrefixed: var_displayNamePrefixed,
        keyColor: var_keyColor,
        isDefaultBanner: var_isDefaultBanner,
        url: var_url,
        quarantine: var_quarantine,
        bannerSize: var_bannerSize,
        userIsModerator: var_userIsModerator,
        publicDescription: var_publicDescription,
        linkFlairEnabled: var_linkFlairEnabled,
        disableContributorRequests: var_disableContributorRequests,
        subredditType: var_subredditType,
        userIsSubscriber: var_userIsSubscriber);
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  VariantInner sse_decode_variant_inner(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_source = sse_decode_image_base(deserializer);
    var var_resolutions = sse_decode_list_image_base(deserializer);
    return VariantInner(source: var_source, resolutions: var_resolutions);
  }

  @protected
  Variants sse_decode_variants(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_gif = sse_decode_opt_box_autoadd_variant_inner(deserializer);
    var var_mp4 = sse_decode_opt_box_autoadd_variant_inner(deserializer);
    var var_obfuscated = sse_decode_opt_box_autoadd_variant_inner(deserializer);
    var var_nsfw = sse_decode_opt_box_autoadd_variant_inner(deserializer);
    return Variants(
        gif: var_gif, mp4: var_mp4, obfuscated: var_obfuscated, nsfw: var_nsfw);
  }

  @protected
  VoteDirection sse_decode_vote_direction(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return VoteDirection.values[inner];
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxFeedStream(
          BoxFeedStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as BoxFeedStreamImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxMultiStream(
          BoxMultiStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as BoxMultiStreamImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          Client self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ClientImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
          Comment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CommentImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
          Common self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CommonImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          Details self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as DetailsImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream(
          FeedStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FeedStreamImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          Fullname self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FullnameImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          Gallery self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GalleryImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryData(
          GalleryData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GalleryDataImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
          GalleryMedia self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GalleryMediaImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          Listing self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ListingImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          Multi self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MultiImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiStream(
          MultiStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MultiStreamImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          Pager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PagerImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          Post self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PostImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
          PostId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PostIdImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchPost(
          SearchPost self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SearchPostImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchSubreddit(
          SearchSubreddit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SearchSubredditImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
          Streamable self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as StreamableImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          Subreddit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
          SubredditId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditIdImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SubredditInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditInfoImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
          Url self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as UrlImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
          Comment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CommentImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
          Common self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CommonImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          Details self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as DetailsImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
          GalleryMedia self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GalleryMediaImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          Listing self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ListingImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          Multi self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MultiImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          Pager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PagerImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          Post self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PostImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
          Streamable self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as StreamableImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          Subreddit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SubredditInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditInfoImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          Client self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ClientImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
          Comment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CommentImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
          Common self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CommonImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          Details self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as DetailsImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          Fullname self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FullnameImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          Gallery self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GalleryImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
          GalleryMedia self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GalleryMediaImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          Listing self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ListingImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          Multi self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MultiImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          Pager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PagerImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          Post self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PostImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
          Streamable self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as StreamableImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          Subreddit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SubredditInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditInfoImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void sse_encode_Chrono_Local(DateTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(
        PlatformInt64Util.from(self.microsecondsSinceEpoch), serializer);
  }

  @protected
  void sse_encode_Chrono_Utc(DateTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(
        PlatformInt64Util.from(self.microsecondsSinceEpoch), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxFeedStream(
          BoxFeedStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as BoxFeedStreamImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerBoxMultiStream(
          BoxMultiStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as BoxMultiStreamImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          Client self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ClientImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
          Comment self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CommentImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerCommon(
          Common self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as CommonImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          Details self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as DetailsImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream(
          FeedStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FeedStreamImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          Fullname self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FullnameImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          Gallery self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GalleryImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryData(
          GalleryData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GalleryDataImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGalleryMedia(
          GalleryMedia self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as GalleryMediaImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          Listing self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ListingImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          Multi self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MultiImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMultiStream(
          MultiStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MultiStreamImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          Pager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PagerImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          Post self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PostImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
          PostId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PostIdImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchPost(
          SearchPost self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SearchPostImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSearchSubreddit(
          SearchSubreddit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SearchSubredditImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerStreamable(
          Streamable self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as StreamableImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          Subreddit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
          SubredditId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditIdImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SubredditInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditInfoImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
          Url self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as UrlImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_animated_image(AnimatedImage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.x, serializer);
    sse_encode_u_32(self.y, serializer);
    sse_encode_String(self.gif, serializer);
    sse_encode_String(self.mp4, serializer);
  }

  @protected
  void sse_encode_author_info(AuthorInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.username, serializer);
    sse_encode_bool(self.premium, serializer);
    sse_encode_flair(self.flair, serializer);
    sse_encode_String(self.fullname, serializer);
    sse_encode_bool(self.isBlocked, serializer);
    sse_encode_bool(self.patreonFlair, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          Details self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
        self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          Fullname self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
        self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          Gallery self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
        self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_animated_image(
      AnimatedImage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_animated_image(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_author_info(
      AuthorInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_author_info(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_comment_sort(
      CommentSort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_comment_sort(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_feed(Feed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_feed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_feed_sort(
      FeedSort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_feed_sort(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_flair(Flair self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_flair(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(
      PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_icon(Icon self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_icon(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_image(Image self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_image(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media(Media self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media_embed(
      MediaEmbed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_embed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_oembed(Oembed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_oembed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_post_search_sort(
      PostSearchSort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_post_search_sort(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_preview(Preview self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_preview(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_reddit_video(
      RedditVideo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_reddit_video(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secure_media_embed(
      SecureMediaEmbed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secure_media_embed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_thing(Thing self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_thing(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_thumbnail(
      Thumbnail self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_thumbnail(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_user(User self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_user_stream_sort(
      UserStreamSort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user_stream_sort(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_variant_inner(
      VariantInner self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_variant_inner(self, serializer);
  }

  @protected
  void sse_encode_comment_contribution_settings(
      CommentContributionSettings self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_String(self.allowedMediaTypes, serializer);
  }

  @protected
  void sse_encode_comment_sort(CommentSort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_feed(Feed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Feed_Home():
        sse_encode_i_32(0, serializer);
      case Feed_All():
        sse_encode_i_32(1, serializer);
      case Feed_Popular():
        sse_encode_i_32(2, serializer);
      case Feed_Subreddit(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_feed_sort(FeedSort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case FeedSort_Best():
        sse_encode_i_32(0, serializer);
      case FeedSort_Hot():
        sse_encode_i_32(1, serializer);
      case FeedSort_New(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_timeframe(field0, serializer);
      case FeedSort_Top(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_timeframe(field0, serializer);
      case FeedSort_Rising():
        sse_encode_i_32(4, serializer);
      case FeedSort_Controversial(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_timeframe(field0, serializer);
    }
  }

  @protected
  void sse_encode_flair(Flair self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.cssClass, serializer);
    sse_encode_list_richtext(self.richtext, serializer);
    sse_encode_opt_String(self.backgroundColor, serializer);
    sse_encode_opt_String(self.textColor, serializer);
    sse_encode_opt_String(self.text, serializer);
    sse_encode_opt_String(self.flairType, serializer);
    sse_encode_opt_String(self.templateId, serializer);
    sse_encode_opt_String(self.position, serializer);
  }

  @protected
  void sse_encode_gildings(Gildings self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_icon(Icon self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_usize(self.width, serializer);
    sse_encode_usize(self.height, serializer);
  }

  @protected
  void sse_encode_image(Image self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.u, serializer);
    sse_encode_u_32(self.x, serializer);
    sse_encode_u_32(self.y, serializer);
  }

  @protected
  void sse_encode_image_base(ImageBase self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_u_32(self.width, serializer);
    sse_encode_u_32(self.height, serializer);
  }

  @protected
  void sse_encode_kind(Kind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          List<Multi> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
          item, serializer);
    }
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          List<Post> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          item, serializer);
    }
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          List<Subreddit> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          item, serializer);
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_image_base(
      List<ImageBase> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_image_base(item, serializer);
    }
  }

  @protected
  void sse_encode_list_opt_String(
      List<String?> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_opt_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_i_64_strict(
      Int64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_reddit_image(
      List<RedditImage> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_reddit_image(item, serializer);
    }
  }

  @protected
  void sse_encode_list_richtext(List<Richtext> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_richtext(item, serializer);
    }
  }

  @protected
  void sse_encode_list_subreddit_details(
      List<SubredditDetails> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_subreddit_details(item, serializer);
    }
  }

  @protected
  void sse_encode_list_thing(List<Thing> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_thing(item, serializer);
    }
  }

  @protected
  void sse_encode_media(Media self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Media_RedditVideo(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_reddit_video(field0, serializer);
      case Media_Oembed(oembed: final oembed, typeField: final typeField):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_oembed(oembed, serializer);
        sse_encode_String(typeField, serializer);
    }
  }

  @protected
  void sse_encode_media_embed(MediaEmbed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.content, serializer);
    sse_encode_u_32(self.width, serializer);
    sse_encode_bool(self.scrolling, serializer);
    sse_encode_u_32(self.height, serializer);
  }

  @protected
  void sse_encode_notification_level(
      NotificationLevel self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_oembed(Oembed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.providerUrl, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_String(self.html, serializer);
    sse_encode_u_32(self.height, serializer);
    sse_encode_u_32(self.width, serializer);
    sse_encode_String(self.version, serializer);
    sse_encode_String(self.authorName, serializer);
    sse_encode_String(self.providerName, serializer);
    sse_encode_String(self.typeField, serializer);
    sse_encode_String(self.authorUrl, serializer);
    sse_encode_thumbnail_option(self.thumbnail, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          Details? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDetails(
          self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          Fullname? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          Gallery? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerGallery(
          self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_author_info(
      AuthorInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_author_info(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_comment_sort(
      CommentSort? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_comment_sort(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_64(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_flair(Flair? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_flair(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(
      PlatformInt64? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_media(Media? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_media(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_media_embed(
      MediaEmbed? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_media_embed(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_preview(
      Preview? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_preview(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_secure_media_embed(
      SecureMediaEmbed? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_secure_media_embed(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_thing(Thing? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_thing(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_thumbnail(
      Thumbnail? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_thumbnail(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_variant_inner(
      VariantInner? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_variant_inner(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_i_64_strict(
      Int64List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_i_64_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_post_search_sort(
      PostSearchSort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PostSearchSort_Relevance(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_timeframe(field0, serializer);
      case PostSearchSort_Hot():
        sse_encode_i_32(1, serializer);
      case PostSearchSort_Top(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_timeframe(field0, serializer);
      case PostSearchSort_New():
        sse_encode_i_32(3, serializer);
      case PostSearchSort_Comments(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_timeframe(field0, serializer);
    }
  }

  @protected
  void sse_encode_preview(Preview self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_reddit_image(self.images, serializer);
    sse_encode_bool(self.enabled, serializer);
  }

  @protected
  void
      sse_encode_record_auto_owned_rust_opaque_flutter_rust_bridgefor_generated_rust_auto_opaque_inner_post_list_thing(
          (Post, List<Thing>) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
        self.$1, serializer);
    sse_encode_list_thing(self.$2, serializer);
  }

  @protected
  void sse_encode_reddit_api(RedditAPI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_reddit_image(RedditImage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_image_base(self.source, serializer);
    sse_encode_list_image_base(self.resolutions, serializer);
    sse_encode_variants(self.variants, serializer);
    sse_encode_String(self.id, serializer);
  }

  @protected
  void sse_encode_reddit_video(RedditVideo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.bitrateKbps, serializer);
    sse_encode_u_32(self.width, serializer);
    sse_encode_u_32(self.height, serializer);
    sse_encode_bool(self.hasAudio, serializer);
    sse_encode_bool(self.isGif, serializer);
    sse_encode_String(self.fallbackUrl, serializer);
    sse_encode_String(self.scrubberMediaUrl, serializer);
    sse_encode_String(self.dashUrl, serializer);
    sse_encode_String(self.hlsUrl, serializer);
    sse_encode_u_32(self.duration, serializer);
    sse_encode_String(self.transcodingStatus, serializer);
  }

  @protected
  void sse_encode_richtext(Richtext self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Richtext_Text(t: final t):
        sse_encode_i_32(0, serializer);
        sse_encode_String(t, serializer);
      case Richtext_Emoji(a: final a, u: final u):
        sse_encode_i_32(1, serializer);
        sse_encode_String(a, serializer);
        sse_encode_String(u, serializer);
    }
  }

  @protected
  void sse_encode_secure_media_embed(
      SecureMediaEmbed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.content, serializer);
    sse_encode_u_32(self.width, serializer);
    sse_encode_bool(self.scrolling, serializer);
    sse_encode_String(self.mediaDomainUrl, serializer);
    sse_encode_u_32(self.height, serializer);
  }

  @protected
  void sse_encode_snoovatar(Snoovatar self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.prefShowSnoovatar, serializer);
    sse_encode_opt_String(self.snoovatarSize, serializer);
    sse_encode_String(self.snoovatarImg, serializer);
  }

  @protected
  void sse_encode_source(Source self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Source_Image(source: final source):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_image(source, serializer);
      case Source_AnimatedImage(source: final source):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_animated_image(source, serializer);
    }
  }

  @protected
  void sse_encode_subreddit_details(
      SubredditDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
  }

  @protected
  void sse_encode_subreddit_icon(SubredditIcon self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case SubredditIcon_Image(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_box_autoadd_icon(field0, serializer);
      case SubredditIcon_Color(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_subreddit_search_sort(
      SubredditSearchSort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_thing(Thing self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Thing_Listing(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            field0, serializer);
      case Thing_Comment(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerComment(
            field0, serializer);
      case Thing_User(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_user(field0, serializer);
      case Thing_Post(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            field0, serializer);
      case Thing_Message():
        sse_encode_i_32(4, serializer);
      case Thing_Subreddit(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            field0, serializer);
      case Thing_Award():
        sse_encode_i_32(6, serializer);
      case Thing_Multi(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMulti(
            field0, serializer);
      case Thing_More(
          id: final id,
          name: final name,
          count: final count,
          depth: final depth,
          children: final children
        ):
        sse_encode_i_32(8, serializer);
        sse_encode_String(id, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            name, serializer);
        sse_encode_u_32(count, serializer);
        sse_encode_u_32(depth, serializer);
        sse_encode_list_String(children, serializer);
    }
  }

  @protected
  void sse_encode_thumbnail(Thumbnail self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_u_32(self.height, serializer);
    sse_encode_u_32(self.width, serializer);
  }

  @protected
  void sse_encode_thumbnail_option(
      ThumbnailOption self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.url, serializer);
    sse_encode_opt_box_autoadd_u_32(self.height, serializer);
    sse_encode_opt_box_autoadd_u_32(self.width, serializer);
  }

  @protected
  void sse_encode_thumbnail_url(ThumbnailURL self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.url, serializer);
    sse_encode_opt_box_autoadd_u_32(self.height, serializer);
    sse_encode_opt_box_autoadd_u_32(self.width, serializer);
  }

  @protected
  void sse_encode_timeframe(Timeframe self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_user(User self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user_info(self.info, serializer);
    sse_encode_opt_String(self.goldExpiration, serializer);
    sse_encode_bool(self.isSponsor, serializer);
    sse_encode_i_64(self.numFriends, serializer);
    sse_encode_bool(self.canEditName, serializer);
    sse_encode_opt_box_autoadd_bool(self.newModmailExists, serializer);
    sse_encode_i_64(self.coins, serializer);
    sse_encode_bool(self.canCreateSubreddit, serializer);
    sse_encode_opt_box_autoadd_f_32(self.suspensionExpirationUtc, serializer);
    sse_encode_bool(self.hasModMail, serializer);
    sse_encode_bool(self.hasMail, serializer);
    sse_encode_bool(self.isSuspended, serializer);
    sse_encode_i_64(self.inboxCount, serializer);
    sse_encode_i_64(self.goldCreddits, serializer);
  }

  @protected
  void sse_encode_user_info(UserInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_user_subreddit(self.subreddit, serializer);
    sse_encode_f_64(self.created, serializer);
    sse_encode_bool(self.over18, serializer);
    sse_encode_f_64(self.createdUtc, serializer);
    sse_encode_bool(self.isBlocked, serializer);
    sse_encode_bool(self.isEmployee, serializer);
    sse_encode_bool(self.isFriend, serializer);
    sse_encode_i_64(self.awardeeKarma, serializer);
    sse_encode_bool(self.verified, serializer);
    sse_encode_i_64(self.awarderKarma, serializer);
    sse_encode_String(self.iconImg, serializer);
    sse_encode_i_64(self.linkKarma, serializer);
    sse_encode_i_64(self.totalKarma, serializer);
    sse_encode_i_64(self.commentKarma, serializer);
    sse_encode_bool(self.acceptFollowers, serializer);
    sse_encode_bool(self.acceptChats, serializer);
    sse_encode_bool(self.acceptPms, serializer);
  }

  @protected
  void sse_encode_user_stream_sort(
      UserStreamSort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case UserStreamSort_Hot():
        sse_encode_i_32(0, serializer);
      case UserStreamSort_Top(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_timeframe(field0, serializer);
      case UserStreamSort_New():
        sse_encode_i_32(2, serializer);
      case UserStreamSort_Controversial(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_timeframe(field0, serializer);
    }
  }

  @protected
  void sse_encode_user_subreddit(UserSubreddit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.defaultSet, serializer);
    sse_encode_bool(self.userIsContributor, serializer);
    sse_encode_String(self.bannerImg, serializer);
    sse_encode_list_String(self.allowedMediaInComments, serializer);
    sse_encode_bool(self.userIsBanned, serializer);
    sse_encode_bool(self.freeFormReports, serializer);
    sse_encode_opt_String(self.communityIcon, serializer);
    sse_encode_bool(self.showMedia, serializer);
    sse_encode_String(self.iconColor, serializer);
    sse_encode_opt_box_autoadd_bool(self.userIsMuted, serializer);
    sse_encode_String(self.displayName, serializer);
    sse_encode_opt_String(self.headerImg, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_i_64(self.coins, serializer);
    sse_encode_list_String(self.previousNames, serializer);
    sse_encode_bool(self.over18, serializer);
    sse_encode_list_prim_i_64_strict(self.iconSize, serializer);
    sse_encode_String(self.primaryColor, serializer);
    sse_encode_String(self.iconImg, serializer);
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.submitLinkLabel, serializer);
    sse_encode_opt_String(self.headerSize, serializer);
    sse_encode_bool(self.restrictPosting, serializer);
    sse_encode_bool(self.restrictCommenting, serializer);
    sse_encode_i_64(self.subscribers, serializer);
    sse_encode_String(self.submitTextLabel, serializer);
    sse_encode_bool(self.isDefaultIcon, serializer);
    sse_encode_String(self.linkFlairPosition, serializer);
    sse_encode_String(self.displayNamePrefixed, serializer);
    sse_encode_String(self.keyColor, serializer);
    sse_encode_bool(self.isDefaultBanner, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_bool(self.quarantine, serializer);
    sse_encode_opt_String(self.bannerSize, serializer);
    sse_encode_bool(self.userIsModerator, serializer);
    sse_encode_String(self.publicDescription, serializer);
    sse_encode_bool(self.linkFlairEnabled, serializer);
    sse_encode_bool(self.disableContributorRequests, serializer);
    sse_encode_String(self.subredditType, serializer);
    sse_encode_bool(self.userIsSubscriber, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_variant_inner(VariantInner self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_image_base(self.source, serializer);
    sse_encode_list_image_base(self.resolutions, serializer);
  }

  @protected
  void sse_encode_variants(Variants self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_box_autoadd_variant_inner(self.gif, serializer);
    sse_encode_opt_box_autoadd_variant_inner(self.mp4, serializer);
    sse_encode_opt_box_autoadd_variant_inner(self.obfuscated, serializer);
    sse_encode_opt_box_autoadd_variant_inner(self.nsfw, serializer);
  }

  @protected
  void sse_encode_vote_direction(VoteDirection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }
}

@sealed
class BoxFeedStreamImpl extends RustOpaque implements BoxFeedStream {
  // Not to be used by end users
  BoxFeedStreamImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  BoxFeedStreamImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_BoxFeedStream,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_BoxFeedStream,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_BoxFeedStreamPtr,
  );
}

@sealed
class BoxMultiStreamImpl extends RustOpaque implements BoxMultiStream {
  // Not to be used by end users
  BoxMultiStreamImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  BoxMultiStreamImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_BoxMultiStream,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_BoxMultiStream,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_BoxMultiStreamPtr,
  );
}

@sealed
class ClientImpl extends RustOpaque implements Client {
  // Not to be used by end users
  ClientImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ClientImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Client,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Client,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ClientPtr,
  );

  /// Authenticate the current client
  Future<void> authenticate({required String refreshToken}) =>
      RustLib.instance.api.redditApiClientClientAuthenticate(
          that: this, refreshToken: refreshToken);

  /// Returns the comments for the post at the given permalink. Each element in the vec is either
  /// a [`Thing::Comment`] or a [`Thing::More`].
  /// # Errors
  /// Fails if the request fails or the parsing of the response fails.
  Future<(Post, List<Thing>)> comments(
          {required String permalink, CommentSort? sort}) =>
      RustLib.instance.api.redditApiClientClientComments(
          that: this, permalink: permalink, sort: sort);

  /// flutter_rust_bridge:sync
  Streamable feedStream({required Feed feed, required FeedSort sort}) =>
      RustLib.instance.api
          .redditApiClientClientFeedStream(that: this, feed: feed, sort: sort);

  /// Returns the content of the post at the given permalink.
  /// # Errors
  /// Fails if the request fails or the parsing of the response fails.
  Future<Post> getPost({required String permalink}) => RustLib.instance.api
      .redditApiClientClientGetPost(that: this, permalink: permalink);

  Future<List<Thing>> loadMoreComments(
          {required Fullname parentId,
          required List<String> children,
          CommentSort? sort}) =>
      RustLib.instance.api.redditApiClientClientLoadMoreComments(
          that: this, parentId: parentId, children: children, sort: sort);

  /// Get the info of the current user.
  /// # Errors
  /// Returns an error if the http client fails or if the parsing of the response fails.
  Future<UserInfo> loggedUserInfo() =>
      RustLib.instance.api.redditApiClientClientLoggedUserInfo(
        that: this,
      );

  ///flutter_rust_bridge:sync
  Streamable multiPosts({required Multi multi, required FeedSort sort}) =>
      RustLib.instance.api.redditApiClientClientMultiPosts(
          that: this, multi: multi, sort: sort);

  /// Get the list of multireddits the current user is subscribed to.
  /// # Errors
  /// Returns an error if the http client fails or if the parsing of the response fails.
  Future<List<Multi>> multis() =>
      RustLib.instance.api.redditApiClientClientMultis(
        that: this,
      );

  /// Create a new access token for a logged out user
  Future<void> newLoggedOutUserToken() =>
      RustLib.instance.api.redditApiClientClientNewLoggedOutUserToken(
        that: this,
      );

  /// Save a saveable item (i.e. a [`Post`] or a [`comment::Comment`]).
  /// # Errors
  /// Returns an error if the request failed.
  Future<void> save({required Fullname thing}) =>
      RustLib.instance.api.redditApiClientClientSave(that: this, thing: thing);

  ///flutter_rust_bridge:sync
  Streamable searchPost(
          {String? subreddit,
          Flair? flair,
          String? query,
          required PostSearchSort sort}) =>
      RustLib.instance.api.redditApiClientClientSearchPost(
          that: this,
          subreddit: subreddit,
          flair: flair,
          query: query,
          sort: sort);

  ///flutter_rust_bridge:sync
  Streamable searchSubreddits(
          {required String query, required SubredditSearchSort sort}) =>
      RustLib.instance.api.redditApiClientClientSearchSubreddits(
          that: this, query: query, sort: sort);

  /// Get the list of all subreddits the current user is subscribed to.
  /// # Errors
  /// Returns an error if the http client fails or if the parsing of the response fails.
  Future<List<Subreddit>> subsriptions() =>
      RustLib.instance.api.redditApiClientClientSubsriptions(
        that: this,
      );

  /// Unsave a saveable item (i.e. a [`Post`] or a [`comment::Comment`]).
  /// # Errors
  /// Returns an error if the request failed.
  Future<void> unsave({required Fullname thing}) => RustLib.instance.api
      .redditApiClientClientUnsave(that: this, thing: thing);

  /// flutter_rust_bridge:
  Future<UserInfo> userAbout({required String username}) => RustLib.instance.api
      .redditApiClientClientUserAbout(that: this, username: username);

  /// flutter_rust_bridge:sync
  Streamable userComments(
          {required String username, required UserStreamSort sort}) =>
      RustLib.instance.api.redditApiClientClientUserComments(
          that: this, username: username, sort: sort);

  /// flutter_rust_bridge:sync
  Streamable userDownvoted({required String username}) => RustLib.instance.api
      .redditApiClientClientUserDownvoted(that: this, username: username);

  /// flutter_rust_bridge:sync
  Streamable userGilded({required String username}) => RustLib.instance.api
      .redditApiClientClientUserGilded(that: this, username: username);

  /// flutter_rust_bridge:sync
  Streamable userHidden({required String username}) => RustLib.instance.api
      .redditApiClientClientUserHidden(that: this, username: username);

  /// flutter_rust_bridge:sync
  Streamable userOverview(
          {required String username, required UserStreamSort sort}) =>
      RustLib.instance.api.redditApiClientClientUserOverview(
          that: this, username: username, sort: sort);

  /// Get saved items ( both [`Post`] and [`Comment`] ) for the specified user.
  /// # Errors
  /// Fails if api request fails.
  /// flutter_rust_bridge:sync
  Streamable userSaved({required String username}) => RustLib.instance.api
      .redditApiClientClientUserSaved(that: this, username: username);

  /// flutter_rust_bridge:sync
  Streamable userSubmitted(
          {required String username, required UserStreamSort sort}) =>
      RustLib.instance.api.redditApiClientClientUserSubmitted(
          that: this, username: username, sort: sort);

  /// flutter_rust_bridge:sync
  Streamable userUpvoted({required String username}) => RustLib.instance.api
      .redditApiClientClientUserUpvoted(that: this, username: username);

  /// Vote on a votable item (i.e. a [`Post`] or a [`comment::Comment`]).
  /// # Errors
  /// Returns an error if the request failed.
  Future<void> vote(
          {required Fullname fullname, required VoteDirection direction}) =>
      RustLib.instance.api.redditApiClientClientVote(
          that: this, fullname: fullname, direction: direction);
}

@sealed
class CommentImpl extends RustOpaque implements Comment {
  // Not to be used by end users
  CommentImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  CommentImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Comment,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Comment,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_CommentPtr,
  );

  bool get archived =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetArchived(
        that: this,
      );

  AuthorInfo? get author =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetAuthor(
        that: this,
      );

  String get body =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetBody(
        that: this,
      );

  String get bodyHtml =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetBodyHtml(
        that: this,
      );

  bool get canGild =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetCanGild(
        that: this,
      );

  bool get canModPost => RustLib.instance.api
          .redditApiModelCommentCommentAutoAccessorGetCanModPost(
        that: this,
      );

  bool get collapsed =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetCollapsed(
        that: this,
      );

  int get controversiality => RustLib.instance.api
          .redditApiModelCommentCommentAutoAccessorGetControversiality(
        that: this,
      );

  DateTime get created =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetCreated(
        that: this,
      );

  DateTime get createdUtc => RustLib.instance.api
          .redditApiModelCommentCommentAutoAccessorGetCreatedUtc(
        that: this,
      );

  int get depth =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetDepth(
        that: this,
      );

  String? get distinguished => RustLib.instance.api
          .redditApiModelCommentCommentAutoAccessorGetDistinguished(
        that: this,
      );

  int get downs =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetDowns(
        that: this,
      );

  double? get edited =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetEdited(
        that: this,
      );

  int get gilded =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetGilded(
        that: this,
      );

  String get id =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetId(
        that: this,
      );

  bool get isSubmitter => RustLib.instance.api
          .redditApiModelCommentCommentAutoAccessorGetIsSubmitter(
        that: this,
      );

  bool? get likes =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetLikes(
        that: this,
      );

  String get linkId =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetLinkId(
        that: this,
      );

  bool get locked =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetLocked(
        that: this,
      );

  Fullname get name =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetName(
        that: this,
      );

  bool get noFollow =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetNoFollow(
        that: this,
      );

  String get parentId =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetParentId(
        that: this,
      );

  String get permalink =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetPermalink(
        that: this,
      );

  bool get saved =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetSaved(
        that: this,
      );

  int get score =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetScore(
        that: this,
      );

  bool get scoreHidden => RustLib.instance.api
          .redditApiModelCommentCommentAutoAccessorGetScoreHidden(
        that: this,
      );

  bool get sendReplies => RustLib.instance.api
          .redditApiModelCommentCommentAutoAccessorGetSendReplies(
        that: this,
      );

  bool get stickied =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetStickied(
        that: this,
      );

  String get subreddit =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetSubreddit(
        that: this,
      );

  String get subredditId => RustLib.instance.api
          .redditApiModelCommentCommentAutoAccessorGetSubredditId(
        that: this,
      );

  String get subredditNamePrefixed => RustLib.instance.api
          .redditApiModelCommentCommentAutoAccessorGetSubredditNamePrefixed(
        that: this,
      );

  String get subredditType => RustLib.instance.api
          .redditApiModelCommentCommentAutoAccessorGetSubredditType(
        that: this,
      );

  int get ups =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorGetUps(
        that: this,
      );

  set archived(bool archived) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetArchived(
          that: this, archived: archived);

  set author(AuthorInfo? author) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetAuthor(
          that: this, author: author);

  set body(String body) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetBody(that: this, body: body);

  set bodyHtml(String bodyHtml) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetBodyHtml(
          that: this, bodyHtml: bodyHtml);

  set canGild(bool canGild) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetCanGild(
          that: this, canGild: canGild);

  set canModPost(bool canModPost) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetCanModPost(
          that: this, canModPost: canModPost);

  set collapsed(bool collapsed) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetCollapsed(
          that: this, collapsed: collapsed);

  set controversiality(int controversiality) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetControversiality(
          that: this, controversiality: controversiality);

  set created(DateTime created) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetCreated(
          that: this, created: created);

  set createdUtc(DateTime createdUtc) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetCreatedUtc(
          that: this, createdUtc: createdUtc);

  set depth(int depth) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetDepth(
          that: this, depth: depth);

  set distinguished(String? distinguished) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetDistinguished(
          that: this, distinguished: distinguished);

  set downs(int downs) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetDowns(
          that: this, downs: downs);

  set edited(double? edited) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetEdited(
          that: this, edited: edited);

  set gilded(int gilded) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetGilded(
          that: this, gilded: gilded);

  set id(String id) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetId(that: this, id: id);

  set isSubmitter(bool isSubmitter) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetIsSubmitter(
          that: this, isSubmitter: isSubmitter);

  set likes(bool? likes) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetLikes(
          that: this, likes: likes);

  set linkId(String linkId) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetLinkId(
          that: this, linkId: linkId);

  set locked(bool locked) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetLocked(
          that: this, locked: locked);

  set name(Fullname name) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetName(that: this, name: name);

  set noFollow(bool noFollow) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetNoFollow(
          that: this, noFollow: noFollow);

  set parentId(String parentId) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetParentId(
          that: this, parentId: parentId);

  set permalink(String permalink) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetPermalink(
          that: this, permalink: permalink);

  set saved(bool saved) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetSaved(
          that: this, saved: saved);

  set score(int score) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetScore(
          that: this, score: score);

  set scoreHidden(bool scoreHidden) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetScoreHidden(
          that: this, scoreHidden: scoreHidden);

  set sendReplies(bool sendReplies) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetSendReplies(
          that: this, sendReplies: sendReplies);

  set stickied(bool stickied) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetStickied(
          that: this, stickied: stickied);

  set subreddit(String subreddit) =>
      RustLib.instance.api.redditApiModelCommentCommentAutoAccessorSetSubreddit(
          that: this, subreddit: subreddit);

  set subredditId(String subredditId) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetSubredditId(
          that: this, subredditId: subredditId);

  set subredditNamePrefixed(String subredditNamePrefixed) =>
      RustLib.instance.api
          .redditApiModelCommentCommentAutoAccessorSetSubredditNamePrefixed(
              that: this, subredditNamePrefixed: subredditNamePrefixed);

  set subredditType(String subredditType) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetSubredditType(
          that: this, subredditType: subredditType);

  set ups(int ups) => RustLib.instance.api
      .redditApiModelCommentCommentAutoAccessorSetUps(that: this, ups: ups);

  /// flutter_rust_bridge:sync
  /// If `more` is a `Thing::More`, if it exists in `Self::replies` or in the replies of one of
  /// its children, will replace it with `new_things`.
  void replaceMore({required Thing more, required List<Thing> newThings}) =>
      RustLib.instance.api.redditApiModelCommentCommentReplaceMore(
          that: this, more: more, newThings: newThings);

  /// flutter_rust_bridge:sync
  List<Thing> replies() =>
      RustLib.instance.api.redditApiModelCommentCommentReplies(
        that: this,
      );

  Future<void> save({required Client client}) => RustLib.instance.api
      .redditApiModelCommentCommentSave(that: this, client: client);

  Future<void> unsave({required Client client}) => RustLib.instance.api
      .redditApiModelCommentCommentUnsave(that: this, client: client);

  Future<void> vote(
          {required VoteDirection direction, required Client client}) =>
      RustLib.instance.api.redditApiModelCommentCommentVote(
          that: this, direction: direction, client: client);
}

@sealed
class CommonImpl extends RustOpaque implements Common {
  // Not to be used by end users
  CommonImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  CommonImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Common,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Common,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_CommonPtr,
  );

  bool get acceptFollowers => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetAcceptFollowers(
        that: this,
      );

  List<String> get allowedMediaInComments => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetAllowedMediaInComments(
        that: this,
      );

  String? get bannerImg => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetBannerImg(
        that: this,
      );

  Int64List? get bannerSize => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetBannerSize(
        that: this,
      );

  double get created =>
      RustLib.instance.api.redditApiModelSubredditCommonAutoAccessorGetCreated(
        that: this,
      );

  double get createdUtc => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetCreatedUtc(
        that: this,
      );

  bool get disableContributorRequests => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetDisableContributorRequests(
        that: this,
      );

  String get displayName => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetDisplayName(
        that: this,
      );

  String get displayNamePrefixed => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetDisplayNamePrefixed(
        that: this,
      );

  bool get freeFormReports => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetFreeFormReports(
        that: this,
      );

  String? get headerImg => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetHeaderImg(
        that: this,
      );

  Int64List? get headerSize => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetHeaderSize(
        that: this,
      );

  String? get keyColor =>
      RustLib.instance.api.redditApiModelSubredditCommonAutoAccessorGetKeyColor(
        that: this,
      );

  bool get linkFlairEnabled => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetLinkFlairEnabled(
        that: this,
      );

  String? get linkFlairPosition => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetLinkFlairPosition(
        that: this,
      );

  Fullname get name =>
      RustLib.instance.api.redditApiModelSubredditCommonAutoAccessorGetName(
        that: this,
      );

  String? get primaryColor => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetPrimaryColor(
        that: this,
      );

  String? get publicDescription => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetPublicDescription(
        that: this,
      );

  bool get quarantine => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetQuarantine(
        that: this,
      );

  bool get restrictCommenting => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetRestrictCommenting(
        that: this,
      );

  bool get restrictPosting => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetRestrictPosting(
        that: this,
      );

  bool get showMedia => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetShowMedia(
        that: this,
      );

  String? get submitLinkLabel => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetSubmitLinkLabel(
        that: this,
      );

  String? get submitTextLabel => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetSubmitTextLabel(
        that: this,
      );

  String? get subredditType => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetSubredditType(
        that: this,
      );

  PlatformInt64 get subscribers => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetSubscribers(
        that: this,
      );

  String? get title =>
      RustLib.instance.api.redditApiModelSubredditCommonAutoAccessorGetTitle(
        that: this,
      );

  String get url =>
      RustLib.instance.api.redditApiModelSubredditCommonAutoAccessorGetUrl(
        that: this,
      );

  bool get userIsBanned => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetUserIsBanned(
        that: this,
      );

  bool get userIsContributor => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetUserIsContributor(
        that: this,
      );

  bool get userIsModerator => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetUserIsModerator(
        that: this,
      );

  bool get userIsMuted => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetUserIsMuted(
        that: this,
      );

  bool get userIsSubscriber => RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorGetUserIsSubscriber(
        that: this,
      );

  set acceptFollowers(bool acceptFollowers) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetAcceptFollowers(
          that: this, acceptFollowers: acceptFollowers);

  set allowedMediaInComments(List<String> allowedMediaInComments) =>
      RustLib.instance.api
          .redditApiModelSubredditCommonAutoAccessorSetAllowedMediaInComments(
              that: this, allowedMediaInComments: allowedMediaInComments);

  set bannerImg(String? bannerImg) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetBannerImg(
          that: this, bannerImg: bannerImg);

  set bannerSize(Int64List? bannerSize) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetBannerSize(
          that: this, bannerSize: bannerSize);

  set created(double created) =>
      RustLib.instance.api.redditApiModelSubredditCommonAutoAccessorSetCreated(
          that: this, created: created);

  set createdUtc(double createdUtc) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetCreatedUtc(
          that: this, createdUtc: createdUtc);

  set disableContributorRequests(bool disableContributorRequests) => RustLib
      .instance.api
      .redditApiModelSubredditCommonAutoAccessorSetDisableContributorRequests(
          that: this, disableContributorRequests: disableContributorRequests);

  set displayName(String displayName) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetDisplayName(
          that: this, displayName: displayName);

  set displayNamePrefixed(String displayNamePrefixed) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetDisplayNamePrefixed(
          that: this, displayNamePrefixed: displayNamePrefixed);

  set freeFormReports(bool freeFormReports) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetFreeFormReports(
          that: this, freeFormReports: freeFormReports);

  set headerImg(String? headerImg) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetHeaderImg(
          that: this, headerImg: headerImg);

  set headerSize(Int64List? headerSize) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetHeaderSize(
          that: this, headerSize: headerSize);

  set keyColor(String? keyColor) =>
      RustLib.instance.api.redditApiModelSubredditCommonAutoAccessorSetKeyColor(
          that: this, keyColor: keyColor);

  set linkFlairEnabled(bool linkFlairEnabled) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetLinkFlairEnabled(
          that: this, linkFlairEnabled: linkFlairEnabled);

  set linkFlairPosition(String? linkFlairPosition) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetLinkFlairPosition(
          that: this, linkFlairPosition: linkFlairPosition);

  set name(Fullname name) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetName(that: this, name: name);

  set primaryColor(String? primaryColor) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetPrimaryColor(
          that: this, primaryColor: primaryColor);

  set publicDescription(String? publicDescription) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetPublicDescription(
          that: this, publicDescription: publicDescription);

  set quarantine(bool quarantine) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetQuarantine(
          that: this, quarantine: quarantine);

  set restrictCommenting(bool restrictCommenting) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetRestrictCommenting(
          that: this, restrictCommenting: restrictCommenting);

  set restrictPosting(bool restrictPosting) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetRestrictPosting(
          that: this, restrictPosting: restrictPosting);

  set showMedia(bool showMedia) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetShowMedia(
          that: this, showMedia: showMedia);

  set submitLinkLabel(String? submitLinkLabel) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetSubmitLinkLabel(
          that: this, submitLinkLabel: submitLinkLabel);

  set submitTextLabel(String? submitTextLabel) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetSubmitTextLabel(
          that: this, submitTextLabel: submitTextLabel);

  set subredditType(String? subredditType) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetSubredditType(
          that: this, subredditType: subredditType);

  set subscribers(PlatformInt64 subscribers) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetSubscribers(
          that: this, subscribers: subscribers);

  set title(String? title) =>
      RustLib.instance.api.redditApiModelSubredditCommonAutoAccessorSetTitle(
          that: this, title: title);

  set url(String url) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetUrl(that: this, url: url);

  set userIsBanned(bool userIsBanned) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetUserIsBanned(
          that: this, userIsBanned: userIsBanned);

  set userIsContributor(bool userIsContributor) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetUserIsContributor(
          that: this, userIsContributor: userIsContributor);

  set userIsModerator(bool userIsModerator) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetUserIsModerator(
          that: this, userIsModerator: userIsModerator);

  set userIsMuted(bool userIsMuted) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetUserIsMuted(
          that: this, userIsMuted: userIsMuted);

  set userIsSubscriber(bool userIsSubscriber) => RustLib.instance.api
      .redditApiModelSubredditCommonAutoAccessorSetUserIsSubscriber(
          that: this, userIsSubscriber: userIsSubscriber);

  /// flutter_rust_bridge:getter,sync
  SubredditIcon get icon =>
      RustLib.instance.api.redditApiModelSubredditCommonIcon(
        that: this,
      );
}

@sealed
class DetailsImpl extends RustOpaque implements Details {
  // Not to be used by end users
  DetailsImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  DetailsImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Details,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Details,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_DetailsPtr,
  );

  bool get defaultSet => RustLib.instance.api
          .redditApiModelSubredditDetailsAutoAccessorGetDefaultSet(
        that: this,
      );

  String? get description => RustLib.instance.api
          .redditApiModelSubredditDetailsAutoAccessorGetDescription(
        that: this,
      );

  String? get iconColor => RustLib.instance.api
          .redditApiModelSubredditDetailsAutoAccessorGetIconColor(
        that: this,
      );

  Common get other =>
      RustLib.instance.api.redditApiModelSubredditDetailsAutoAccessorGetOther(
        that: this,
      );

  bool get over18 =>
      RustLib.instance.api.redditApiModelSubredditDetailsAutoAccessorGetOver18(
        that: this,
      );

  List<String> get previousNames => RustLib.instance.api
          .redditApiModelSubredditDetailsAutoAccessorGetPreviousNames(
        that: this,
      );

  set defaultSet(bool defaultSet) => RustLib.instance.api
      .redditApiModelSubredditDetailsAutoAccessorSetDefaultSet(
          that: this, defaultSet: defaultSet);

  set description(String? description) => RustLib.instance.api
      .redditApiModelSubredditDetailsAutoAccessorSetDescription(
          that: this, description: description);

  set iconColor(String? iconColor) => RustLib.instance.api
      .redditApiModelSubredditDetailsAutoAccessorSetIconColor(
          that: this, iconColor: iconColor);

  set other(Common other) =>
      RustLib.instance.api.redditApiModelSubredditDetailsAutoAccessorSetOther(
          that: this, other: other);

  set over18(bool over18) =>
      RustLib.instance.api.redditApiModelSubredditDetailsAutoAccessorSetOver18(
          that: this, over18: over18);

  set previousNames(List<String> previousNames) => RustLib.instance.api
      .redditApiModelSubredditDetailsAutoAccessorSetPreviousNames(
          that: this, previousNames: previousNames);

  /// flutter_rust_bridge:getter,sync
  SubredditIcon get icon =>
      RustLib.instance.api.redditApiModelSubredditDetailsIcon(
        that: this,
      );
}

@sealed
class FeedStreamImpl extends RustOpaque implements FeedStream {
  // Not to be used by end users
  FeedStreamImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  FeedStreamImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_FeedStream,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_FeedStream,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_FeedStreamPtr,
  );
}

@sealed
class FullnameImpl extends RustOpaque implements Fullname {
  // Not to be used by end users
  FullnameImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  FullnameImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Fullname,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Fullname,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_FullnamePtr,
  );
}

@sealed
class GalleryDataImpl extends RustOpaque implements GalleryData {
  // Not to be used by end users
  GalleryDataImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  GalleryDataImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_GalleryData,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_GalleryData,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_GalleryDataPtr,
  );
}

@sealed
class GalleryImpl extends RustOpaque implements Gallery {
  // Not to be used by end users
  GalleryImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  GalleryImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Gallery,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Gallery,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_GalleryPtr,
  );

  /// flutter_rust_bridge:sync
  Source get_({required int index}) => RustLib.instance.api
      .redditApiModelGalleryGalleryGet(that: this, index: index);

  /// flutter_rust_bridge:sync,getter
  double get aspectRatio =>
      RustLib.instance.api.redditApiModelGalleryGalleryGetAspectRatio(
        that: this,
      );

  /// flutter_rust_bridge:sync,getter
  int get length => RustLib.instance.api.redditApiModelGalleryGalleryGetLength(
        that: this,
      );
}

@sealed
class GalleryMediaImpl extends RustOpaque implements GalleryMedia {
  // Not to be used by end users
  GalleryMediaImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  GalleryMediaImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_GalleryMedia,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_GalleryMedia,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_GalleryMediaPtr,
  );

  String get mediaType => RustLib.instance.api
          .redditApiModelGalleryGalleryMediaAutoAccessorGetMediaType(
        that: this,
      );

  set mediaType(String mediaType) => RustLib.instance.api
      .redditApiModelGalleryGalleryMediaAutoAccessorSetMediaType(
          that: this, mediaType: mediaType);
}

@sealed
class ListingImpl extends RustOpaque implements Listing {
  // Not to be used by end users
  ListingImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ListingImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Listing,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Listing,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ListingPtr,
  );

  String? get after =>
      RustLib.instance.api.redditApiModelListingAutoAccessorGetAfter(
        that: this,
      );

  String? get before =>
      RustLib.instance.api.redditApiModelListingAutoAccessorGetBefore(
        that: this,
      );

  List<Thing> get children =>
      RustLib.instance.api.redditApiModelListingAutoAccessorGetChildren(
        that: this,
      );

  int? get dist =>
      RustLib.instance.api.redditApiModelListingAutoAccessorGetDist(
        that: this,
      );

  String? get modhash =>
      RustLib.instance.api.redditApiModelListingAutoAccessorGetModhash(
        that: this,
      );

  set after(String? after) => RustLib.instance.api
      .redditApiModelListingAutoAccessorSetAfter(that: this, after: after);

  set before(String? before) => RustLib.instance.api
      .redditApiModelListingAutoAccessorSetBefore(that: this, before: before);

  set children(List<Thing> children) =>
      RustLib.instance.api.redditApiModelListingAutoAccessorSetChildren(
          that: this, children: children);

  set dist(int? dist) => RustLib.instance.api
      .redditApiModelListingAutoAccessorSetDist(that: this, dist: dist);

  set modhash(String? modhash) =>
      RustLib.instance.api.redditApiModelListingAutoAccessorSetModhash(
          that: this, modhash: modhash);
}

@sealed
class MultiImpl extends RustOpaque implements Multi {
  // Not to be used by end users
  MultiImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MultiImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Multi,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Multi,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_MultiPtr,
  );

  bool get canEdit =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetCanEdit(
        that: this,
      );

  String? get copiedFrom =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetCopiedFrom(
        that: this,
      );

  double get created =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetCreated(
        that: this,
      );

  double get createdUtc =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetCreatedUtc(
        that: this,
      );

  String get descriptionHtml => RustLib.instance.api
          .redditApiModelMultiMultiAutoAccessorGetDescriptionHtml(
        that: this,
      );

  String get descriptionMd =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetDescriptionMd(
        that: this,
      );

  String get displayName =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetDisplayName(
        that: this,
      );

  String get iconUrl =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetIconUrl(
        that: this,
      );

  bool get isFavorited =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetIsFavorited(
        that: this,
      );

  bool get isSubscriber =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetIsSubscriber(
        that: this,
      );

  String? get keyColor =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetKeyColor(
        that: this,
      );

  Fullname get name =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetName(
        that: this,
      );

  PlatformInt64 get numSubscribers => RustLib.instance.api
          .redditApiModelMultiMultiAutoAccessorGetNumSubscribers(
        that: this,
      );

  bool get over18 =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetOver18(
        that: this,
      );

  String get owner =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetOwner(
        that: this,
      );

  String get ownerId =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetOwnerId(
        that: this,
      );

  String get path =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetPath(
        that: this,
      );

  List<SubredditDetails> get subreddits =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetSubreddits(
        that: this,
      );

  String get visibility =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorGetVisibility(
        that: this,
      );

  set canEdit(bool canEdit) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetCanEdit(
          that: this, canEdit: canEdit);

  set copiedFrom(String? copiedFrom) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetCopiedFrom(
          that: this, copiedFrom: copiedFrom);

  set created(double created) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetCreated(
          that: this, created: created);

  set createdUtc(double createdUtc) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetCreatedUtc(
          that: this, createdUtc: createdUtc);

  set descriptionHtml(String descriptionHtml) => RustLib.instance.api
      .redditApiModelMultiMultiAutoAccessorSetDescriptionHtml(
          that: this, descriptionHtml: descriptionHtml);

  set descriptionMd(String descriptionMd) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetDescriptionMd(
          that: this, descriptionMd: descriptionMd);

  set displayName(String displayName) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetDisplayName(
          that: this, displayName: displayName);

  set iconUrl(String iconUrl) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetIconUrl(
          that: this, iconUrl: iconUrl);

  set isFavorited(bool isFavorited) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetIsFavorited(
          that: this, isFavorited: isFavorited);

  set isSubscriber(bool isSubscriber) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetIsSubscriber(
          that: this, isSubscriber: isSubscriber);

  set keyColor(String? keyColor) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetKeyColor(
          that: this, keyColor: keyColor);

  set name(Fullname name) => RustLib.instance.api
      .redditApiModelMultiMultiAutoAccessorSetName(that: this, name: name);

  set numSubscribers(PlatformInt64 numSubscribers) => RustLib.instance.api
      .redditApiModelMultiMultiAutoAccessorSetNumSubscribers(
          that: this, numSubscribers: numSubscribers);

  set over18(bool over18) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetOver18(
          that: this, over18: over18);

  set owner(String owner) => RustLib.instance.api
      .redditApiModelMultiMultiAutoAccessorSetOwner(that: this, owner: owner);

  set ownerId(String ownerId) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetOwnerId(
          that: this, ownerId: ownerId);

  set path(String path) => RustLib.instance.api
      .redditApiModelMultiMultiAutoAccessorSetPath(that: this, path: path);

  set subreddits(List<SubredditDetails> subreddits) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetSubreddits(
          that: this, subreddits: subreddits);

  set visibility(String visibility) =>
      RustLib.instance.api.redditApiModelMultiMultiAutoAccessorSetVisibility(
          that: this, visibility: visibility);
}

@sealed
class MultiStreamImpl extends RustOpaque implements MultiStream {
  // Not to be used by end users
  MultiStreamImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MultiStreamImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_MultiStream,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_MultiStream,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_MultiStreamPtr,
  );
}

@sealed
class PagerImpl extends RustOpaque implements Pager {
  // Not to be used by end users
  PagerImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PagerImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Pager,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Pager,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PagerPtr,
  );

  Future<Url> addToUrl({required Url url}) =>
      RustLib.instance.api.redditApiClientPagerAddToUrl(that: this, url: url);

  Future<void> after({String? after}) =>
      RustLib.instance.api.redditApiClientPagerAfter(that: this, after: after);

  Future<void> before({String? before}) => RustLib.instance.api
      .redditApiClientPagerBefore(that: this, before: before);
}

@sealed
class PostIdImpl extends RustOpaque implements PostId {
  // Not to be used by end users
  PostIdImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PostIdImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_PostId,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_PostId,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PostIdPtr,
  );
}

@sealed
class PostImpl extends RustOpaque implements Post {
  // Not to be used by end users
  PostImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PostImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Post,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Post,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PostPtr,
  );

  Future<List<String?>> getAllAwardings() =>
      RustLib.instance.api.redditApiModelPostPostGetAllAwardings(
        that: this,
      );

  Future<bool> getAllowLiveComments() =>
      RustLib.instance.api.redditApiModelPostPostGetAllowLiveComments(
        that: this,
      );

  Future<double?> getApprovedAtUtc() =>
      RustLib.instance.api.redditApiModelPostPostGetApprovedAtUtc(
        that: this,
      );

  Future<String?> getApprovedBy() =>
      RustLib.instance.api.redditApiModelPostPostGetApprovedBy(
        that: this,
      );

  Future<bool> getArchived() =>
      RustLib.instance.api.redditApiModelPostPostGetArchived(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  AuthorInfo? get author =>
      RustLib.instance.api.redditApiModelPostPostGetAuthor(
        that: this,
      );

  Future<List<String?>> getAwarders() =>
      RustLib.instance.api.redditApiModelPostPostGetAwarders(
        that: this,
      );

  Future<double?> getBannedAtUtc() =>
      RustLib.instance.api.redditApiModelPostPostGetBannedAtUtc(
        that: this,
      );

  Future<bool> getCanGild() =>
      RustLib.instance.api.redditApiModelPostPostGetCanGild(
        that: this,
      );

  Future<bool> getCanModPost() =>
      RustLib.instance.api.redditApiModelPostPostGetCanModPost(
        that: this,
      );

  Future<String?> getCategory() =>
      RustLib.instance.api.redditApiModelPostPostGetCategory(
        that: this,
      );

  Future<bool> getClicked() =>
      RustLib.instance.api.redditApiModelPostPostGetClicked(
        that: this,
      );

  Future<List<String>> getContentCategories() =>
      RustLib.instance.api.redditApiModelPostPostGetContentCategories(
        that: this,
      );

  Future<bool> getContestMode() =>
      RustLib.instance.api.redditApiModelPostPostGetContestMode(
        that: this,
      );

  /// Date of creation in logged in user locale
  Future<DateTime> getCreated() =>
      RustLib.instance.api.redditApiModelPostPostGetCreated(
        that: this,
      );

  /// Date of creation in UTC
  /// flutter_rust_bridge:getter,sync
  DateTime get createdUtc =>
      RustLib.instance.api.redditApiModelPostPostGetCreatedUtc(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  List<Post> get crosspostParentList =>
      RustLib.instance.api.redditApiModelPostPostGetCrosspostParentList(
        that: this,
      );

  Future<String?> getDiscussionType() =>
      RustLib.instance.api.redditApiModelPostPostGetDiscussionType(
        that: this,
      );

  Future<String?> getDistinguished() =>
      RustLib.instance.api.redditApiModelPostPostGetDistinguished(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  String get domain => RustLib.instance.api.redditApiModelPostPostGetDomain(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  int get downs => RustLib.instance.api.redditApiModelPostPostGetDowns(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  double? get edited => RustLib.instance.api.redditApiModelPostPostGetEdited(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  Gallery? get gallery => RustLib.instance.api.redditApiModelPostPostGetGallery(
        that: this,
      );

  Future<int> getGilded() =>
      RustLib.instance.api.redditApiModelPostPostGetGilded(
        that: this,
      );

  Future<Gildings> getGildings() =>
      RustLib.instance.api.redditApiModelPostPostGetGildings(
        that: this,
      );

  Future<bool> getHidden() =>
      RustLib.instance.api.redditApiModelPostPostGetHidden(
        that: this,
      );

  Future<bool> getHideScore() =>
      RustLib.instance.api.redditApiModelPostPostGetHideScore(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  PostId get id => RustLib.instance.api.redditApiModelPostPostGetId(
        that: this,
      );

  Future<bool> getIsCreatedFromAdsUi() =>
      RustLib.instance.api.redditApiModelPostPostGetIsCreatedFromAdsUi(
        that: this,
      );

  Future<bool> getIsCrosspostable() =>
      RustLib.instance.api.redditApiModelPostPostGetIsCrosspostable(
        that: this,
      );

  Future<bool> getIsGallery() =>
      RustLib.instance.api.redditApiModelPostPostGetIsGallery(
        that: this,
      );

  Future<bool> getIsMeta() =>
      RustLib.instance.api.redditApiModelPostPostGetIsMeta(
        that: this,
      );

  Future<bool> getIsOriginalContent() =>
      RustLib.instance.api.redditApiModelPostPostGetIsOriginalContent(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  bool get isRedditMediaDomain =>
      RustLib.instance.api.redditApiModelPostPostGetIsRedditMediaDomain(
        that: this,
      );

  Future<bool> getIsRobotIndexable() =>
      RustLib.instance.api.redditApiModelPostPostGetIsRobotIndexable(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  bool get isSelf => RustLib.instance.api.redditApiModelPostPostGetIsSelf(
        that: this,
      );

  Future<bool> getIsVideo() =>
      RustLib.instance.api.redditApiModelPostPostGetIsVideo(
        that: this,
      );

  /// Some(true) if upvoted, Some(false) if downvoted, None otherwise
  /// flutter_rust_bridge:getter,sync
  bool? get likes => RustLib.instance.api.redditApiModelPostPostGetLikes(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  Flair get linkFlair =>
      RustLib.instance.api.redditApiModelPostPostGetLinkFlair(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  bool get locked => RustLib.instance.api.redditApiModelPostPostGetLocked(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  Media? get media => RustLib.instance.api.redditApiModelPostPostGetMedia(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  MediaEmbed? get mediaEmbed =>
      RustLib.instance.api.redditApiModelPostPostGetMediaEmbed(
        that: this,
      );

  Future<bool> getMediaOnly() =>
      RustLib.instance.api.redditApiModelPostPostGetMediaOnly(
        that: this,
      );

  Future<String?> getModNote() =>
      RustLib.instance.api.redditApiModelPostPostGetModNote(
        that: this,
      );

  Future<String?> getModReasonBy() =>
      RustLib.instance.api.redditApiModelPostPostGetModReasonBy(
        that: this,
      );

  Future<String?> getModReasonTitle() =>
      RustLib.instance.api.redditApiModelPostPostGetModReasonTitle(
        that: this,
      );

  Future<List<String?>> getModReports() =>
      RustLib.instance.api.redditApiModelPostPostGetModReports(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  Fullname get name => RustLib.instance.api.redditApiModelPostPostGetName(
        that: this,
      );

  Future<bool> getNoFollow() =>
      RustLib.instance.api.redditApiModelPostPostGetNoFollow(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  int get numComments =>
      RustLib.instance.api.redditApiModelPostPostGetNumComments(
        that: this,
      );

  Future<int?> getNumCrossposts() =>
      RustLib.instance.api.redditApiModelPostPostGetNumCrossposts(
        that: this,
      );

  Future<int?> getNumDuplicates() =>
      RustLib.instance.api.redditApiModelPostPostGetNumDuplicates(
        that: this,
      );

  Future<int?> getNumReports() =>
      RustLib.instance.api.redditApiModelPostPostGetNumReports(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  bool get over18 => RustLib.instance.api.redditApiModelPostPostGetOver18(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  String get permalink =>
      RustLib.instance.api.redditApiModelPostPostGetPermalink(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  bool get pinned => RustLib.instance.api.redditApiModelPostPostGetPinned(
        that: this,
      );

  Future<String?> getPostHint() =>
      RustLib.instance.api.redditApiModelPostPostGetPostHint(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  Preview? get preview => RustLib.instance.api.redditApiModelPostPostGetPreview(
        that: this,
      );

  Future<int?> getPwls() => RustLib.instance.api.redditApiModelPostPostGetPwls(
        that: this,
      );

  Future<bool> getQuarantine() =>
      RustLib.instance.api.redditApiModelPostPostGetQuarantine(
        that: this,
      );

  Future<String?> getRemovalReason() =>
      RustLib.instance.api.redditApiModelPostPostGetRemovalReason(
        that: this,
      );

  Future<String?> getRemovedBy() =>
      RustLib.instance.api.redditApiModelPostPostGetRemovedBy(
        that: this,
      );

  Future<String?> getRemovedByCategory() =>
      RustLib.instance.api.redditApiModelPostPostGetRemovedByCategory(
        that: this,
      );

  Future<List<String>> getReportReasons() =>
      RustLib.instance.api.redditApiModelPostPostGetReportReasons(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  bool get saved => RustLib.instance.api.redditApiModelPostPostGetSaved(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  int get score => RustLib.instance.api.redditApiModelPostPostGetScore(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  Media? get secureMedia =>
      RustLib.instance.api.redditApiModelPostPostGetSecureMedia(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  SecureMediaEmbed? get secureMediaEmbed =>
      RustLib.instance.api.redditApiModelPostPostGetSecureMediaEmbed(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  String? get selftext =>
      RustLib.instance.api.redditApiModelPostPostGetSelftext(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  String? get selftextHtml =>
      RustLib.instance.api.redditApiModelPostPostGetSelftextHtml(
        that: this,
      );

  Future<bool> getSendReplies() =>
      RustLib.instance.api.redditApiModelPostPostGetSendReplies(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  bool get spoiler => RustLib.instance.api.redditApiModelPostPostGetSpoiler(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  bool get stickied => RustLib.instance.api.redditApiModelPostPostGetStickied(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  SubredditInfo get subreddit =>
      RustLib.instance.api.redditApiModelPostPostGetSubreddit(
        that: this,
      );

  /// Suggested sort for comments
  /// flutter_rust_bridge:getter,sync
  CommentSort? get suggestedSort =>
      RustLib.instance.api.redditApiModelPostPostGetSuggestedSort(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  String get title => RustLib.instance.api.redditApiModelPostPostGetTitle(
        that: this,
      );

  Future<String?> getTopAwardedType() =>
      RustLib.instance.api.redditApiModelPostPostGetTopAwardedType(
        that: this,
      );

  Future<int?> getTotalAwardsReceived() =>
      RustLib.instance.api.redditApiModelPostPostGetTotalAwardsReceived(
        that: this,
      );

  Future<List<String?>> getTreatmentTags() =>
      RustLib.instance.api.redditApiModelPostPostGetTreatmentTags(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  int get ups => RustLib.instance.api.redditApiModelPostPostGetUps(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  double get upvoteRatio =>
      RustLib.instance.api.redditApiModelPostPostGetUpvoteRatio(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  String get url => RustLib.instance.api.redditApiModelPostPostGetUrl(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  String? get urlOverriddenByDest =>
      RustLib.instance.api.redditApiModelPostPostGetUrlOverriddenByDest(
        that: this,
      );

  Future<List<String?>> getUserReports() =>
      RustLib.instance.api.redditApiModelPostPostGetUserReports(
        that: this,
      );

  Future<String?> getViewCount() =>
      RustLib.instance.api.redditApiModelPostPostGetViewCount(
        that: this,
      );

  Future<bool> getVisited() =>
      RustLib.instance.api.redditApiModelPostPostGetVisited(
        that: this,
      );

  Future<int?> getWls() => RustLib.instance.api.redditApiModelPostPostGetWls(
        that: this,
      );

  ///flutter_rust_bridge:sync,getter
  bool get isCrosspost =>
      RustLib.instance.api.redditApiModelPostPostIsCrosspost(
        that: this,
      );

  Kind get kind => RustLib.instance.api.redditApiModelPostPostKind(
        that: this,
      );

  Future<void> save({required Client client}) => RustLib.instance.api
      .redditApiModelPostPostSave(that: this, client: client);

  Thumbnail? get thumbnail =>
      RustLib.instance.api.redditApiModelPostPostThumbnail(
        that: this,
      );

  Future<void> unsave({required Client client}) => RustLib.instance.api
      .redditApiModelPostPostUnsave(that: this, client: client);

  Future<void> vote(
          {required VoteDirection direction, required Client client}) =>
      RustLib.instance.api.redditApiModelPostPostVote(
          that: this, direction: direction, client: client);
}

@sealed
class SearchPostImpl extends RustOpaque implements SearchPost {
  // Not to be used by end users
  SearchPostImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SearchPostImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SearchPost,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SearchPost,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SearchPostPtr,
  );
}

@sealed
class SearchSubredditImpl extends RustOpaque implements SearchSubreddit {
  // Not to be used by end users
  SearchSubredditImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SearchSubredditImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SearchSubreddit,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SearchSubreddit,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SearchSubredditPtr,
  );
}

@sealed
class StreamableImpl extends RustOpaque implements Streamable {
  // Not to be used by end users
  StreamableImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  StreamableImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Streamable,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Streamable,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_StreamablePtr,
  );

  /// flutter_rust_bridge:sync
  List<Thing> getAll() =>
      RustLib.instance.api.redditApiStreamableStreamableGetAll(
        that: this,
      );

  /// flutter_rust_bridge:getter,sync
  int get length => RustLib.instance.api.redditApiStreamableStreamableGetLength(
        that: this,
      );

  /// Returns true if there are still elements remaining.
  /// flutter_rust_bridge:
  Future<bool> next() => RustLib.instance.api.redditApiStreamableStreamableNext(
        that: this,
      );

  /// flutter_rust_bridge:sync
  Thing? nth({required int n}) =>
      RustLib.instance.api.redditApiStreamableStreamableNth(that: this, n: n);

  Future<void> refresh() =>
      RustLib.instance.api.redditApiStreamableStreamableRefresh(
        that: this,
      );

  Future<void> save(
          {required Fullname name,
          required bool save,
          required Client client}) =>
      RustLib.instance.api.redditApiStreamableStreamableSave(
          that: this, name: name, save: save, client: client);

  Future<void> vote(
          {required Fullname name,
          required VoteDirection direction,
          required Client client}) =>
      RustLib.instance.api.redditApiStreamableStreamableVote(
          that: this, name: name, direction: direction, client: client);
}

@sealed
class SubredditIdImpl extends RustOpaque implements SubredditId {
  // Not to be used by end users
  SubredditIdImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SubredditIdImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SubredditId,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubredditId,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubredditIdPtr,
  );
}

@sealed
class SubredditImpl extends RustOpaque implements Subreddit {
  // Not to be used by end users
  SubredditImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SubredditImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Subreddit,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Subreddit,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubredditPtr,
  );

  int? get accountsActive => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAccountsActive(
        that: this,
      );

  bool get accountsActiveIsFuzzed => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAccountsActiveIsFuzzed(
        that: this,
      );

  int get activeUserCount => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetActiveUserCount(
        that: this,
      );

  String? get advertiserCategory => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAdvertiserCategory(
        that: this,
      );

  bool get allOriginalContent => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllOriginalContent(
        that: this,
      );

  bool get allowDiscovery => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowDiscovery(
        that: this,
      );

  bool get allowGalleries => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowGalleries(
        that: this,
      );

  bool get allowImages => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowImages(
        that: this,
      );

  bool get allowPolls => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowPolls(
        that: this,
      );

  bool get allowPredictionContributors => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowPredictionContributors(
        that: this,
      );

  bool get allowPredictions => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowPredictions(
        that: this,
      );

  bool get allowPredictionsTournament => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsTournament(
        that: this,
      );

  bool get allowTalks => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowTalks(
        that: this,
      );

  bool get allowVideogifs => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowVideogifs(
        that: this,
      );

  bool get allowVideos => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowVideos(
        that: this,
      );

  String? get bannerBackgroundColor => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundColor(
        that: this,
      );

  String? get bannerBackgroundImage => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundImage(
        that: this,
      );

  bool get canAssignLinkFlair => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCanAssignLinkFlair(
        that: this,
      );

  bool get canAssignUserFlair => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCanAssignUserFlair(
        that: this,
      );

  bool get collapseDeletedComments => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCollapseDeletedComments(
        that: this,
      );

  CommentContributionSettings get commentContributionSettings =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCommentContributionSettings(
        that: this,
      );

  PlatformInt64? get commentScoreHideMins => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCommentScoreHideMins(
        that: this,
      );

  bool get communityReviewed => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCommunityReviewed(
        that: this,
      );

  String? get description => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetDescription(
        that: this,
      );

  String? get descriptionHtml => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetDescriptionHtml(
        that: this,
      );

  Int64List? get emojisCustomSize => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetEmojisCustomSize(
        that: this,
      );

  bool get emojisEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetEmojisEnabled(
        that: this,
      );

  bool get hasMenuWidget => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetHasMenuWidget(
        that: this,
      );

  String? get headerTitle => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetHeaderTitle(
        that: this,
      );

  bool get hideAds => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetHideAds(
        that: this,
      );

  String get id =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorGetId(
        that: this,
      );

  bool? get isCrosspostableSubreddit => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetIsCrosspostableSubreddit(
        that: this,
      );

  bool? get isEnrolledInNewModmail => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetIsEnrolledInNewModmail(
        that: this,
      );

  String? get lang =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorGetLang(
        that: this,
      );

  String? get mobileBannerImage => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetMobileBannerImage(
        that: this,
      );

  String? get notificationLevel => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetNotificationLevel(
        that: this,
      );

  bool get originalContentTagEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetOriginalContentTagEnabled(
        that: this,
      );

  Common get other =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorGetOther(
        that: this,
      );

  bool get over18 => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetOver18(
        that: this,
      );

  PlatformInt64 get predictionLeaderboardEntryType => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetPredictionLeaderboardEntryType(
        that: this,
      );

  String? get publicDescriptionHtml => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetPublicDescriptionHtml(
        that: this,
      );

  bool get publicTraffic => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetPublicTraffic(
        that: this,
      );

  bool get shouldArchivePosts => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetShouldArchivePosts(
        that: this,
      );

  bool get shouldShowMediaInCommentsSetting => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetShouldShowMediaInCommentsSetting(
        that: this,
      );

  bool get showMediaPreview => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetShowMediaPreview(
        that: this,
      );

  bool get spoilersEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSpoilersEnabled(
        that: this,
      );

  String? get submissionType => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSubmissionType(
        that: this,
      );

  String? get submitText => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSubmitText(
        that: this,
      );

  String? get submitTextHtml => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSubmitTextHtml(
        that: this,
      );

  String? get suggestedCommentSort => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSuggestedCommentSort(
        that: this,
      );

  bool? get userCanFlairInSr => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserCanFlairInSr(
        that: this,
      );

  Flair get userFlair => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserFlair(
        that: this,
      );

  bool get userFlairEnabledInSr => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserFlairEnabledInSr(
        that: this,
      );

  bool get userHasFavorited => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserHasFavorited(
        that: this,
      );

  bool? get userSrFlairEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserSrFlairEnabled(
        that: this,
      );

  bool get userSrThemeEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserSrThemeEnabled(
        that: this,
      );

  bool? get wikiEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetWikiEnabled(
        that: this,
      );

  int? get wls =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorGetWls(
        that: this,
      );

  set accountsActive(int? accountsActive) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAccountsActive(
          that: this, accountsActive: accountsActive);

  set accountsActiveIsFuzzed(bool accountsActiveIsFuzzed) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAccountsActiveIsFuzzed(
          that: this, accountsActiveIsFuzzed: accountsActiveIsFuzzed);

  set activeUserCount(int activeUserCount) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetActiveUserCount(
          that: this, activeUserCount: activeUserCount);

  set advertiserCategory(String? advertiserCategory) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAdvertiserCategory(
          that: this, advertiserCategory: advertiserCategory);

  set allOriginalContent(bool allOriginalContent) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllOriginalContent(
          that: this, allOriginalContent: allOriginalContent);

  set allowDiscovery(bool allowDiscovery) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowDiscovery(
          that: this, allowDiscovery: allowDiscovery);

  set allowGalleries(bool allowGalleries) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowGalleries(
          that: this, allowGalleries: allowGalleries);

  set allowImages(bool allowImages) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowImages(
          that: this, allowImages: allowImages);

  set allowPolls(bool allowPolls) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowPolls(
          that: this, allowPolls: allowPolls);

  set allowPredictionContributors(bool allowPredictionContributors) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowPredictionContributors(
          that: this, allowPredictionContributors: allowPredictionContributors);

  set allowPredictions(bool allowPredictions) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowPredictions(
          that: this, allowPredictions: allowPredictions);

  set allowPredictionsTournament(bool allowPredictionsTournament) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsTournament(
          that: this, allowPredictionsTournament: allowPredictionsTournament);

  set allowTalks(bool allowTalks) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowTalks(
          that: this, allowTalks: allowTalks);

  set allowVideogifs(bool allowVideogifs) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowVideogifs(
          that: this, allowVideogifs: allowVideogifs);

  set allowVideos(bool allowVideos) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowVideos(
          that: this, allowVideos: allowVideos);

  set bannerBackgroundColor(String? bannerBackgroundColor) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundColor(
              that: this, bannerBackgroundColor: bannerBackgroundColor);

  set bannerBackgroundImage(String? bannerBackgroundImage) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundImage(
              that: this, bannerBackgroundImage: bannerBackgroundImage);

  set canAssignLinkFlair(bool canAssignLinkFlair) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetCanAssignLinkFlair(
          that: this, canAssignLinkFlair: canAssignLinkFlair);

  set canAssignUserFlair(bool canAssignUserFlair) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetCanAssignUserFlair(
          that: this, canAssignUserFlair: canAssignUserFlair);

  set collapseDeletedComments(bool collapseDeletedComments) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetCollapseDeletedComments(
          that: this, collapseDeletedComments: collapseDeletedComments);

  set commentContributionSettings(
          CommentContributionSettings commentContributionSettings) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetCommentContributionSettings(
              that: this,
              commentContributionSettings: commentContributionSettings);

  set commentScoreHideMins(PlatformInt64? commentScoreHideMins) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetCommentScoreHideMins(
              that: this, commentScoreHideMins: commentScoreHideMins);

  set communityReviewed(bool communityReviewed) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetCommunityReviewed(
          that: this, communityReviewed: communityReviewed);

  set description(String? description) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetDescription(
          that: this, description: description);

  set descriptionHtml(String? descriptionHtml) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetDescriptionHtml(
          that: this, descriptionHtml: descriptionHtml);

  set emojisCustomSize(Int64List? emojisCustomSize) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetEmojisCustomSize(
          that: this, emojisCustomSize: emojisCustomSize);

  set emojisEnabled(bool emojisEnabled) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetEmojisEnabled(
          that: this, emojisEnabled: emojisEnabled);

  set hasMenuWidget(bool hasMenuWidget) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetHasMenuWidget(
          that: this, hasMenuWidget: hasMenuWidget);

  set headerTitle(String? headerTitle) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetHeaderTitle(
          that: this, headerTitle: headerTitle);

  set hideAds(bool hideAds) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetHideAds(
          that: this, hideAds: hideAds);

  set id(String id) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetId(that: this, id: id);

  set isCrosspostableSubreddit(bool? isCrosspostableSubreddit) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetIsCrosspostableSubreddit(
          that: this, isCrosspostableSubreddit: isCrosspostableSubreddit);

  set isEnrolledInNewModmail(bool? isEnrolledInNewModmail) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetIsEnrolledInNewModmail(
          that: this, isEnrolledInNewModmail: isEnrolledInNewModmail);

  set lang(String? lang) =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorSetLang(
          that: this, lang: lang);

  set mobileBannerImage(String? mobileBannerImage) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetMobileBannerImage(
          that: this, mobileBannerImage: mobileBannerImage);

  set notificationLevel(String? notificationLevel) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetNotificationLevel(
          that: this, notificationLevel: notificationLevel);

  set originalContentTagEnabled(bool originalContentTagEnabled) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetOriginalContentTagEnabled(
          that: this, originalContentTagEnabled: originalContentTagEnabled);

  set other(Common other) =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorSetOther(
          that: this, other: other);

  set over18(bool over18) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetOver18(
          that: this, over18: over18);

  set predictionLeaderboardEntryType(
          PlatformInt64 predictionLeaderboardEntryType) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetPredictionLeaderboardEntryType(
              that: this,
              predictionLeaderboardEntryType: predictionLeaderboardEntryType);

  set publicDescriptionHtml(String? publicDescriptionHtml) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetPublicDescriptionHtml(
              that: this, publicDescriptionHtml: publicDescriptionHtml);

  set publicTraffic(bool publicTraffic) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetPublicTraffic(
          that: this, publicTraffic: publicTraffic);

  set shouldArchivePosts(bool shouldArchivePosts) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetShouldArchivePosts(
          that: this, shouldArchivePosts: shouldArchivePosts);

  set shouldShowMediaInCommentsSetting(bool shouldShowMediaInCommentsSetting) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetShouldShowMediaInCommentsSetting(
              that: this,
              shouldShowMediaInCommentsSetting:
                  shouldShowMediaInCommentsSetting);

  set showMediaPreview(bool showMediaPreview) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetShowMediaPreview(
          that: this, showMediaPreview: showMediaPreview);

  set spoilersEnabled(bool spoilersEnabled) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSpoilersEnabled(
          that: this, spoilersEnabled: spoilersEnabled);

  set submissionType(String? submissionType) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSubmissionType(
          that: this, submissionType: submissionType);

  set submitText(String? submitText) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSubmitText(
          that: this, submitText: submitText);

  set submitTextHtml(String? submitTextHtml) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSubmitTextHtml(
          that: this, submitTextHtml: submitTextHtml);

  set suggestedCommentSort(String? suggestedCommentSort) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSuggestedCommentSort(
          that: this, suggestedCommentSort: suggestedCommentSort);

  set userCanFlairInSr(bool? userCanFlairInSr) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserCanFlairInSr(
          that: this, userCanFlairInSr: userCanFlairInSr);

  set userFlair(Flair userFlair) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserFlair(
          that: this, userFlair: userFlair);

  set userFlairEnabledInSr(bool userFlairEnabledInSr) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserFlairEnabledInSr(
          that: this, userFlairEnabledInSr: userFlairEnabledInSr);

  set userHasFavorited(bool userHasFavorited) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserHasFavorited(
          that: this, userHasFavorited: userHasFavorited);

  set userSrFlairEnabled(bool? userSrFlairEnabled) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserSrFlairEnabled(
          that: this, userSrFlairEnabled: userSrFlairEnabled);

  set userSrThemeEnabled(bool userSrThemeEnabled) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserSrThemeEnabled(
          that: this, userSrThemeEnabled: userSrThemeEnabled);

  set wikiEnabled(bool? wikiEnabled) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetWikiEnabled(
          that: this, wikiEnabled: wikiEnabled);

  set wls(int? wls) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetWls(that: this, wls: wls);

  /// flutter_rust_bridge:getter,sync
  SubredditIcon get icon =>
      RustLib.instance.api.redditApiModelSubredditSubredditIcon(
        that: this,
      );
}

@sealed
class SubredditInfoImpl extends RustOpaque implements SubredditInfo {
  // Not to be used by end users
  SubredditInfoImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SubredditInfoImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SubredditInfo,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubredditInfo,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubredditInfoPtr,
  );

  Details? get details => RustLib.instance.api
          .redditApiModelSubredditSubredditInfoAutoAccessorGetDetails(
        that: this,
      );

  String get subreddit => RustLib.instance.api
          .redditApiModelSubredditSubredditInfoAutoAccessorGetSubreddit(
        that: this,
      );

  SubredditId get subredditId => RustLib.instance.api
          .redditApiModelSubredditSubredditInfoAutoAccessorGetSubredditId(
        that: this,
      );

  String get subredditNamePrefixed => RustLib.instance.api
          .redditApiModelSubredditSubredditInfoAutoAccessorGetSubredditNamePrefixed(
        that: this,
      );

  int get subscribers => RustLib.instance.api
          .redditApiModelSubredditSubredditInfoAutoAccessorGetSubscribers(
        that: this,
      );

  set details(Details? details) => RustLib.instance.api
      .redditApiModelSubredditSubredditInfoAutoAccessorSetDetails(
          that: this, details: details);

  set subreddit(String subreddit) => RustLib.instance.api
      .redditApiModelSubredditSubredditInfoAutoAccessorSetSubreddit(
          that: this, subreddit: subreddit);

  set subredditId(SubredditId subredditId) => RustLib.instance.api
      .redditApiModelSubredditSubredditInfoAutoAccessorSetSubredditId(
          that: this, subredditId: subredditId);

  set subredditNamePrefixed(String subredditNamePrefixed) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditInfoAutoAccessorSetSubredditNamePrefixed(
          that: this, subredditNamePrefixed: subredditNamePrefixed);

  set subscribers(int subscribers) => RustLib.instance.api
      .redditApiModelSubredditSubredditInfoAutoAccessorSetSubscribers(
          that: this, subscribers: subscribers);
}

@sealed
class UrlImpl extends RustOpaque implements Url {
  // Not to be used by end users
  UrlImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  UrlImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Url,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Url,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_UrlPtr,
  );
}
