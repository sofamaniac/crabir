// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/simple.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'third_party/reddit_api/client.dart';
import 'third_party/reddit_api/model.dart';
import 'third_party/reddit_api/model/feed.dart';
import 'third_party/reddit_api/model/flair.dart';
import 'third_party/reddit_api/model/multi.dart';
import 'third_party/reddit_api/model/post.dart';
import 'third_party/reddit_api/model/subreddit.dart';
import 'third_party/reddit_api/model/user.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiSimpleInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.10.0';

  @override
  int get rustContentHash => -1733747484;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'rust_lib_crabir',
    ioDirectory: '../crabir_bridge/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Flair redditApiModelPostAuthorInfoAutoAccessorGetFlair(
      {required AuthorInfo that});

  String redditApiModelPostAuthorInfoAutoAccessorGetFullname(
      {required AuthorInfo that});

  bool redditApiModelPostAuthorInfoAutoAccessorGetIsBlocked(
      {required AuthorInfo that});

  bool redditApiModelPostAuthorInfoAutoAccessorGetPatreonFlair(
      {required AuthorInfo that});

  bool redditApiModelPostAuthorInfoAutoAccessorGetPremium(
      {required AuthorInfo that});

  String redditApiModelPostAuthorInfoAutoAccessorGetUsername(
      {required AuthorInfo that});

  void redditApiModelPostAuthorInfoAutoAccessorSetFlair(
      {required AuthorInfo that, required Flair flair});

  void redditApiModelPostAuthorInfoAutoAccessorSetFullname(
      {required AuthorInfo that, required String fullname});

  void redditApiModelPostAuthorInfoAutoAccessorSetIsBlocked(
      {required AuthorInfo that, required bool isBlocked});

  void redditApiModelPostAuthorInfoAutoAccessorSetPatreonFlair(
      {required AuthorInfo that, required bool patreonFlair});

  void redditApiModelPostAuthorInfoAutoAccessorSetPremium(
      {required AuthorInfo that, required bool premium});

  void redditApiModelPostAuthorInfoAutoAccessorSetUsername(
      {required AuthorInfo that, required String username});

  Future<AuthorInfo> redditApiModelPostAuthorInfoDefault();

  Future<void> redditApiClientClientAuthenticate(
      {required Client that, required String refreshToken});

  Future<Client> redditApiClientClientDefault();

  Future<Client> redditApiClientClientFromRefreshToken(
      {required String refreshToken});

  Future<UserInfo> redditApiClientClientLoggedUserInfo({required Client that});

  Future<List<Multi>> redditApiClientClientMultis({required Client that});

  Future<Client> redditApiClientClientNewAnonymous();

  Future<void> redditApiClientClientSave(
      {required Client that, required Fullname thing});

  Future<List<Subreddit>> redditApiClientClientSubsriptions(
      {required Client that});

  Future<void> redditApiClientClientUnsave(
      {required Client that, required Fullname thing});

  Future<void> redditApiClientClientVote(
      {required Client that,
      required Fullname thing,
      required VoteDirection direction});

  bool crateApiSimpleFeedStateGetDone({required FeedState that});

  Feed crateApiSimpleFeedStateGetFeed({required FeedState that});

  int crateApiSimpleFeedStateGetLength({required FeedState that});

  bool crateApiSimpleFeedStateGetLoading({required FeedState that});

  Sort crateApiSimpleFeedStateGetSort({required FeedState that});

  String crateApiSimpleFeedStateGetSortString({required FeedState that});

  String crateApiSimpleFeedStateGetTitle({required FeedState that});

  FeedState crateApiSimpleFeedStateNew(
      {required Feed feed, required Sort sort});

  Future<bool> crateApiSimpleFeedStateNext({required FeedState that});

  Post? crateApiSimpleFeedStateNth({required FeedState that, required int n});

  Future<void> crateApiSimpleFeedStateRefresh({required FeedState that});

  Future<void> crateApiSimpleFeedStateSetFeed(
      {required FeedState that, required Feed feed});

  Future<void> crateApiSimpleFeedStateSetSort(
      {required FeedState that, required Sort sort});

  Future<FeedStream> redditApiModelFeedFeedStreamNew(
      {required Client client, required Feed feed, required Sort sort});

  String? redditApiModelFlairFlairAutoAccessorGetCssClass(
      {required Flair that});

  String? redditApiModelFlairFlairAutoAccessorGetFlairType(
      {required Flair that});

  String? redditApiModelFlairFlairAutoAccessorGetPosition(
      {required Flair that});

  List<Map<String, String>> redditApiModelFlairFlairAutoAccessorGetRichtext(
      {required Flair that});

  String? redditApiModelFlairFlairAutoAccessorGetTemplateId(
      {required Flair that});

  String? redditApiModelFlairFlairAutoAccessorGetText({required Flair that});

  void redditApiModelFlairFlairAutoAccessorSetCssClass(
      {required Flair that, String? cssClass});

  void redditApiModelFlairFlairAutoAccessorSetFlairType(
      {required Flair that, String? flairType});

  void redditApiModelFlairFlairAutoAccessorSetPosition(
      {required Flair that, String? position});

  void redditApiModelFlairFlairAutoAccessorSetRichtext(
      {required Flair that, required List<Map<String, String>> richtext});

  void redditApiModelFlairFlairAutoAccessorSetTemplateId(
      {required Flair that, String? templateId});

  void redditApiModelFlairFlairAutoAccessorSetText(
      {required Flair that, String? text});

  Future<Flair> redditApiModelFlairFlairDefault();

  Future<Fullname> redditApiModelFullnameDefault();

  String? redditApiModelListingAutoAccessorGetAfter({required Listing that});

  String? redditApiModelListingAutoAccessorGetBefore({required Listing that});

  List<Thing> redditApiModelListingAutoAccessorGetChildren(
      {required Listing that});

  BigInt redditApiModelListingAutoAccessorGetDist({required Listing that});

  String? redditApiModelListingAutoAccessorGetModhash({required Listing that});

  void redditApiModelListingAutoAccessorSetAfter(
      {required Listing that, String? after});

  void redditApiModelListingAutoAccessorSetBefore(
      {required Listing that, String? before});

  void redditApiModelListingAutoAccessorSetChildren(
      {required Listing that, required List<Thing> children});

  void redditApiModelListingAutoAccessorSetDist(
      {required Listing that, required BigInt dist});

  void redditApiModelListingAutoAccessorSetModhash(
      {required Listing that, String? modhash});

  Future<Listing> redditApiModelListingDefault();

  String redditApiModelPostOembedAutoAccessorGetAuthorName(
      {required Oembed that});

  String redditApiModelPostOembedAutoAccessorGetAuthorUrl(
      {required Oembed that});

  PlatformInt64 redditApiModelPostOembedAutoAccessorGetHeight(
      {required Oembed that});

  String redditApiModelPostOembedAutoAccessorGetHtml({required Oembed that});

  String redditApiModelPostOembedAutoAccessorGetProviderName(
      {required Oembed that});

  String redditApiModelPostOembedAutoAccessorGetProviderUrl(
      {required Oembed that});

  String redditApiModelPostOembedAutoAccessorGetTitle({required Oembed that});

  String redditApiModelPostOembedAutoAccessorGetTypeField(
      {required Oembed that});

  String redditApiModelPostOembedAutoAccessorGetVersion({required Oembed that});

  PlatformInt64 redditApiModelPostOembedAutoAccessorGetWidth(
      {required Oembed that});

  void redditApiModelPostOembedAutoAccessorSetAuthorName(
      {required Oembed that, required String authorName});

  void redditApiModelPostOembedAutoAccessorSetAuthorUrl(
      {required Oembed that, required String authorUrl});

  void redditApiModelPostOembedAutoAccessorSetHeight(
      {required Oembed that, required PlatformInt64 height});

  void redditApiModelPostOembedAutoAccessorSetHtml(
      {required Oembed that, required String html});

  void redditApiModelPostOembedAutoAccessorSetProviderName(
      {required Oembed that, required String providerName});

  void redditApiModelPostOembedAutoAccessorSetProviderUrl(
      {required Oembed that, required String providerUrl});

  void redditApiModelPostOembedAutoAccessorSetTitle(
      {required Oembed that, required String title});

  void redditApiModelPostOembedAutoAccessorSetTypeField(
      {required Oembed that, required String typeField});

  void redditApiModelPostOembedAutoAccessorSetVersion(
      {required Oembed that, required String version});

  void redditApiModelPostOembedAutoAccessorSetWidth(
      {required Oembed that, required PlatformInt64 width});

  Future<Oembed> redditApiModelPostOembedDefault();

  Future<Url> redditApiClientPagerAddToUrl(
      {required Pager that, required Url url});

  Future<void> redditApiClientPagerAfter({required Pager that, String? after});

  Future<void> redditApiClientPagerBefore(
      {required Pager that, String? before});

  Future<Pager> redditApiClientPagerDefault();

  Future<PostId> redditApiModelPostPostIdDefault();

  List<String?> redditApiModelPostPostAutoAccessorGetAllAwardings(
      {required Post that});

  bool redditApiModelPostPostAutoAccessorGetAllowLiveComments(
      {required Post that});

  double? redditApiModelPostPostAutoAccessorGetApprovedAtUtc(
      {required Post that});

  String? redditApiModelPostPostAutoAccessorGetApprovedBy({required Post that});

  bool redditApiModelPostPostAutoAccessorGetArchived({required Post that});

  AuthorInfo? redditApiModelPostPostAutoAccessorGetAuthor({required Post that});

  List<String?> redditApiModelPostPostAutoAccessorGetAwarders(
      {required Post that});

  double? redditApiModelPostPostAutoAccessorGetBannedAtUtc(
      {required Post that});

  String? redditApiModelPostPostAutoAccessorGetBannedBy({required Post that});

  bool redditApiModelPostPostAutoAccessorGetCanGild({required Post that});

  bool redditApiModelPostPostAutoAccessorGetCanModPost({required Post that});

  String? redditApiModelPostPostAutoAccessorGetCategory({required Post that});

  bool redditApiModelPostPostAutoAccessorGetClicked({required Post that});

  List<String> redditApiModelPostPostAutoAccessorGetContentCategories(
      {required Post that});

  bool redditApiModelPostPostAutoAccessorGetContestMode({required Post that});

  DateTime redditApiModelPostPostAutoAccessorGetCreated({required Post that});

  DateTime redditApiModelPostPostAutoAccessorGetCreatedUtc(
      {required Post that});

  String? redditApiModelPostPostAutoAccessorGetDiscussionType(
      {required Post that});

  String? redditApiModelPostPostAutoAccessorGetDistinguished(
      {required Post that});

  String redditApiModelPostPostAutoAccessorGetDomain({required Post that});

  PlatformInt64 redditApiModelPostPostAutoAccessorGetDowns(
      {required Post that});

  double? redditApiModelPostPostAutoAccessorGetEdited({required Post that});

  Gallery? redditApiModelPostPostAutoAccessorGetGallery({required Post that});

  PlatformInt64 redditApiModelPostPostAutoAccessorGetGilded(
      {required Post that});

  Gildings redditApiModelPostPostAutoAccessorGetGildings({required Post that});

  bool redditApiModelPostPostAutoAccessorGetHidden({required Post that});

  bool redditApiModelPostPostAutoAccessorGetHideScore({required Post that});

  PostId redditApiModelPostPostAutoAccessorGetId({required Post that});

  bool redditApiModelPostPostAutoAccessorGetIsCreatedFromAdsUi(
      {required Post that});

  bool redditApiModelPostPostAutoAccessorGetIsCrosspostable(
      {required Post that});

  bool redditApiModelPostPostAutoAccessorGetIsMeta({required Post that});

  bool redditApiModelPostPostAutoAccessorGetIsOriginalContent(
      {required Post that});

  bool redditApiModelPostPostAutoAccessorGetIsRedditMediaDomain(
      {required Post that});

  bool redditApiModelPostPostAutoAccessorGetIsRobotIndexable(
      {required Post that});

  bool redditApiModelPostPostAutoAccessorGetIsSelf({required Post that});

  bool redditApiModelPostPostAutoAccessorGetIsVideo({required Post that});

  bool? redditApiModelPostPostAutoAccessorGetLikes({required Post that});

  Flair redditApiModelPostPostAutoAccessorGetLinkFlair({required Post that});

  bool redditApiModelPostPostAutoAccessorGetLocked({required Post that});

  Media? redditApiModelPostPostAutoAccessorGetMedia({required Post that});

  MediaEmbed? redditApiModelPostPostAutoAccessorGetMediaEmbed(
      {required Post that});

  bool redditApiModelPostPostAutoAccessorGetMediaOnly({required Post that});

  String? redditApiModelPostPostAutoAccessorGetModNote({required Post that});

  String? redditApiModelPostPostAutoAccessorGetModReasonBy(
      {required Post that});

  String? redditApiModelPostPostAutoAccessorGetModReasonTitle(
      {required Post that});

  List<String?> redditApiModelPostPostAutoAccessorGetModReports(
      {required Post that});

  Fullname redditApiModelPostPostAutoAccessorGetName({required Post that});

  bool redditApiModelPostPostAutoAccessorGetNoFollow({required Post that});

  PlatformInt64 redditApiModelPostPostAutoAccessorGetNumComments(
      {required Post that});

  PlatformInt64? redditApiModelPostPostAutoAccessorGetNumCrossposts(
      {required Post that});

  BigInt? redditApiModelPostPostAutoAccessorGetNumDuplicates(
      {required Post that});

  String? redditApiModelPostPostAutoAccessorGetNumReports({required Post that});

  bool redditApiModelPostPostAutoAccessorGetOver18({required Post that});

  String redditApiModelPostPostAutoAccessorGetPermalink({required Post that});

  bool redditApiModelPostPostAutoAccessorGetPinned({required Post that});

  String? redditApiModelPostPostAutoAccessorGetPostHint({required Post that});

  Preview? redditApiModelPostPostAutoAccessorGetPreview({required Post that});

  PlatformInt64? redditApiModelPostPostAutoAccessorGetPwls(
      {required Post that});

  bool redditApiModelPostPostAutoAccessorGetQuarantine({required Post that});

  String? redditApiModelPostPostAutoAccessorGetRemovalReason(
      {required Post that});

  String? redditApiModelPostPostAutoAccessorGetRemovedBy({required Post that});

  String? redditApiModelPostPostAutoAccessorGetRemovedByCategory(
      {required Post that});

  String? redditApiModelPostPostAutoAccessorGetReportReasons(
      {required Post that});

  bool redditApiModelPostPostAutoAccessorGetSaved({required Post that});

  PlatformInt64 redditApiModelPostPostAutoAccessorGetScore(
      {required Post that});

  SecureMedia? redditApiModelPostPostAutoAccessorGetSecureMedia(
      {required Post that});

  SecureMediaEmbed? redditApiModelPostPostAutoAccessorGetSecureMediaEmbed(
      {required Post that});

  String? redditApiModelPostPostAutoAccessorGetSelftext({required Post that});

  String? redditApiModelPostPostAutoAccessorGetSelftextHtml(
      {required Post that});

  bool redditApiModelPostPostAutoAccessorGetSendReplies({required Post that});

  bool redditApiModelPostPostAutoAccessorGetSpoiler({required Post that});

  bool redditApiModelPostPostAutoAccessorGetStickied({required Post that});

  SubredditInfo redditApiModelPostPostAutoAccessorGetSubreddit(
      {required Post that});

  String? redditApiModelPostPostAutoAccessorGetSuggestedSort(
      {required Post that});

  String redditApiModelPostPostAutoAccessorGetTitle({required Post that});

  String? redditApiModelPostPostAutoAccessorGetTopAwardedType(
      {required Post that});

  PlatformInt64? redditApiModelPostPostAutoAccessorGetTotalAwardsReceived(
      {required Post that});

  List<String?> redditApiModelPostPostAutoAccessorGetTreatmentTags(
      {required Post that});

  PlatformInt64 redditApiModelPostPostAutoAccessorGetUps({required Post that});

  double redditApiModelPostPostAutoAccessorGetUpvoteRatio({required Post that});

  String redditApiModelPostPostAutoAccessorGetUrl({required Post that});

  String? redditApiModelPostPostAutoAccessorGetUrlOverriddenByDest(
      {required Post that});

  List<String?> redditApiModelPostPostAutoAccessorGetUserReports(
      {required Post that});

  String? redditApiModelPostPostAutoAccessorGetViewCount({required Post that});

  bool redditApiModelPostPostAutoAccessorGetVisited({required Post that});

  PlatformInt64? redditApiModelPostPostAutoAccessorGetWls({required Post that});

  void redditApiModelPostPostAutoAccessorSetAllAwardings(
      {required Post that, required List<String?> allAwardings});

  void redditApiModelPostPostAutoAccessorSetAllowLiveComments(
      {required Post that, required bool allowLiveComments});

  void redditApiModelPostPostAutoAccessorSetApprovedAtUtc(
      {required Post that, double? approvedAtUtc});

  void redditApiModelPostPostAutoAccessorSetApprovedBy(
      {required Post that, String? approvedBy});

  void redditApiModelPostPostAutoAccessorSetArchived(
      {required Post that, required bool archived});

  void redditApiModelPostPostAutoAccessorSetAuthor(
      {required Post that, AuthorInfo? author});

  void redditApiModelPostPostAutoAccessorSetAwarders(
      {required Post that, required List<String?> awarders});

  void redditApiModelPostPostAutoAccessorSetBannedAtUtc(
      {required Post that, double? bannedAtUtc});

  void redditApiModelPostPostAutoAccessorSetBannedBy(
      {required Post that, String? bannedBy});

  void redditApiModelPostPostAutoAccessorSetCanGild(
      {required Post that, required bool canGild});

  void redditApiModelPostPostAutoAccessorSetCanModPost(
      {required Post that, required bool canModPost});

  void redditApiModelPostPostAutoAccessorSetCategory(
      {required Post that, String? category});

  void redditApiModelPostPostAutoAccessorSetClicked(
      {required Post that, required bool clicked});

  void redditApiModelPostPostAutoAccessorSetContentCategories(
      {required Post that, required List<String> contentCategories});

  void redditApiModelPostPostAutoAccessorSetContestMode(
      {required Post that, required bool contestMode});

  void redditApiModelPostPostAutoAccessorSetCreated(
      {required Post that, required DateTime created});

  void redditApiModelPostPostAutoAccessorSetCreatedUtc(
      {required Post that, required DateTime createdUtc});

  void redditApiModelPostPostAutoAccessorSetDiscussionType(
      {required Post that, String? discussionType});

  void redditApiModelPostPostAutoAccessorSetDistinguished(
      {required Post that, String? distinguished});

  void redditApiModelPostPostAutoAccessorSetDomain(
      {required Post that, required String domain});

  void redditApiModelPostPostAutoAccessorSetDowns(
      {required Post that, required PlatformInt64 downs});

  void redditApiModelPostPostAutoAccessorSetEdited(
      {required Post that, double? edited});

  void redditApiModelPostPostAutoAccessorSetGallery(
      {required Post that, Gallery? gallery});

  void redditApiModelPostPostAutoAccessorSetGilded(
      {required Post that, required PlatformInt64 gilded});

  void redditApiModelPostPostAutoAccessorSetGildings(
      {required Post that, required Gildings gildings});

  void redditApiModelPostPostAutoAccessorSetHidden(
      {required Post that, required bool hidden});

  void redditApiModelPostPostAutoAccessorSetHideScore(
      {required Post that, required bool hideScore});

  void redditApiModelPostPostAutoAccessorSetId(
      {required Post that, required PostId id});

  void redditApiModelPostPostAutoAccessorSetIsCreatedFromAdsUi(
      {required Post that, required bool isCreatedFromAdsUi});

  void redditApiModelPostPostAutoAccessorSetIsCrosspostable(
      {required Post that, required bool isCrosspostable});

  void redditApiModelPostPostAutoAccessorSetIsMeta(
      {required Post that, required bool isMeta});

  void redditApiModelPostPostAutoAccessorSetIsOriginalContent(
      {required Post that, required bool isOriginalContent});

  void redditApiModelPostPostAutoAccessorSetIsRedditMediaDomain(
      {required Post that, required bool isRedditMediaDomain});

  void redditApiModelPostPostAutoAccessorSetIsRobotIndexable(
      {required Post that, required bool isRobotIndexable});

  void redditApiModelPostPostAutoAccessorSetIsSelf(
      {required Post that, required bool isSelf});

  void redditApiModelPostPostAutoAccessorSetIsVideo(
      {required Post that, required bool isVideo});

  void redditApiModelPostPostAutoAccessorSetLikes(
      {required Post that, bool? likes});

  void redditApiModelPostPostAutoAccessorSetLinkFlair(
      {required Post that, required Flair linkFlair});

  void redditApiModelPostPostAutoAccessorSetLocked(
      {required Post that, required bool locked});

  void redditApiModelPostPostAutoAccessorSetMedia(
      {required Post that, Media? media});

  void redditApiModelPostPostAutoAccessorSetMediaEmbed(
      {required Post that, MediaEmbed? mediaEmbed});

  void redditApiModelPostPostAutoAccessorSetMediaOnly(
      {required Post that, required bool mediaOnly});

  void redditApiModelPostPostAutoAccessorSetModNote(
      {required Post that, String? modNote});

  void redditApiModelPostPostAutoAccessorSetModReasonBy(
      {required Post that, String? modReasonBy});

  void redditApiModelPostPostAutoAccessorSetModReasonTitle(
      {required Post that, String? modReasonTitle});

  void redditApiModelPostPostAutoAccessorSetModReports(
      {required Post that, required List<String?> modReports});

  void redditApiModelPostPostAutoAccessorSetName(
      {required Post that, required Fullname name});

  void redditApiModelPostPostAutoAccessorSetNoFollow(
      {required Post that, required bool noFollow});

  void redditApiModelPostPostAutoAccessorSetNumComments(
      {required Post that, required PlatformInt64 numComments});

  void redditApiModelPostPostAutoAccessorSetNumCrossposts(
      {required Post that, PlatformInt64? numCrossposts});

  void redditApiModelPostPostAutoAccessorSetNumDuplicates(
      {required Post that, BigInt? numDuplicates});

  void redditApiModelPostPostAutoAccessorSetNumReports(
      {required Post that, String? numReports});

  void redditApiModelPostPostAutoAccessorSetOver18(
      {required Post that, required bool over18});

  void redditApiModelPostPostAutoAccessorSetPermalink(
      {required Post that, required String permalink});

  void redditApiModelPostPostAutoAccessorSetPinned(
      {required Post that, required bool pinned});

  void redditApiModelPostPostAutoAccessorSetPostHint(
      {required Post that, String? postHint});

  void redditApiModelPostPostAutoAccessorSetPreview(
      {required Post that, Preview? preview});

  void redditApiModelPostPostAutoAccessorSetPwls(
      {required Post that, PlatformInt64? pwls});

  void redditApiModelPostPostAutoAccessorSetQuarantine(
      {required Post that, required bool quarantine});

  void redditApiModelPostPostAutoAccessorSetRemovalReason(
      {required Post that, String? removalReason});

  void redditApiModelPostPostAutoAccessorSetRemovedBy(
      {required Post that, String? removedBy});

  void redditApiModelPostPostAutoAccessorSetRemovedByCategory(
      {required Post that, String? removedByCategory});

  void redditApiModelPostPostAutoAccessorSetReportReasons(
      {required Post that, String? reportReasons});

  void redditApiModelPostPostAutoAccessorSetSaved(
      {required Post that, required bool saved});

  void redditApiModelPostPostAutoAccessorSetScore(
      {required Post that, required PlatformInt64 score});

  void redditApiModelPostPostAutoAccessorSetSecureMedia(
      {required Post that, SecureMedia? secureMedia});

  void redditApiModelPostPostAutoAccessorSetSecureMediaEmbed(
      {required Post that, SecureMediaEmbed? secureMediaEmbed});

  void redditApiModelPostPostAutoAccessorSetSelftext(
      {required Post that, String? selftext});

  void redditApiModelPostPostAutoAccessorSetSelftextHtml(
      {required Post that, String? selftextHtml});

  void redditApiModelPostPostAutoAccessorSetSendReplies(
      {required Post that, required bool sendReplies});

  void redditApiModelPostPostAutoAccessorSetSpoiler(
      {required Post that, required bool spoiler});

  void redditApiModelPostPostAutoAccessorSetStickied(
      {required Post that, required bool stickied});

  void redditApiModelPostPostAutoAccessorSetSubreddit(
      {required Post that, required SubredditInfo subreddit});

  void redditApiModelPostPostAutoAccessorSetSuggestedSort(
      {required Post that, String? suggestedSort});

  void redditApiModelPostPostAutoAccessorSetTitle(
      {required Post that, required String title});

  void redditApiModelPostPostAutoAccessorSetTopAwardedType(
      {required Post that, String? topAwardedType});

  void redditApiModelPostPostAutoAccessorSetTotalAwardsReceived(
      {required Post that, PlatformInt64? totalAwardsReceived});

  void redditApiModelPostPostAutoAccessorSetTreatmentTags(
      {required Post that, required List<String?> treatmentTags});

  void redditApiModelPostPostAutoAccessorSetUps(
      {required Post that, required PlatformInt64 ups});

  void redditApiModelPostPostAutoAccessorSetUpvoteRatio(
      {required Post that, required double upvoteRatio});

  void redditApiModelPostPostAutoAccessorSetUrl(
      {required Post that, required String url});

  void redditApiModelPostPostAutoAccessorSetUrlOverriddenByDest(
      {required Post that, String? urlOverriddenByDest});

  void redditApiModelPostPostAutoAccessorSetUserReports(
      {required Post that, required List<String?> userReports});

  void redditApiModelPostPostAutoAccessorSetViewCount(
      {required Post that, String? viewCount});

  void redditApiModelPostPostAutoAccessorSetVisited(
      {required Post that, required bool visited});

  void redditApiModelPostPostAutoAccessorSetWls(
      {required Post that, PlatformInt64? wls});

  Future<Post> redditApiModelPostPostDefault();

  Kind redditApiModelPostPostKind({required Post that});

  Thumbnail? redditApiModelPostPostThumbnail({required Post that});

  Future<RedditVideo> redditApiModelPostRedditVideoDefault();

  Future<SubredditId> redditApiModelPostSubredditIdDefault();

  String redditApiModelPostSubredditInfoAutoAccessorGetSubreddit(
      {required SubredditInfo that});

  SubredditId redditApiModelPostSubredditInfoAutoAccessorGetSubredditId(
      {required SubredditInfo that});

  String redditApiModelPostSubredditInfoAutoAccessorGetSubredditNamePrefixed(
      {required SubredditInfo that});

  String redditApiModelPostSubredditInfoAutoAccessorGetSubredditType(
      {required SubredditInfo that});

  BigInt redditApiModelPostSubredditInfoAutoAccessorGetSubscribers(
      {required SubredditInfo that});

  void redditApiModelPostSubredditInfoAutoAccessorSetSubreddit(
      {required SubredditInfo that, required String subreddit});

  void redditApiModelPostSubredditInfoAutoAccessorSetSubredditId(
      {required SubredditInfo that, required SubredditId subredditId});

  void redditApiModelPostSubredditInfoAutoAccessorSetSubredditNamePrefixed(
      {required SubredditInfo that, required String subredditNamePrefixed});

  void redditApiModelPostSubredditInfoAutoAccessorSetSubredditType(
      {required SubredditInfo that, required String subredditType});

  void redditApiModelPostSubredditInfoAutoAccessorSetSubscribers(
      {required SubredditInfo that, required BigInt subscribers});

  Future<SubredditInfo> redditApiModelPostSubredditInfoDefault();

  bool redditApiModelSubredditSubredditAutoAccessorGetAcceptFollowers(
      {required Subreddit that});

  BigInt? redditApiModelSubredditSubredditAutoAccessorGetAccountsActive(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAccountsActiveIsFuzzed(
      {required Subreddit that});

  BigInt redditApiModelSubredditSubredditAutoAccessorGetActiveUserCount(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetAdvertiserCategory(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllOriginalContent(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowDiscovery(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowGalleries(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowImages(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowPolls(
      {required Subreddit that});

  bool
      redditApiModelSubredditSubredditAutoAccessorGetAllowPredictionContributors(
          {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowPredictions(
      {required Subreddit that});

  bool
      redditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsTournament(
          {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowTalks(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowVideogifs(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetAllowVideos(
      {required Subreddit that});

  List<String>
      redditApiModelSubredditSubredditAutoAccessorGetAllowedMediaInComments(
          {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundColor(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundImage(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetBannerImg(
      {required Subreddit that});

  Int64List? redditApiModelSubredditSubredditAutoAccessorGetBannerSize(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetCanAssignLinkFlair(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetCanAssignUserFlair(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetCollapseDeletedComments(
      {required Subreddit that});

  CommentContributionSettings
      redditApiModelSubredditSubredditAutoAccessorGetCommentContributionSettings(
          {required Subreddit that});

  PlatformInt64
      redditApiModelSubredditSubredditAutoAccessorGetCommentScoreHideMins(
          {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetCommunityIcon(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetCommunityReviewed(
      {required Subreddit that});

  double redditApiModelSubredditSubredditAutoAccessorGetCreated(
      {required Subreddit that});

  double redditApiModelSubredditSubredditAutoAccessorGetCreatedUtc(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetDescription(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetDescriptionHtml(
      {required Subreddit that});

  bool
      redditApiModelSubredditSubredditAutoAccessorGetDisableContributorRequests(
          {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetDisplayName(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetDisplayNamePrefixed(
      {required Subreddit that});

  Int64List? redditApiModelSubredditSubredditAutoAccessorGetEmojisCustomSize(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetEmojisEnabled(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetFreeFormReports(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetHasMenuWidget(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetHeaderImg(
      {required Subreddit that});

  Int64List? redditApiModelSubredditSubredditAutoAccessorGetHeaderSize(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetHeaderTitle(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetHideAds(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetIconImg(
      {required Subreddit that});

  UsizeArray2? redditApiModelSubredditSubredditAutoAccessorGetIconSize(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetId(
      {required Subreddit that});

  bool? redditApiModelSubredditSubredditAutoAccessorGetIsCrosspostableSubreddit(
      {required Subreddit that});

  bool? redditApiModelSubredditSubredditAutoAccessorGetIsEnrolledInNewModmail(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetKeyColor(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetLang(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetLinkFlairEnabled(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetLinkFlairPosition(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetMobileBannerImage(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetName(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetNotificationLevel(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetOriginalContentTagEnabled(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetOver18(
      {required Subreddit that});

  PlatformInt64
      redditApiModelSubredditSubredditAutoAccessorGetPredictionLeaderboardEntryType(
          {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetPrimaryColor(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetPublicDescription(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetPublicDescriptionHtml(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetPublicTraffic(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetQuarantine(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetRestrictCommenting(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetRestrictPosting(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetShouldArchivePosts(
      {required Subreddit that});

  bool
      redditApiModelSubredditSubredditAutoAccessorGetShouldShowMediaInCommentsSetting(
          {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetShowMedia(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetShowMediaPreview(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetSpoilersEnabled(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetSubmissionType(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetSubmitLinkLabel(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetSubmitText(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetSubmitTextHtml(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetSubmitTextLabel(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetSubredditType(
      {required Subreddit that});

  PlatformInt64 redditApiModelSubredditSubredditAutoAccessorGetSubscribers(
      {required Subreddit that});

  String? redditApiModelSubredditSubredditAutoAccessorGetSuggestedCommentSort(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetTitle(
      {required Subreddit that});

  String redditApiModelSubredditSubredditAutoAccessorGetUrl(
      {required Subreddit that});

  bool? redditApiModelSubredditSubredditAutoAccessorGetUserCanFlairInSr(
      {required Subreddit that});

  Flair redditApiModelSubredditSubredditAutoAccessorGetUserFlair(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetUserFlairEnabledInSr(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetUserHasFavorited(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetUserIsBanned(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetUserIsContributor(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetUserIsModerator(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetUserIsMuted(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetUserIsSubscriber(
      {required Subreddit that});

  bool? redditApiModelSubredditSubredditAutoAccessorGetUserSrFlairEnabled(
      {required Subreddit that});

  bool redditApiModelSubredditSubredditAutoAccessorGetUserSrThemeEnabled(
      {required Subreddit that});

  bool? redditApiModelSubredditSubredditAutoAccessorGetWikiEnabled(
      {required Subreddit that});

  BigInt? redditApiModelSubredditSubredditAutoAccessorGetWls(
      {required Subreddit that});

  void redditApiModelSubredditSubredditAutoAccessorSetAcceptFollowers(
      {required Subreddit that, required bool acceptFollowers});

  void redditApiModelSubredditSubredditAutoAccessorSetAccountsActive(
      {required Subreddit that, BigInt? accountsActive});

  void redditApiModelSubredditSubredditAutoAccessorSetAccountsActiveIsFuzzed(
      {required Subreddit that, required bool accountsActiveIsFuzzed});

  void redditApiModelSubredditSubredditAutoAccessorSetActiveUserCount(
      {required Subreddit that, required BigInt activeUserCount});

  void redditApiModelSubredditSubredditAutoAccessorSetAdvertiserCategory(
      {required Subreddit that, required String advertiserCategory});

  void redditApiModelSubredditSubredditAutoAccessorSetAllOriginalContent(
      {required Subreddit that, required bool allOriginalContent});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowDiscovery(
      {required Subreddit that, required bool allowDiscovery});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowGalleries(
      {required Subreddit that, required bool allowGalleries});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowImages(
      {required Subreddit that, required bool allowImages});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowPolls(
      {required Subreddit that, required bool allowPolls});

  void
      redditApiModelSubredditSubredditAutoAccessorSetAllowPredictionContributors(
          {required Subreddit that, required bool allowPredictionContributors});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowPredictions(
      {required Subreddit that, required bool allowPredictions});

  void
      redditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsTournament(
          {required Subreddit that, required bool allowPredictionsTournament});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowTalks(
      {required Subreddit that, required bool allowTalks});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowVideogifs(
      {required Subreddit that, required bool allowVideogifs});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowVideos(
      {required Subreddit that, required bool allowVideos});

  void redditApiModelSubredditSubredditAutoAccessorSetAllowedMediaInComments(
      {required Subreddit that, required List<String> allowedMediaInComments});

  void redditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundColor(
      {required Subreddit that, required String bannerBackgroundColor});

  void redditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundImage(
      {required Subreddit that, required String bannerBackgroundImage});

  void redditApiModelSubredditSubredditAutoAccessorSetBannerImg(
      {required Subreddit that, required String bannerImg});

  void redditApiModelSubredditSubredditAutoAccessorSetBannerSize(
      {required Subreddit that, Int64List? bannerSize});

  void redditApiModelSubredditSubredditAutoAccessorSetCanAssignLinkFlair(
      {required Subreddit that, required bool canAssignLinkFlair});

  void redditApiModelSubredditSubredditAutoAccessorSetCanAssignUserFlair(
      {required Subreddit that, required bool canAssignUserFlair});

  void redditApiModelSubredditSubredditAutoAccessorSetCollapseDeletedComments(
      {required Subreddit that, required bool collapseDeletedComments});

  void
      redditApiModelSubredditSubredditAutoAccessorSetCommentContributionSettings(
          {required Subreddit that,
          required CommentContributionSettings commentContributionSettings});

  void redditApiModelSubredditSubredditAutoAccessorSetCommentScoreHideMins(
      {required Subreddit that, required PlatformInt64 commentScoreHideMins});

  void redditApiModelSubredditSubredditAutoAccessorSetCommunityIcon(
      {required Subreddit that, required String communityIcon});

  void redditApiModelSubredditSubredditAutoAccessorSetCommunityReviewed(
      {required Subreddit that, required bool communityReviewed});

  void redditApiModelSubredditSubredditAutoAccessorSetCreated(
      {required Subreddit that, required double created});

  void redditApiModelSubredditSubredditAutoAccessorSetCreatedUtc(
      {required Subreddit that, required double createdUtc});

  void redditApiModelSubredditSubredditAutoAccessorSetDescription(
      {required Subreddit that, required String description});

  void redditApiModelSubredditSubredditAutoAccessorSetDescriptionHtml(
      {required Subreddit that, String? descriptionHtml});

  void
      redditApiModelSubredditSubredditAutoAccessorSetDisableContributorRequests(
          {required Subreddit that, required bool disableContributorRequests});

  void redditApiModelSubredditSubredditAutoAccessorSetDisplayName(
      {required Subreddit that, required String displayName});

  void redditApiModelSubredditSubredditAutoAccessorSetDisplayNamePrefixed(
      {required Subreddit that, required String displayNamePrefixed});

  void redditApiModelSubredditSubredditAutoAccessorSetEmojisCustomSize(
      {required Subreddit that, Int64List? emojisCustomSize});

  void redditApiModelSubredditSubredditAutoAccessorSetEmojisEnabled(
      {required Subreddit that, required bool emojisEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetFreeFormReports(
      {required Subreddit that, required bool freeFormReports});

  void redditApiModelSubredditSubredditAutoAccessorSetHasMenuWidget(
      {required Subreddit that, required bool hasMenuWidget});

  void redditApiModelSubredditSubredditAutoAccessorSetHeaderImg(
      {required Subreddit that, String? headerImg});

  void redditApiModelSubredditSubredditAutoAccessorSetHeaderSize(
      {required Subreddit that, Int64List? headerSize});

  void redditApiModelSubredditSubredditAutoAccessorSetHeaderTitle(
      {required Subreddit that, required String headerTitle});

  void redditApiModelSubredditSubredditAutoAccessorSetHideAds(
      {required Subreddit that, required bool hideAds});

  void redditApiModelSubredditSubredditAutoAccessorSetIconImg(
      {required Subreddit that, required String iconImg});

  void redditApiModelSubredditSubredditAutoAccessorSetIconSize(
      {required Subreddit that, UsizeArray2? iconSize});

  void redditApiModelSubredditSubredditAutoAccessorSetId(
      {required Subreddit that, required String id});

  void redditApiModelSubredditSubredditAutoAccessorSetIsCrosspostableSubreddit(
      {required Subreddit that, bool? isCrosspostableSubreddit});

  void redditApiModelSubredditSubredditAutoAccessorSetIsEnrolledInNewModmail(
      {required Subreddit that, bool? isEnrolledInNewModmail});

  void redditApiModelSubredditSubredditAutoAccessorSetKeyColor(
      {required Subreddit that, required String keyColor});

  void redditApiModelSubredditSubredditAutoAccessorSetLang(
      {required Subreddit that, required String lang});

  void redditApiModelSubredditSubredditAutoAccessorSetLinkFlairEnabled(
      {required Subreddit that, required bool linkFlairEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetLinkFlairPosition(
      {required Subreddit that, required String linkFlairPosition});

  void redditApiModelSubredditSubredditAutoAccessorSetMobileBannerImage(
      {required Subreddit that, required String mobileBannerImage});

  void redditApiModelSubredditSubredditAutoAccessorSetName(
      {required Subreddit that, required String name});

  void redditApiModelSubredditSubredditAutoAccessorSetNotificationLevel(
      {required Subreddit that, String? notificationLevel});

  void redditApiModelSubredditSubredditAutoAccessorSetOriginalContentTagEnabled(
      {required Subreddit that, required bool originalContentTagEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetOver18(
      {required Subreddit that, required bool over18});

  void
      redditApiModelSubredditSubredditAutoAccessorSetPredictionLeaderboardEntryType(
          {required Subreddit that,
          required PlatformInt64 predictionLeaderboardEntryType});

  void redditApiModelSubredditSubredditAutoAccessorSetPrimaryColor(
      {required Subreddit that, required String primaryColor});

  void redditApiModelSubredditSubredditAutoAccessorSetPublicDescription(
      {required Subreddit that, required String publicDescription});

  void redditApiModelSubredditSubredditAutoAccessorSetPublicDescriptionHtml(
      {required Subreddit that, String? publicDescriptionHtml});

  void redditApiModelSubredditSubredditAutoAccessorSetPublicTraffic(
      {required Subreddit that, required bool publicTraffic});

  void redditApiModelSubredditSubredditAutoAccessorSetQuarantine(
      {required Subreddit that, required bool quarantine});

  void redditApiModelSubredditSubredditAutoAccessorSetRestrictCommenting(
      {required Subreddit that, required bool restrictCommenting});

  void redditApiModelSubredditSubredditAutoAccessorSetRestrictPosting(
      {required Subreddit that, required bool restrictPosting});

  void redditApiModelSubredditSubredditAutoAccessorSetShouldArchivePosts(
      {required Subreddit that, required bool shouldArchivePosts});

  void
      redditApiModelSubredditSubredditAutoAccessorSetShouldShowMediaInCommentsSetting(
          {required Subreddit that,
          required bool shouldShowMediaInCommentsSetting});

  void redditApiModelSubredditSubredditAutoAccessorSetShowMedia(
      {required Subreddit that, required bool showMedia});

  void redditApiModelSubredditSubredditAutoAccessorSetShowMediaPreview(
      {required Subreddit that, required bool showMediaPreview});

  void redditApiModelSubredditSubredditAutoAccessorSetSpoilersEnabled(
      {required Subreddit that, required bool spoilersEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetSubmissionType(
      {required Subreddit that, required String submissionType});

  void redditApiModelSubredditSubredditAutoAccessorSetSubmitLinkLabel(
      {required Subreddit that, required String submitLinkLabel});

  void redditApiModelSubredditSubredditAutoAccessorSetSubmitText(
      {required Subreddit that, required String submitText});

  void redditApiModelSubredditSubredditAutoAccessorSetSubmitTextHtml(
      {required Subreddit that, String? submitTextHtml});

  void redditApiModelSubredditSubredditAutoAccessorSetSubmitTextLabel(
      {required Subreddit that, required String submitTextLabel});

  void redditApiModelSubredditSubredditAutoAccessorSetSubredditType(
      {required Subreddit that, required String subredditType});

  void redditApiModelSubredditSubredditAutoAccessorSetSubscribers(
      {required Subreddit that, required PlatformInt64 subscribers});

  void redditApiModelSubredditSubredditAutoAccessorSetSuggestedCommentSort(
      {required Subreddit that, String? suggestedCommentSort});

  void redditApiModelSubredditSubredditAutoAccessorSetTitle(
      {required Subreddit that, required String title});

  void redditApiModelSubredditSubredditAutoAccessorSetUrl(
      {required Subreddit that, required String url});

  void redditApiModelSubredditSubredditAutoAccessorSetUserCanFlairInSr(
      {required Subreddit that, bool? userCanFlairInSr});

  void redditApiModelSubredditSubredditAutoAccessorSetUserFlair(
      {required Subreddit that, required Flair userFlair});

  void redditApiModelSubredditSubredditAutoAccessorSetUserFlairEnabledInSr(
      {required Subreddit that, required bool userFlairEnabledInSr});

  void redditApiModelSubredditSubredditAutoAccessorSetUserHasFavorited(
      {required Subreddit that, required bool userHasFavorited});

  void redditApiModelSubredditSubredditAutoAccessorSetUserIsBanned(
      {required Subreddit that, required bool userIsBanned});

  void redditApiModelSubredditSubredditAutoAccessorSetUserIsContributor(
      {required Subreddit that, required bool userIsContributor});

  void redditApiModelSubredditSubredditAutoAccessorSetUserIsModerator(
      {required Subreddit that, required bool userIsModerator});

  void redditApiModelSubredditSubredditAutoAccessorSetUserIsMuted(
      {required Subreddit that, required bool userIsMuted});

  void redditApiModelSubredditSubredditAutoAccessorSetUserIsSubscriber(
      {required Subreddit that, required bool userIsSubscriber});

  void redditApiModelSubredditSubredditAutoAccessorSetUserSrFlairEnabled(
      {required Subreddit that, bool? userSrFlairEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetUserSrThemeEnabled(
      {required Subreddit that, required bool userSrThemeEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetWikiEnabled(
      {required Subreddit that, bool? wikiEnabled});

  void redditApiModelSubredditSubredditAutoAccessorSetWls(
      {required Subreddit that, BigInt? wls});

  Future<Subreddit> redditApiModelSubredditSubredditDefault();

  Future<CommentContributionSettings>
      redditApiModelSubredditCommentContributionSettingsDefault();

  Future<Features> redditApiModelUserFeaturesDefault();

  Future<Feed> redditApiModelFeedFeedDefault();

  Future<Gallery> redditApiModelPostGalleryDefault();

  Future<Gildings> redditApiModelPostGildingsDefault();

  Future<ImageBase> redditApiModelPostImageBaseDefault();

  Future<void> crateApiSimpleInitApp();

  Future<MediaEmbed> redditApiModelPostMediaEmbedDefault();

  Future<Multi> redditApiModelMultiMultiDefault();

  Future<NotificationLevel> redditApiModelSubredditNotificationLevelDefault();

  Future<Preferences> redditApiModelUserPreferencesDefault();

  Future<Preview> redditApiModelPostPreviewDefault();

  Client crateApiSimpleRedditApiClient();

  Future<RedditImage> redditApiModelPostRedditImageDefault();

  Future<SecureMediaEmbed> redditApiModelPostSecureMediaEmbedDefault();

  Future<Snoovatar> redditApiModelUserSnoovatarDefault();

  Future<Url> redditApiModelSortAddToUrl(
      {required Sort that, required Url url});

  Future<SubredditName> redditApiModelMultiSubredditNameDefault();

  Future<User> redditApiModelUserUserDefault();

  Future<UserInfo> redditApiModelUserUserInfoDefault();

  Future<UserSubreddit> redditApiModelUserUserSubredditDefault();

  Future<Variants> redditApiModelPostVariantsDefault();

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AuthorInfo;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AuthorInfo;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_AuthorInfoPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Client;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Client;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_FeedState;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_FeedState;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FeedStatePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_FeedStream;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_FeedStream;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FeedStreamPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Flair;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Flair;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FlairPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Fullname;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Fullname;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_FullnamePtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Listing;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Listing;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ListingPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Media;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Media;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MediaPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Oembed;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Oembed;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_OembedPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Pager;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Pager;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PagerPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Post;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Post;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PostPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_PostId;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_PostId;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_PostIdPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_RedditVideo;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_RedditVideo;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_RedditVideoPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SecureMedia;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SecureMedia;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SecureMediaPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Subreddit;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Subreddit;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SubredditPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SubredditId;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SubredditId;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SubredditIdPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SubredditInfo;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SubredditInfo;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_SubredditInfoPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Url;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Url;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_UrlPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Flair redditApiModelPostAuthorInfoAutoAccessorGetFlair(
      {required AuthorInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 1)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostAuthorInfoAutoAccessorGetFlairConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostAuthorInfoAutoAccessorGetFlairConstMeta =>
          const TaskConstMeta(
            debugName: "AuthorInfo_auto_accessor_get_flair",
            argNames: ["that"],
          );

  @override
  String redditApiModelPostAuthorInfoAutoAccessorGetFullname(
      {required AuthorInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostAuthorInfoAutoAccessorGetFullnameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostAuthorInfoAutoAccessorGetFullnameConstMeta =>
          const TaskConstMeta(
            debugName: "AuthorInfo_auto_accessor_get_fullname",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostAuthorInfoAutoAccessorGetIsBlocked(
      {required AuthorInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostAuthorInfoAutoAccessorGetIsBlockedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostAuthorInfoAutoAccessorGetIsBlockedConstMeta =>
          const TaskConstMeta(
            debugName: "AuthorInfo_auto_accessor_get_is_blocked",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostAuthorInfoAutoAccessorGetPatreonFlair(
      {required AuthorInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostAuthorInfoAutoAccessorGetPatreonFlairConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostAuthorInfoAutoAccessorGetPatreonFlairConstMeta =>
          const TaskConstMeta(
            debugName: "AuthorInfo_auto_accessor_get_patreon_flair",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostAuthorInfoAutoAccessorGetPremium(
      {required AuthorInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 5)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostAuthorInfoAutoAccessorGetPremiumConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostAuthorInfoAutoAccessorGetPremiumConstMeta =>
          const TaskConstMeta(
            debugName: "AuthorInfo_auto_accessor_get_premium",
            argNames: ["that"],
          );

  @override
  String redditApiModelPostAuthorInfoAutoAccessorGetUsername(
      {required AuthorInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 6)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostAuthorInfoAutoAccessorGetUsernameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostAuthorInfoAutoAccessorGetUsernameConstMeta =>
          const TaskConstMeta(
            debugName: "AuthorInfo_auto_accessor_get_username",
            argNames: ["that"],
          );

  @override
  void redditApiModelPostAuthorInfoAutoAccessorSetFlair(
      {required AuthorInfo that, required Flair flair}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            flair, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 7)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostAuthorInfoAutoAccessorSetFlairConstMeta,
      argValues: [that, flair],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostAuthorInfoAutoAccessorSetFlairConstMeta =>
          const TaskConstMeta(
            debugName: "AuthorInfo_auto_accessor_set_flair",
            argNames: ["that", "flair"],
          );

  @override
  void redditApiModelPostAuthorInfoAutoAccessorSetFullname(
      {required AuthorInfo that, required String fullname}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            that, serializer);
        sse_encode_String(fullname, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 8)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostAuthorInfoAutoAccessorSetFullnameConstMeta,
      argValues: [that, fullname],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostAuthorInfoAutoAccessorSetFullnameConstMeta =>
          const TaskConstMeta(
            debugName: "AuthorInfo_auto_accessor_set_fullname",
            argNames: ["that", "fullname"],
          );

  @override
  void redditApiModelPostAuthorInfoAutoAccessorSetIsBlocked(
      {required AuthorInfo that, required bool isBlocked}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            that, serializer);
        sse_encode_bool(isBlocked, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 9)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostAuthorInfoAutoAccessorSetIsBlockedConstMeta,
      argValues: [that, isBlocked],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostAuthorInfoAutoAccessorSetIsBlockedConstMeta =>
          const TaskConstMeta(
            debugName: "AuthorInfo_auto_accessor_set_is_blocked",
            argNames: ["that", "isBlocked"],
          );

  @override
  void redditApiModelPostAuthorInfoAutoAccessorSetPatreonFlair(
      {required AuthorInfo that, required bool patreonFlair}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            that, serializer);
        sse_encode_bool(patreonFlair, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostAuthorInfoAutoAccessorSetPatreonFlairConstMeta,
      argValues: [that, patreonFlair],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostAuthorInfoAutoAccessorSetPatreonFlairConstMeta =>
          const TaskConstMeta(
            debugName: "AuthorInfo_auto_accessor_set_patreon_flair",
            argNames: ["that", "patreonFlair"],
          );

  @override
  void redditApiModelPostAuthorInfoAutoAccessorSetPremium(
      {required AuthorInfo that, required bool premium}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            that, serializer);
        sse_encode_bool(premium, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 11)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostAuthorInfoAutoAccessorSetPremiumConstMeta,
      argValues: [that, premium],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostAuthorInfoAutoAccessorSetPremiumConstMeta =>
          const TaskConstMeta(
            debugName: "AuthorInfo_auto_accessor_set_premium",
            argNames: ["that", "premium"],
          );

  @override
  void redditApiModelPostAuthorInfoAutoAccessorSetUsername(
      {required AuthorInfo that, required String username}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            that, serializer);
        sse_encode_String(username, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 12)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostAuthorInfoAutoAccessorSetUsernameConstMeta,
      argValues: [that, username],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostAuthorInfoAutoAccessorSetUsernameConstMeta =>
          const TaskConstMeta(
            debugName: "AuthorInfo_auto_accessor_set_username",
            argNames: ["that", "username"],
          );

  @override
  Future<AuthorInfo> redditApiModelPostAuthorInfoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostAuthorInfoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostAuthorInfoDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "AuthorInfo_default",
        argNames: [],
      );

  @override
  Future<void> redditApiClientClientAuthenticate(
      {required Client that, required String refreshToken}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_String(refreshToken, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientAuthenticateConstMeta,
      argValues: [that, refreshToken],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientAuthenticateConstMeta =>
      const TaskConstMeta(
        debugName: "Client_authenticate",
        argNames: ["that", "refreshToken"],
      );

  @override
  Future<Client> redditApiClientClientDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Client_default",
        argNames: [],
      );

  @override
  Future<Client> redditApiClientClientFromRefreshToken(
      {required String refreshToken}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(refreshToken, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientFromRefreshTokenConstMeta,
      argValues: [refreshToken],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientFromRefreshTokenConstMeta =>
      const TaskConstMeta(
        debugName: "Client_from_refresh_token",
        argNames: ["refreshToken"],
      );

  @override
  Future<UserInfo> redditApiClientClientLoggedUserInfo({required Client that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_user_info,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientLoggedUserInfoConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientLoggedUserInfoConstMeta =>
      const TaskConstMeta(
        debugName: "Client_logged_user_info",
        argNames: ["that"],
      );

  @override
  Future<List<Multi>> redditApiClientClientMultis({required Client that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_multi,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientMultisConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientMultisConstMeta =>
      const TaskConstMeta(
        debugName: "Client_multis",
        argNames: ["that"],
      );

  @override
  Future<Client> redditApiClientClientNewAnonymous() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientClientNewAnonymousConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientNewAnonymousConstMeta =>
      const TaskConstMeta(
        debugName: "Client_new_anonymous",
        argNames: [],
      );

  @override
  Future<void> redditApiClientClientSave(
      {required Client that, required Fullname thing}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            thing, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientSaveConstMeta,
      argValues: [that, thing],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientSaveConstMeta => const TaskConstMeta(
        debugName: "Client_save",
        argNames: ["that", "thing"],
      );

  @override
  Future<List<Subreddit>> redditApiClientClientSubsriptions(
      {required Client that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientSubsriptionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientSubsriptionsConstMeta =>
      const TaskConstMeta(
        debugName: "Client_subsriptions",
        argNames: ["that"],
      );

  @override
  Future<void> redditApiClientClientUnsave(
      {required Client that, required Fullname thing}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            thing, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientUnsaveConstMeta,
      argValues: [that, thing],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientUnsaveConstMeta =>
      const TaskConstMeta(
        debugName: "Client_unsave",
        argNames: ["that", "thing"],
      );

  @override
  Future<void> redditApiClientClientVote(
      {required Client that,
      required Fullname thing,
      required VoteDirection direction}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            thing, serializer);
        sse_encode_vote_direction(direction, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kRedditApiClientClientVoteConstMeta,
      argValues: [that, thing, direction],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientClientVoteConstMeta => const TaskConstMeta(
        debugName: "Client_vote",
        argNames: ["that", "thing", "direction"],
      );

  @override
  bool crateApiSimpleFeedStateGetDone({required FeedState that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleFeedStateGetDoneConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateGetDoneConstMeta =>
      const TaskConstMeta(
        debugName: "FeedState_get_done(dart_style=done)",
        argNames: ["that"],
      );

  @override
  Feed crateApiSimpleFeedStateGetFeed({required FeedState that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_feed,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleFeedStateGetFeedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateGetFeedConstMeta =>
      const TaskConstMeta(
        debugName: "FeedState_get_feed(dart_style=feed)",
        argNames: ["that"],
      );

  @override
  int crateApiSimpleFeedStateGetLength({required FeedState that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleFeedStateGetLengthConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateGetLengthConstMeta =>
      const TaskConstMeta(
        debugName: "FeedState_get_length(dart_style=length)",
        argNames: ["that"],
      );

  @override
  bool crateApiSimpleFeedStateGetLoading({required FeedState that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleFeedStateGetLoadingConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateGetLoadingConstMeta =>
      const TaskConstMeta(
        debugName: "FeedState_get_loading(dart_style=loading)",
        argNames: ["that"],
      );

  @override
  Sort crateApiSimpleFeedStateGetSort({required FeedState that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 28)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_sort,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleFeedStateGetSortConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateGetSortConstMeta =>
      const TaskConstMeta(
        debugName: "FeedState_get_sort(dart_style=sort)",
        argNames: ["that"],
      );

  @override
  String crateApiSimpleFeedStateGetSortString({required FeedState that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 29)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleFeedStateGetSortStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateGetSortStringConstMeta =>
      const TaskConstMeta(
        debugName: "FeedState_get_sort_string(dart_style=sort_string)",
        argNames: ["that"],
      );

  @override
  String crateApiSimpleFeedStateGetTitle({required FeedState that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 30)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleFeedStateGetTitleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateGetTitleConstMeta =>
      const TaskConstMeta(
        debugName: "FeedState_get_title(dart_style=title)",
        argNames: ["that"],
      );

  @override
  FeedState crateApiSimpleFeedStateNew(
      {required Feed feed, required Sort sort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_feed(feed, serializer);
        sse_encode_box_autoadd_sort(sort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 31)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleFeedStateNewConstMeta,
      argValues: [feed, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateNewConstMeta => const TaskConstMeta(
        debugName: "FeedState_new",
        argNames: ["feed", "sort"],
      );

  @override
  Future<bool> crateApiSimpleFeedStateNext({required FeedState that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiSimpleFeedStateNextConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateNextConstMeta =>
      const TaskConstMeta(
        debugName: "FeedState_next",
        argNames: ["that"],
      );

  @override
  Post? crateApiSimpleFeedStateNth({required FeedState that, required int n}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
            that, serializer);
        sse_encode_u_32(n, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 33)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleFeedStateNthConstMeta,
      argValues: [that, n],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateNthConstMeta => const TaskConstMeta(
        debugName: "FeedState_nth",
        argNames: ["that", "n"],
      );

  @override
  Future<void> crateApiSimpleFeedStateRefresh({required FeedState that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleFeedStateRefreshConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateRefreshConstMeta =>
      const TaskConstMeta(
        debugName: "FeedState_refresh",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiSimpleFeedStateSetFeed(
      {required FeedState that, required Feed feed}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
            that, serializer);
        sse_encode_box_autoadd_feed(feed, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleFeedStateSetFeedConstMeta,
      argValues: [that, feed],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateSetFeedConstMeta =>
      const TaskConstMeta(
        debugName: "FeedState_set_feed(dart_style=feed)",
        argNames: ["that", "feed"],
      );

  @override
  Future<void> crateApiSimpleFeedStateSetSort(
      {required FeedState that, required Sort sort}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
            that, serializer);
        sse_encode_box_autoadd_sort(sort, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleFeedStateSetSortConstMeta,
      argValues: [that, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleFeedStateSetSortConstMeta =>
      const TaskConstMeta(
        debugName: "FeedState_set_sort(dart_style=sort)",
        argNames: ["that", "sort"],
      );

  @override
  Future<FeedStream> redditApiModelFeedFeedStreamNew(
      {required Client client, required Feed feed, required Sort sort}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
            client, serializer);
        sse_encode_box_autoadd_feed(feed, serializer);
        sse_encode_box_autoadd_sort(sort, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFeedFeedStreamNewConstMeta,
      argValues: [client, feed, sort],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFeedFeedStreamNewConstMeta =>
      const TaskConstMeta(
        debugName: "FeedStream_new",
        argNames: ["client", "feed", "sort"],
      );

  @override
  String? redditApiModelFlairFlairAutoAccessorGetCssClass(
      {required Flair that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairAutoAccessorGetCssClassConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFlairFlairAutoAccessorGetCssClassConstMeta =>
      const TaskConstMeta(
        debugName: "Flair_auto_accessor_get_css_class",
        argNames: ["that"],
      );

  @override
  String? redditApiModelFlairFlairAutoAccessorGetFlairType(
      {required Flair that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairAutoAccessorGetFlairTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelFlairFlairAutoAccessorGetFlairTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Flair_auto_accessor_get_flair_type",
            argNames: ["that"],
          );

  @override
  String? redditApiModelFlairFlairAutoAccessorGetPosition(
      {required Flair that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 40)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairAutoAccessorGetPositionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFlairFlairAutoAccessorGetPositionConstMeta =>
      const TaskConstMeta(
        debugName: "Flair_auto_accessor_get_position",
        argNames: ["that"],
      );

  @override
  List<Map<String, String>> redditApiModelFlairFlairAutoAccessorGetRichtext(
      {required Flair that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 41)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_Map_String_String_None,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairAutoAccessorGetRichtextConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFlairFlairAutoAccessorGetRichtextConstMeta =>
      const TaskConstMeta(
        debugName: "Flair_auto_accessor_get_richtext",
        argNames: ["that"],
      );

  @override
  String? redditApiModelFlairFlairAutoAccessorGetTemplateId(
      {required Flair that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 42)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairAutoAccessorGetTemplateIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelFlairFlairAutoAccessorGetTemplateIdConstMeta =>
          const TaskConstMeta(
            debugName: "Flair_auto_accessor_get_template_id",
            argNames: ["that"],
          );

  @override
  String? redditApiModelFlairFlairAutoAccessorGetText({required Flair that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 43)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairAutoAccessorGetTextConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFlairFlairAutoAccessorGetTextConstMeta =>
      const TaskConstMeta(
        debugName: "Flair_auto_accessor_get_text",
        argNames: ["that"],
      );

  @override
  void redditApiModelFlairFlairAutoAccessorSetCssClass(
      {required Flair that, String? cssClass}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            that, serializer);
        sse_encode_opt_String(cssClass, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 44)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairAutoAccessorSetCssClassConstMeta,
      argValues: [that, cssClass],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFlairFlairAutoAccessorSetCssClassConstMeta =>
      const TaskConstMeta(
        debugName: "Flair_auto_accessor_set_css_class",
        argNames: ["that", "cssClass"],
      );

  @override
  void redditApiModelFlairFlairAutoAccessorSetFlairType(
      {required Flair that, String? flairType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            that, serializer);
        sse_encode_opt_String(flairType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 45)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairAutoAccessorSetFlairTypeConstMeta,
      argValues: [that, flairType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelFlairFlairAutoAccessorSetFlairTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Flair_auto_accessor_set_flair_type",
            argNames: ["that", "flairType"],
          );

  @override
  void redditApiModelFlairFlairAutoAccessorSetPosition(
      {required Flair that, String? position}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            that, serializer);
        sse_encode_opt_String(position, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 46)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairAutoAccessorSetPositionConstMeta,
      argValues: [that, position],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFlairFlairAutoAccessorSetPositionConstMeta =>
      const TaskConstMeta(
        debugName: "Flair_auto_accessor_set_position",
        argNames: ["that", "position"],
      );

  @override
  void redditApiModelFlairFlairAutoAccessorSetRichtext(
      {required Flair that, required List<Map<String, String>> richtext}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            that, serializer);
        sse_encode_list_Map_String_String_None(richtext, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 47)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairAutoAccessorSetRichtextConstMeta,
      argValues: [that, richtext],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFlairFlairAutoAccessorSetRichtextConstMeta =>
      const TaskConstMeta(
        debugName: "Flair_auto_accessor_set_richtext",
        argNames: ["that", "richtext"],
      );

  @override
  void redditApiModelFlairFlairAutoAccessorSetTemplateId(
      {required Flair that, String? templateId}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            that, serializer);
        sse_encode_opt_String(templateId, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 48)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairAutoAccessorSetTemplateIdConstMeta,
      argValues: [that, templateId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelFlairFlairAutoAccessorSetTemplateIdConstMeta =>
          const TaskConstMeta(
            debugName: "Flair_auto_accessor_set_template_id",
            argNames: ["that", "templateId"],
          );

  @override
  void redditApiModelFlairFlairAutoAccessorSetText(
      {required Flair that, String? text}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            that, serializer);
        sse_encode_opt_String(text, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 49)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairAutoAccessorSetTextConstMeta,
      argValues: [that, text],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFlairFlairAutoAccessorSetTextConstMeta =>
      const TaskConstMeta(
        debugName: "Flair_auto_accessor_set_text",
        argNames: ["that", "text"],
      );

  @override
  Future<Flair> redditApiModelFlairFlairDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 50, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFlairFlairDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFlairFlairDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Flair_default",
        argNames: [],
      );

  @override
  Future<Fullname> redditApiModelFullnameDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 51, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFullnameDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFullnameDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Fullname_default",
        argNames: [],
      );

  @override
  String? redditApiModelListingAutoAccessorGetAfter({required Listing that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 52)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorGetAfterConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorGetAfterConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_get_after",
        argNames: ["that"],
      );

  @override
  String? redditApiModelListingAutoAccessorGetBefore({required Listing that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 53)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorGetBeforeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorGetBeforeConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_get_before",
        argNames: ["that"],
      );

  @override
  List<Thing> redditApiModelListingAutoAccessorGetChildren(
      {required Listing that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 54)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_thing,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorGetChildrenConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorGetChildrenConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_get_children",
        argNames: ["that"],
      );

  @override
  BigInt redditApiModelListingAutoAccessorGetDist({required Listing that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 55)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorGetDistConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorGetDistConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_get_dist",
        argNames: ["that"],
      );

  @override
  String? redditApiModelListingAutoAccessorGetModhash({required Listing that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 56)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorGetModhashConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorGetModhashConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_get_modhash",
        argNames: ["that"],
      );

  @override
  void redditApiModelListingAutoAccessorSetAfter(
      {required Listing that, String? after}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        sse_encode_opt_String(after, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 57)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorSetAfterConstMeta,
      argValues: [that, after],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorSetAfterConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_set_after",
        argNames: ["that", "after"],
      );

  @override
  void redditApiModelListingAutoAccessorSetBefore(
      {required Listing that, String? before}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        sse_encode_opt_String(before, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 58)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorSetBeforeConstMeta,
      argValues: [that, before],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorSetBeforeConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_set_before",
        argNames: ["that", "before"],
      );

  @override
  void redditApiModelListingAutoAccessorSetChildren(
      {required Listing that, required List<Thing> children}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        sse_encode_list_thing(children, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 59)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorSetChildrenConstMeta,
      argValues: [that, children],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorSetChildrenConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_set_children",
        argNames: ["that", "children"],
      );

  @override
  void redditApiModelListingAutoAccessorSetDist(
      {required Listing that, required BigInt dist}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        sse_encode_u_64(dist, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 60)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorSetDistConstMeta,
      argValues: [that, dist],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorSetDistConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_set_dist",
        argNames: ["that", "dist"],
      );

  @override
  void redditApiModelListingAutoAccessorSetModhash(
      {required Listing that, String? modhash}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            that, serializer);
        sse_encode_opt_String(modhash, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 61)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingAutoAccessorSetModhashConstMeta,
      argValues: [that, modhash],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingAutoAccessorSetModhashConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_auto_accessor_set_modhash",
        argNames: ["that", "modhash"],
      );

  @override
  Future<Listing> redditApiModelListingDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 62, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelListingDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelListingDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Listing_default",
        argNames: [],
      );

  @override
  String redditApiModelPostOembedAutoAccessorGetAuthorName(
      {required Oembed that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 63)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorGetAuthorNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostOembedAutoAccessorGetAuthorNameConstMeta =>
          const TaskConstMeta(
            debugName: "Oembed_auto_accessor_get_author_name",
            argNames: ["that"],
          );

  @override
  String redditApiModelPostOembedAutoAccessorGetAuthorUrl(
      {required Oembed that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 64)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorGetAuthorUrlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostOembedAutoAccessorGetAuthorUrlConstMeta =>
          const TaskConstMeta(
            debugName: "Oembed_auto_accessor_get_author_url",
            argNames: ["that"],
          );

  @override
  PlatformInt64 redditApiModelPostOembedAutoAccessorGetHeight(
      {required Oembed that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 65)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorGetHeightConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostOembedAutoAccessorGetHeightConstMeta =>
      const TaskConstMeta(
        debugName: "Oembed_auto_accessor_get_height",
        argNames: ["that"],
      );

  @override
  String redditApiModelPostOembedAutoAccessorGetHtml({required Oembed that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 66)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorGetHtmlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostOembedAutoAccessorGetHtmlConstMeta =>
      const TaskConstMeta(
        debugName: "Oembed_auto_accessor_get_html",
        argNames: ["that"],
      );

  @override
  String redditApiModelPostOembedAutoAccessorGetProviderName(
      {required Oembed that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 67)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorGetProviderNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostOembedAutoAccessorGetProviderNameConstMeta =>
          const TaskConstMeta(
            debugName: "Oembed_auto_accessor_get_provider_name",
            argNames: ["that"],
          );

  @override
  String redditApiModelPostOembedAutoAccessorGetProviderUrl(
      {required Oembed that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 68)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorGetProviderUrlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostOembedAutoAccessorGetProviderUrlConstMeta =>
          const TaskConstMeta(
            debugName: "Oembed_auto_accessor_get_provider_url",
            argNames: ["that"],
          );

  @override
  String redditApiModelPostOembedAutoAccessorGetTitle({required Oembed that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 69)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorGetTitleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostOembedAutoAccessorGetTitleConstMeta =>
      const TaskConstMeta(
        debugName: "Oembed_auto_accessor_get_title",
        argNames: ["that"],
      );

  @override
  String redditApiModelPostOembedAutoAccessorGetTypeField(
      {required Oembed that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 70)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorGetTypeFieldConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostOembedAutoAccessorGetTypeFieldConstMeta =>
          const TaskConstMeta(
            debugName: "Oembed_auto_accessor_get_type_field",
            argNames: ["that"],
          );

  @override
  String redditApiModelPostOembedAutoAccessorGetVersion(
      {required Oembed that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 71)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorGetVersionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostOembedAutoAccessorGetVersionConstMeta =>
      const TaskConstMeta(
        debugName: "Oembed_auto_accessor_get_version",
        argNames: ["that"],
      );

  @override
  PlatformInt64 redditApiModelPostOembedAutoAccessorGetWidth(
      {required Oembed that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 72)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorGetWidthConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostOembedAutoAccessorGetWidthConstMeta =>
      const TaskConstMeta(
        debugName: "Oembed_auto_accessor_get_width",
        argNames: ["that"],
      );

  @override
  void redditApiModelPostOembedAutoAccessorSetAuthorName(
      {required Oembed that, required String authorName}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        sse_encode_String(authorName, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 73)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorSetAuthorNameConstMeta,
      argValues: [that, authorName],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostOembedAutoAccessorSetAuthorNameConstMeta =>
          const TaskConstMeta(
            debugName: "Oembed_auto_accessor_set_author_name",
            argNames: ["that", "authorName"],
          );

  @override
  void redditApiModelPostOembedAutoAccessorSetAuthorUrl(
      {required Oembed that, required String authorUrl}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        sse_encode_String(authorUrl, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 74)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorSetAuthorUrlConstMeta,
      argValues: [that, authorUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostOembedAutoAccessorSetAuthorUrlConstMeta =>
          const TaskConstMeta(
            debugName: "Oembed_auto_accessor_set_author_url",
            argNames: ["that", "authorUrl"],
          );

  @override
  void redditApiModelPostOembedAutoAccessorSetHeight(
      {required Oembed that, required PlatformInt64 height}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        sse_encode_i_64(height, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 75)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorSetHeightConstMeta,
      argValues: [that, height],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostOembedAutoAccessorSetHeightConstMeta =>
      const TaskConstMeta(
        debugName: "Oembed_auto_accessor_set_height",
        argNames: ["that", "height"],
      );

  @override
  void redditApiModelPostOembedAutoAccessorSetHtml(
      {required Oembed that, required String html}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        sse_encode_String(html, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 76)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorSetHtmlConstMeta,
      argValues: [that, html],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostOembedAutoAccessorSetHtmlConstMeta =>
      const TaskConstMeta(
        debugName: "Oembed_auto_accessor_set_html",
        argNames: ["that", "html"],
      );

  @override
  void redditApiModelPostOembedAutoAccessorSetProviderName(
      {required Oembed that, required String providerName}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        sse_encode_String(providerName, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 77)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorSetProviderNameConstMeta,
      argValues: [that, providerName],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostOembedAutoAccessorSetProviderNameConstMeta =>
          const TaskConstMeta(
            debugName: "Oembed_auto_accessor_set_provider_name",
            argNames: ["that", "providerName"],
          );

  @override
  void redditApiModelPostOembedAutoAccessorSetProviderUrl(
      {required Oembed that, required String providerUrl}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        sse_encode_String(providerUrl, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 78)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorSetProviderUrlConstMeta,
      argValues: [that, providerUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostOembedAutoAccessorSetProviderUrlConstMeta =>
          const TaskConstMeta(
            debugName: "Oembed_auto_accessor_set_provider_url",
            argNames: ["that", "providerUrl"],
          );

  @override
  void redditApiModelPostOembedAutoAccessorSetTitle(
      {required Oembed that, required String title}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        sse_encode_String(title, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 79)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorSetTitleConstMeta,
      argValues: [that, title],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostOembedAutoAccessorSetTitleConstMeta =>
      const TaskConstMeta(
        debugName: "Oembed_auto_accessor_set_title",
        argNames: ["that", "title"],
      );

  @override
  void redditApiModelPostOembedAutoAccessorSetTypeField(
      {required Oembed that, required String typeField}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        sse_encode_String(typeField, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 80)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorSetTypeFieldConstMeta,
      argValues: [that, typeField],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostOembedAutoAccessorSetTypeFieldConstMeta =>
          const TaskConstMeta(
            debugName: "Oembed_auto_accessor_set_type_field",
            argNames: ["that", "typeField"],
          );

  @override
  void redditApiModelPostOembedAutoAccessorSetVersion(
      {required Oembed that, required String version}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        sse_encode_String(version, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 81)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorSetVersionConstMeta,
      argValues: [that, version],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostOembedAutoAccessorSetVersionConstMeta =>
      const TaskConstMeta(
        debugName: "Oembed_auto_accessor_set_version",
        argNames: ["that", "version"],
      );

  @override
  void redditApiModelPostOembedAutoAccessorSetWidth(
      {required Oembed that, required PlatformInt64 width}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
            that, serializer);
        sse_encode_i_64(width, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 82)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedAutoAccessorSetWidthConstMeta,
      argValues: [that, width],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostOembedAutoAccessorSetWidthConstMeta =>
      const TaskConstMeta(
        debugName: "Oembed_auto_accessor_set_width",
        argNames: ["that", "width"],
      );

  @override
  Future<Oembed> redditApiModelPostOembedDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 83, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostOembedDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostOembedDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Oembed_default",
        argNames: [],
      );

  @override
  Future<Url> redditApiClientPagerAddToUrl(
      {required Pager that, required Url url}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
            url, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 84, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientPagerAddToUrlConstMeta,
      argValues: [that, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientPagerAddToUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Pager_add_to_url",
        argNames: ["that", "url"],
      );

  @override
  Future<void> redditApiClientPagerAfter({required Pager that, String? after}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
            that, serializer);
        sse_encode_opt_String(after, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 85, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientPagerAfterConstMeta,
      argValues: [that, after],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientPagerAfterConstMeta => const TaskConstMeta(
        debugName: "Pager_after",
        argNames: ["that", "after"],
      );

  @override
  Future<void> redditApiClientPagerBefore(
      {required Pager that, String? before}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
            that, serializer);
        sse_encode_opt_String(before, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 86, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientPagerBeforeConstMeta,
      argValues: [that, before],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientPagerBeforeConstMeta => const TaskConstMeta(
        debugName: "Pager_before",
        argNames: ["that", "before"],
      );

  @override
  Future<Pager> redditApiClientPagerDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 87, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiClientPagerDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiClientPagerDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Pager_default",
        argNames: [],
      );

  @override
  Future<PostId> redditApiModelPostPostIdDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 88, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostIdDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostIdDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "PostId_default",
        argNames: [],
      );

  @override
  List<String?> redditApiModelPostPostAutoAccessorGetAllAwardings(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 89)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetAllAwardingsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetAllAwardingsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_all_awardings",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostPostAutoAccessorGetAllowLiveComments(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 90)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorGetAllowLiveCommentsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetAllowLiveCommentsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_allow_live_comments",
            argNames: ["that"],
          );

  @override
  double? redditApiModelPostPostAutoAccessorGetApprovedAtUtc(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 91)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_f_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetApprovedAtUtcConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetApprovedAtUtcConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_approved_at_utc",
            argNames: ["that"],
          );

  @override
  String? redditApiModelPostPostAutoAccessorGetApprovedBy(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 92)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetApprovedByConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetApprovedByConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_approved_by",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetArchived({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 93)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetArchivedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetArchivedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_archived",
        argNames: ["that"],
      );

  @override
  AuthorInfo? redditApiModelPostPostAutoAccessorGetAuthor(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 94)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetAuthorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetAuthorConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_author",
        argNames: ["that"],
      );

  @override
  List<String?> redditApiModelPostPostAutoAccessorGetAwarders(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 95)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetAwardersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetAwardersConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_awarders",
        argNames: ["that"],
      );

  @override
  double? redditApiModelPostPostAutoAccessorGetBannedAtUtc(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 96)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_f_32,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetBannedAtUtcConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetBannedAtUtcConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_banned_at_utc",
            argNames: ["that"],
          );

  @override
  String? redditApiModelPostPostAutoAccessorGetBannedBy({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 97)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetBannedByConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetBannedByConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_banned_by",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetCanGild({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 98)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetCanGildConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetCanGildConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_can_gild",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetCanModPost({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 99)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetCanModPostConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetCanModPostConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_can_mod_post",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostAutoAccessorGetCategory({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 100)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetCategoryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetCategoryConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_category",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetClicked({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 101)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetClickedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetClickedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_clicked",
        argNames: ["that"],
      );

  @override
  List<String> redditApiModelPostPostAutoAccessorGetContentCategories(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 102)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorGetContentCategoriesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetContentCategoriesConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_content_categories",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostPostAutoAccessorGetContestMode({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 103)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetContestModeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetContestModeConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_contest_mode",
            argNames: ["that"],
          );

  @override
  DateTime redditApiModelPostPostAutoAccessorGetCreated({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 104)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Chrono_Local,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetCreatedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetCreatedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_created",
        argNames: ["that"],
      );

  @override
  DateTime redditApiModelPostPostAutoAccessorGetCreatedUtc(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 105)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Chrono_Utc,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetCreatedUtcConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetCreatedUtcConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_created_utc",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostAutoAccessorGetDiscussionType(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 106)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetDiscussionTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetDiscussionTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_discussion_type",
            argNames: ["that"],
          );

  @override
  String? redditApiModelPostPostAutoAccessorGetDistinguished(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 107)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetDistinguishedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetDistinguishedConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_distinguished",
            argNames: ["that"],
          );

  @override
  String redditApiModelPostPostAutoAccessorGetDomain({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 108)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetDomainConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetDomainConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_domain",
        argNames: ["that"],
      );

  @override
  PlatformInt64 redditApiModelPostPostAutoAccessorGetDowns(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 109)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetDownsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetDownsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_downs",
        argNames: ["that"],
      );

  @override
  double? redditApiModelPostPostAutoAccessorGetEdited({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 110)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_f_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetEditedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetEditedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_edited",
        argNames: ["that"],
      );

  @override
  Gallery? redditApiModelPostPostAutoAccessorGetGallery({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 111)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_gallery,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetGalleryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetGalleryConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_gallery",
        argNames: ["that"],
      );

  @override
  PlatformInt64 redditApiModelPostPostAutoAccessorGetGilded(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 112)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetGildedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetGildedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_gilded",
        argNames: ["that"],
      );

  @override
  Gildings redditApiModelPostPostAutoAccessorGetGildings({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 113)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_gildings,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetGildingsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetGildingsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_gildings",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetHidden({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 114)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetHiddenConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetHiddenConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_hidden",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetHideScore({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 115)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetHideScoreConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetHideScoreConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_hide_score",
        argNames: ["that"],
      );

  @override
  PostId redditApiModelPostPostAutoAccessorGetId({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 116)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetIdConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_id",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetIsCreatedFromAdsUi(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 117)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorGetIsCreatedFromAdsUiConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetIsCreatedFromAdsUiConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_is_created_from_ads_ui",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostPostAutoAccessorGetIsCrosspostable(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 118)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetIsCrosspostableConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetIsCrosspostableConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_is_crosspostable",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostPostAutoAccessorGetIsMeta({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 119)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetIsMetaConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetIsMetaConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_is_meta",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetIsOriginalContent(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 120)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorGetIsOriginalContentConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetIsOriginalContentConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_is_original_content",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostPostAutoAccessorGetIsRedditMediaDomain(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 121)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorGetIsRedditMediaDomainConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetIsRedditMediaDomainConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_is_reddit_media_domain",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostPostAutoAccessorGetIsRobotIndexable(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 122)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorGetIsRobotIndexableConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetIsRobotIndexableConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_is_robot_indexable",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostPostAutoAccessorGetIsSelf({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 123)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetIsSelfConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetIsSelfConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_is_self",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetIsVideo({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 124)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetIsVideoConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetIsVideoConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_is_video",
        argNames: ["that"],
      );

  @override
  bool? redditApiModelPostPostAutoAccessorGetLikes({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 125)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetLikesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetLikesConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_likes",
        argNames: ["that"],
      );

  @override
  Flair redditApiModelPostPostAutoAccessorGetLinkFlair({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 126)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetLinkFlairConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetLinkFlairConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_link_flair",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetLocked({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 127)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetLockedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetLockedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_locked",
        argNames: ["that"],
      );

  @override
  Media? redditApiModelPostPostAutoAccessorGetMedia({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 128)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetMediaConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetMediaConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_media",
        argNames: ["that"],
      );

  @override
  MediaEmbed? redditApiModelPostPostAutoAccessorGetMediaEmbed(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 129)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_media_embed,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetMediaEmbedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetMediaEmbedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_media_embed",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetMediaOnly({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 130)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetMediaOnlyConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetMediaOnlyConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_media_only",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostAutoAccessorGetModNote({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 131)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetModNoteConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetModNoteConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_mod_note",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostAutoAccessorGetModReasonBy(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 132)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetModReasonByConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetModReasonByConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_mod_reason_by",
            argNames: ["that"],
          );

  @override
  String? redditApiModelPostPostAutoAccessorGetModReasonTitle(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 133)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetModReasonTitleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetModReasonTitleConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_mod_reason_title",
            argNames: ["that"],
          );

  @override
  List<String?> redditApiModelPostPostAutoAccessorGetModReports(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 134)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetModReportsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetModReportsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_mod_reports",
        argNames: ["that"],
      );

  @override
  Fullname redditApiModelPostPostAutoAccessorGetName({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 135)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetNameConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_name",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetNoFollow({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 136)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetNoFollowConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetNoFollowConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_no_follow",
        argNames: ["that"],
      );

  @override
  PlatformInt64 redditApiModelPostPostAutoAccessorGetNumComments(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 137)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetNumCommentsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetNumCommentsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_num_comments",
            argNames: ["that"],
          );

  @override
  PlatformInt64? redditApiModelPostPostAutoAccessorGetNumCrossposts(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 138)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_i_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetNumCrosspostsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetNumCrosspostsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_num_crossposts",
            argNames: ["that"],
          );

  @override
  BigInt? redditApiModelPostPostAutoAccessorGetNumDuplicates(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 139)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetNumDuplicatesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetNumDuplicatesConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_num_duplicates",
            argNames: ["that"],
          );

  @override
  String? redditApiModelPostPostAutoAccessorGetNumReports(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 140)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetNumReportsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetNumReportsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_num_reports",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetOver18({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 141)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetOver18ConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetOver18ConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_over_18",
        argNames: ["that"],
      );

  @override
  String redditApiModelPostPostAutoAccessorGetPermalink({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 142)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetPermalinkConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetPermalinkConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_permalink",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetPinned({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 143)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetPinnedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetPinnedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_pinned",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostAutoAccessorGetPostHint({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 144)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetPostHintConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetPostHintConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_post_hint",
        argNames: ["that"],
      );

  @override
  Preview? redditApiModelPostPostAutoAccessorGetPreview({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 145)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_preview,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetPreviewConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetPreviewConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_preview",
        argNames: ["that"],
      );

  @override
  PlatformInt64? redditApiModelPostPostAutoAccessorGetPwls(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 146)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_i_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetPwlsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetPwlsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_pwls",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetQuarantine({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 147)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetQuarantineConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetQuarantineConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_quarantine",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostAutoAccessorGetRemovalReason(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 148)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetRemovalReasonConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetRemovalReasonConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_removal_reason",
            argNames: ["that"],
          );

  @override
  String? redditApiModelPostPostAutoAccessorGetRemovedBy({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 149)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetRemovedByConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetRemovedByConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_removed_by",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostAutoAccessorGetRemovedByCategory(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 150)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorGetRemovedByCategoryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetRemovedByCategoryConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_removed_by_category",
            argNames: ["that"],
          );

  @override
  String? redditApiModelPostPostAutoAccessorGetReportReasons(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 151)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetReportReasonsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetReportReasonsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_report_reasons",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostPostAutoAccessorGetSaved({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 152)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetSavedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetSavedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_saved",
        argNames: ["that"],
      );

  @override
  PlatformInt64 redditApiModelPostPostAutoAccessorGetScore(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 153)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetScoreConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetScoreConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_score",
        argNames: ["that"],
      );

  @override
  SecureMedia? redditApiModelPostPostAutoAccessorGetSecureMedia(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 154)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetSecureMediaConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetSecureMediaConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_secure_media",
            argNames: ["that"],
          );

  @override
  SecureMediaEmbed? redditApiModelPostPostAutoAccessorGetSecureMediaEmbed(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 155)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_secure_media_embed,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorGetSecureMediaEmbedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetSecureMediaEmbedConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_secure_media_embed",
            argNames: ["that"],
          );

  @override
  String? redditApiModelPostPostAutoAccessorGetSelftext({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 156)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetSelftextConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetSelftextConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_selftext",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostAutoAccessorGetSelftextHtml(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 157)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetSelftextHtmlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetSelftextHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_selftext_html",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostPostAutoAccessorGetSendReplies({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 158)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetSendRepliesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetSendRepliesConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_send_replies",
            argNames: ["that"],
          );

  @override
  bool redditApiModelPostPostAutoAccessorGetSpoiler({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 159)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetSpoilerConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetSpoilerConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_spoiler",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetStickied({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 160)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetStickiedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetStickiedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_stickied",
        argNames: ["that"],
      );

  @override
  SubredditInfo redditApiModelPostPostAutoAccessorGetSubreddit(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 161)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetSubredditConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetSubredditConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_subreddit",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostAutoAccessorGetSuggestedSort(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 162)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetSuggestedSortConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetSuggestedSortConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_suggested_sort",
            argNames: ["that"],
          );

  @override
  String redditApiModelPostPostAutoAccessorGetTitle({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 163)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetTitleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetTitleConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_title",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostAutoAccessorGetTopAwardedType(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 164)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetTopAwardedTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetTopAwardedTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_top_awarded_type",
            argNames: ["that"],
          );

  @override
  PlatformInt64? redditApiModelPostPostAutoAccessorGetTotalAwardsReceived(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 165)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_i_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorGetTotalAwardsReceivedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetTotalAwardsReceivedConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_total_awards_received",
            argNames: ["that"],
          );

  @override
  List<String?> redditApiModelPostPostAutoAccessorGetTreatmentTags(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 166)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetTreatmentTagsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetTreatmentTagsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_treatment_tags",
            argNames: ["that"],
          );

  @override
  PlatformInt64 redditApiModelPostPostAutoAccessorGetUps({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 167)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetUpsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetUpsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_ups",
        argNames: ["that"],
      );

  @override
  double redditApiModelPostPostAutoAccessorGetUpvoteRatio(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 168)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetUpvoteRatioConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetUpvoteRatioConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_upvote_ratio",
            argNames: ["that"],
          );

  @override
  String redditApiModelPostPostAutoAccessorGetUrl({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 169)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetUrlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_url",
        argNames: ["that"],
      );

  @override
  String? redditApiModelPostPostAutoAccessorGetUrlOverriddenByDest(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 170)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorGetUrlOverriddenByDestConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetUrlOverriddenByDestConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_url_overridden_by_dest",
            argNames: ["that"],
          );

  @override
  List<String?> redditApiModelPostPostAutoAccessorGetUserReports(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 171)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetUserReportsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorGetUserReportsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_get_user_reports",
            argNames: ["that"],
          );

  @override
  String? redditApiModelPostPostAutoAccessorGetViewCount({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 172)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetViewCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetViewCountConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_view_count",
        argNames: ["that"],
      );

  @override
  bool redditApiModelPostPostAutoAccessorGetVisited({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 173)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetVisitedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetVisitedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_visited",
        argNames: ["that"],
      );

  @override
  PlatformInt64? redditApiModelPostPostAutoAccessorGetWls(
      {required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 174)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_i_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorGetWlsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorGetWlsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_get_wls",
        argNames: ["that"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetAllAwardings(
      {required Post that, required List<String?> allAwardings}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_list_opt_String(allAwardings, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 175)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetAllAwardingsConstMeta,
      argValues: [that, allAwardings],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetAllAwardingsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_all_awardings",
            argNames: ["that", "allAwardings"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetAllowLiveComments(
      {required Post that, required bool allowLiveComments}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(allowLiveComments, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 176)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorSetAllowLiveCommentsConstMeta,
      argValues: [that, allowLiveComments],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetAllowLiveCommentsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_allow_live_comments",
            argNames: ["that", "allowLiveComments"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetApprovedAtUtc(
      {required Post that, double? approvedAtUtc}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_f_32(approvedAtUtc, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 177)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetApprovedAtUtcConstMeta,
      argValues: [that, approvedAtUtc],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetApprovedAtUtcConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_approved_at_utc",
            argNames: ["that", "approvedAtUtc"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetApprovedBy(
      {required Post that, String? approvedBy}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(approvedBy, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 178)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetApprovedByConstMeta,
      argValues: [that, approvedBy],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetApprovedByConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_approved_by",
        argNames: ["that", "approvedBy"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetArchived(
      {required Post that, required bool archived}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(archived, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 179)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetArchivedConstMeta,
      argValues: [that, archived],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetArchivedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_archived",
        argNames: ["that", "archived"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetAuthor(
      {required Post that, AuthorInfo? author}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            author, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 180)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetAuthorConstMeta,
      argValues: [that, author],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetAuthorConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_author",
        argNames: ["that", "author"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetAwarders(
      {required Post that, required List<String?> awarders}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_list_opt_String(awarders, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 181)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetAwardersConstMeta,
      argValues: [that, awarders],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetAwardersConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_awarders",
        argNames: ["that", "awarders"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetBannedAtUtc(
      {required Post that, double? bannedAtUtc}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_f_32(bannedAtUtc, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 182)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetBannedAtUtcConstMeta,
      argValues: [that, bannedAtUtc],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetBannedAtUtcConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_banned_at_utc",
            argNames: ["that", "bannedAtUtc"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetBannedBy(
      {required Post that, String? bannedBy}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(bannedBy, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 183)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetBannedByConstMeta,
      argValues: [that, bannedBy],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetBannedByConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_banned_by",
        argNames: ["that", "bannedBy"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetCanGild(
      {required Post that, required bool canGild}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(canGild, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 184)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetCanGildConstMeta,
      argValues: [that, canGild],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetCanGildConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_can_gild",
        argNames: ["that", "canGild"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetCanModPost(
      {required Post that, required bool canModPost}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(canModPost, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 185)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetCanModPostConstMeta,
      argValues: [that, canModPost],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetCanModPostConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_can_mod_post",
        argNames: ["that", "canModPost"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetCategory(
      {required Post that, String? category}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(category, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 186)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetCategoryConstMeta,
      argValues: [that, category],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetCategoryConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_category",
        argNames: ["that", "category"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetClicked(
      {required Post that, required bool clicked}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(clicked, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 187)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetClickedConstMeta,
      argValues: [that, clicked],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetClickedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_clicked",
        argNames: ["that", "clicked"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetContentCategories(
      {required Post that, required List<String> contentCategories}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_list_String(contentCategories, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 188)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorSetContentCategoriesConstMeta,
      argValues: [that, contentCategories],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetContentCategoriesConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_content_categories",
            argNames: ["that", "contentCategories"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetContestMode(
      {required Post that, required bool contestMode}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(contestMode, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 189)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetContestModeConstMeta,
      argValues: [that, contestMode],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetContestModeConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_contest_mode",
            argNames: ["that", "contestMode"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetCreated(
      {required Post that, required DateTime created}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_Chrono_Local(created, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 190)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetCreatedConstMeta,
      argValues: [that, created],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetCreatedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_created",
        argNames: ["that", "created"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetCreatedUtc(
      {required Post that, required DateTime createdUtc}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_Chrono_Utc(createdUtc, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 191)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetCreatedUtcConstMeta,
      argValues: [that, createdUtc],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetCreatedUtcConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_created_utc",
        argNames: ["that", "createdUtc"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetDiscussionType(
      {required Post that, String? discussionType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(discussionType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 192)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetDiscussionTypeConstMeta,
      argValues: [that, discussionType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetDiscussionTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_discussion_type",
            argNames: ["that", "discussionType"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetDistinguished(
      {required Post that, String? distinguished}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(distinguished, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 193)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetDistinguishedConstMeta,
      argValues: [that, distinguished],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetDistinguishedConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_distinguished",
            argNames: ["that", "distinguished"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetDomain(
      {required Post that, required String domain}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_String(domain, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 194)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetDomainConstMeta,
      argValues: [that, domain],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetDomainConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_domain",
        argNames: ["that", "domain"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetDowns(
      {required Post that, required PlatformInt64 downs}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_i_64(downs, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 195)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetDownsConstMeta,
      argValues: [that, downs],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetDownsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_downs",
        argNames: ["that", "downs"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetEdited(
      {required Post that, double? edited}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_f_64(edited, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 196)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetEditedConstMeta,
      argValues: [that, edited],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetEditedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_edited",
        argNames: ["that", "edited"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetGallery(
      {required Post that, Gallery? gallery}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_gallery(gallery, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 197)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetGalleryConstMeta,
      argValues: [that, gallery],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetGalleryConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_gallery",
        argNames: ["that", "gallery"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetGilded(
      {required Post that, required PlatformInt64 gilded}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_i_64(gilded, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 198)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetGildedConstMeta,
      argValues: [that, gilded],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetGildedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_gilded",
        argNames: ["that", "gilded"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetGildings(
      {required Post that, required Gildings gildings}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_gildings(gildings, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 199)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetGildingsConstMeta,
      argValues: [that, gildings],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetGildingsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_gildings",
        argNames: ["that", "gildings"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetHidden(
      {required Post that, required bool hidden}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(hidden, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 200)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetHiddenConstMeta,
      argValues: [that, hidden],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetHiddenConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_hidden",
        argNames: ["that", "hidden"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetHideScore(
      {required Post that, required bool hideScore}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(hideScore, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 201)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetHideScoreConstMeta,
      argValues: [that, hideScore],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetHideScoreConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_hide_score",
        argNames: ["that", "hideScore"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetId(
      {required Post that, required PostId id}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
            id, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 202)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetIdConstMeta,
      argValues: [that, id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetIdConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_id",
        argNames: ["that", "id"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetIsCreatedFromAdsUi(
      {required Post that, required bool isCreatedFromAdsUi}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(isCreatedFromAdsUi, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 203)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorSetIsCreatedFromAdsUiConstMeta,
      argValues: [that, isCreatedFromAdsUi],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetIsCreatedFromAdsUiConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_is_created_from_ads_ui",
            argNames: ["that", "isCreatedFromAdsUi"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetIsCrosspostable(
      {required Post that, required bool isCrosspostable}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(isCrosspostable, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 204)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetIsCrosspostableConstMeta,
      argValues: [that, isCrosspostable],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetIsCrosspostableConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_is_crosspostable",
            argNames: ["that", "isCrosspostable"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetIsMeta(
      {required Post that, required bool isMeta}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(isMeta, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 205)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetIsMetaConstMeta,
      argValues: [that, isMeta],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetIsMetaConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_is_meta",
        argNames: ["that", "isMeta"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetIsOriginalContent(
      {required Post that, required bool isOriginalContent}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(isOriginalContent, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 206)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorSetIsOriginalContentConstMeta,
      argValues: [that, isOriginalContent],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetIsOriginalContentConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_is_original_content",
            argNames: ["that", "isOriginalContent"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetIsRedditMediaDomain(
      {required Post that, required bool isRedditMediaDomain}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(isRedditMediaDomain, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 207)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorSetIsRedditMediaDomainConstMeta,
      argValues: [that, isRedditMediaDomain],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetIsRedditMediaDomainConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_is_reddit_media_domain",
            argNames: ["that", "isRedditMediaDomain"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetIsRobotIndexable(
      {required Post that, required bool isRobotIndexable}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(isRobotIndexable, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 208)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorSetIsRobotIndexableConstMeta,
      argValues: [that, isRobotIndexable],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetIsRobotIndexableConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_is_robot_indexable",
            argNames: ["that", "isRobotIndexable"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetIsSelf(
      {required Post that, required bool isSelf}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(isSelf, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 209)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetIsSelfConstMeta,
      argValues: [that, isSelf],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetIsSelfConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_is_self",
        argNames: ["that", "isSelf"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetIsVideo(
      {required Post that, required bool isVideo}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(isVideo, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 210)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetIsVideoConstMeta,
      argValues: [that, isVideo],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetIsVideoConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_is_video",
        argNames: ["that", "isVideo"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetLikes(
      {required Post that, bool? likes}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_bool(likes, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 211)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetLikesConstMeta,
      argValues: [that, likes],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetLikesConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_likes",
        argNames: ["that", "likes"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetLinkFlair(
      {required Post that, required Flair linkFlair}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            linkFlair, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 212)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetLinkFlairConstMeta,
      argValues: [that, linkFlair],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetLinkFlairConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_link_flair",
        argNames: ["that", "linkFlair"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetLocked(
      {required Post that, required bool locked}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(locked, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 213)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetLockedConstMeta,
      argValues: [that, locked],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetLockedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_locked",
        argNames: ["that", "locked"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetMedia(
      {required Post that, Media? media}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
            media, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 214)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetMediaConstMeta,
      argValues: [that, media],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetMediaConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_media",
        argNames: ["that", "media"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetMediaEmbed(
      {required Post that, MediaEmbed? mediaEmbed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_media_embed(mediaEmbed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 215)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetMediaEmbedConstMeta,
      argValues: [that, mediaEmbed],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetMediaEmbedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_media_embed",
        argNames: ["that", "mediaEmbed"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetMediaOnly(
      {required Post that, required bool mediaOnly}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(mediaOnly, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 216)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetMediaOnlyConstMeta,
      argValues: [that, mediaOnly],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetMediaOnlyConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_media_only",
        argNames: ["that", "mediaOnly"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetModNote(
      {required Post that, String? modNote}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(modNote, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 217)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetModNoteConstMeta,
      argValues: [that, modNote],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetModNoteConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_mod_note",
        argNames: ["that", "modNote"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetModReasonBy(
      {required Post that, String? modReasonBy}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(modReasonBy, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 218)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetModReasonByConstMeta,
      argValues: [that, modReasonBy],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetModReasonByConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_mod_reason_by",
            argNames: ["that", "modReasonBy"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetModReasonTitle(
      {required Post that, String? modReasonTitle}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(modReasonTitle, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 219)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetModReasonTitleConstMeta,
      argValues: [that, modReasonTitle],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetModReasonTitleConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_mod_reason_title",
            argNames: ["that", "modReasonTitle"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetModReports(
      {required Post that, required List<String?> modReports}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_list_opt_String(modReports, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 220)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetModReportsConstMeta,
      argValues: [that, modReports],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetModReportsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_mod_reports",
        argNames: ["that", "modReports"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetName(
      {required Post that, required Fullname name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
            name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 221)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetNameConstMeta,
      argValues: [that, name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetNameConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_name",
        argNames: ["that", "name"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetNoFollow(
      {required Post that, required bool noFollow}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(noFollow, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 222)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetNoFollowConstMeta,
      argValues: [that, noFollow],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetNoFollowConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_no_follow",
        argNames: ["that", "noFollow"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetNumComments(
      {required Post that, required PlatformInt64 numComments}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_i_64(numComments, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 223)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetNumCommentsConstMeta,
      argValues: [that, numComments],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetNumCommentsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_num_comments",
            argNames: ["that", "numComments"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetNumCrossposts(
      {required Post that, PlatformInt64? numCrossposts}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_i_64(numCrossposts, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 224)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetNumCrosspostsConstMeta,
      argValues: [that, numCrossposts],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetNumCrosspostsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_num_crossposts",
            argNames: ["that", "numCrossposts"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetNumDuplicates(
      {required Post that, BigInt? numDuplicates}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_u_64(numDuplicates, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 225)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetNumDuplicatesConstMeta,
      argValues: [that, numDuplicates],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetNumDuplicatesConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_num_duplicates",
            argNames: ["that", "numDuplicates"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetNumReports(
      {required Post that, String? numReports}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(numReports, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 226)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetNumReportsConstMeta,
      argValues: [that, numReports],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetNumReportsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_num_reports",
        argNames: ["that", "numReports"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetOver18(
      {required Post that, required bool over18}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(over18, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 227)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetOver18ConstMeta,
      argValues: [that, over18],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetOver18ConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_over_18",
        argNames: ["that", "over18"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetPermalink(
      {required Post that, required String permalink}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_String(permalink, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 228)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetPermalinkConstMeta,
      argValues: [that, permalink],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetPermalinkConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_permalink",
        argNames: ["that", "permalink"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetPinned(
      {required Post that, required bool pinned}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(pinned, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 229)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetPinnedConstMeta,
      argValues: [that, pinned],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetPinnedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_pinned",
        argNames: ["that", "pinned"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetPostHint(
      {required Post that, String? postHint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(postHint, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 230)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetPostHintConstMeta,
      argValues: [that, postHint],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetPostHintConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_post_hint",
        argNames: ["that", "postHint"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetPreview(
      {required Post that, Preview? preview}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_preview(preview, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 231)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetPreviewConstMeta,
      argValues: [that, preview],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetPreviewConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_preview",
        argNames: ["that", "preview"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetPwls(
      {required Post that, PlatformInt64? pwls}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_i_64(pwls, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 232)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetPwlsConstMeta,
      argValues: [that, pwls],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetPwlsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_pwls",
        argNames: ["that", "pwls"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetQuarantine(
      {required Post that, required bool quarantine}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(quarantine, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 233)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetQuarantineConstMeta,
      argValues: [that, quarantine],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetQuarantineConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_quarantine",
        argNames: ["that", "quarantine"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetRemovalReason(
      {required Post that, String? removalReason}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(removalReason, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 234)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetRemovalReasonConstMeta,
      argValues: [that, removalReason],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetRemovalReasonConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_removal_reason",
            argNames: ["that", "removalReason"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetRemovedBy(
      {required Post that, String? removedBy}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(removedBy, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 235)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetRemovedByConstMeta,
      argValues: [that, removedBy],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetRemovedByConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_removed_by",
        argNames: ["that", "removedBy"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetRemovedByCategory(
      {required Post that, String? removedByCategory}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(removedByCategory, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 236)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorSetRemovedByCategoryConstMeta,
      argValues: [that, removedByCategory],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetRemovedByCategoryConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_removed_by_category",
            argNames: ["that", "removedByCategory"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetReportReasons(
      {required Post that, String? reportReasons}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(reportReasons, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 237)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetReportReasonsConstMeta,
      argValues: [that, reportReasons],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetReportReasonsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_report_reasons",
            argNames: ["that", "reportReasons"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetSaved(
      {required Post that, required bool saved}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(saved, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 238)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetSavedConstMeta,
      argValues: [that, saved],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetSavedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_saved",
        argNames: ["that", "saved"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetScore(
      {required Post that, required PlatformInt64 score}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_i_64(score, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 239)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetScoreConstMeta,
      argValues: [that, score],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetScoreConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_score",
        argNames: ["that", "score"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetSecureMedia(
      {required Post that, SecureMedia? secureMedia}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
            secureMedia, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 240)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetSecureMediaConstMeta,
      argValues: [that, secureMedia],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetSecureMediaConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_secure_media",
            argNames: ["that", "secureMedia"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetSecureMediaEmbed(
      {required Post that, SecureMediaEmbed? secureMediaEmbed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_secure_media_embed(
            secureMediaEmbed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 241)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorSetSecureMediaEmbedConstMeta,
      argValues: [that, secureMediaEmbed],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetSecureMediaEmbedConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_secure_media_embed",
            argNames: ["that", "secureMediaEmbed"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetSelftext(
      {required Post that, String? selftext}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(selftext, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 242)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetSelftextConstMeta,
      argValues: [that, selftext],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetSelftextConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_selftext",
        argNames: ["that", "selftext"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetSelftextHtml(
      {required Post that, String? selftextHtml}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(selftextHtml, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 243)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetSelftextHtmlConstMeta,
      argValues: [that, selftextHtml],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetSelftextHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_selftext_html",
            argNames: ["that", "selftextHtml"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetSendReplies(
      {required Post that, required bool sendReplies}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(sendReplies, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 244)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetSendRepliesConstMeta,
      argValues: [that, sendReplies],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetSendRepliesConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_send_replies",
            argNames: ["that", "sendReplies"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetSpoiler(
      {required Post that, required bool spoiler}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(spoiler, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 245)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetSpoilerConstMeta,
      argValues: [that, spoiler],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetSpoilerConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_spoiler",
        argNames: ["that", "spoiler"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetStickied(
      {required Post that, required bool stickied}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(stickied, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 246)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetStickiedConstMeta,
      argValues: [that, stickied],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetStickiedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_stickied",
        argNames: ["that", "stickied"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetSubreddit(
      {required Post that, required SubredditInfo subreddit}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            subreddit, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 247)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetSubredditConstMeta,
      argValues: [that, subreddit],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetSubredditConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_subreddit",
        argNames: ["that", "subreddit"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetSuggestedSort(
      {required Post that, String? suggestedSort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(suggestedSort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 248)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetSuggestedSortConstMeta,
      argValues: [that, suggestedSort],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetSuggestedSortConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_suggested_sort",
            argNames: ["that", "suggestedSort"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetTitle(
      {required Post that, required String title}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_String(title, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 249)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetTitleConstMeta,
      argValues: [that, title],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetTitleConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_title",
        argNames: ["that", "title"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetTopAwardedType(
      {required Post that, String? topAwardedType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(topAwardedType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 250)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetTopAwardedTypeConstMeta,
      argValues: [that, topAwardedType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetTopAwardedTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_top_awarded_type",
            argNames: ["that", "topAwardedType"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetTotalAwardsReceived(
      {required Post that, PlatformInt64? totalAwardsReceived}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_i_64(totalAwardsReceived, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 251)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorSetTotalAwardsReceivedConstMeta,
      argValues: [that, totalAwardsReceived],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetTotalAwardsReceivedConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_total_awards_received",
            argNames: ["that", "totalAwardsReceived"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetTreatmentTags(
      {required Post that, required List<String?> treatmentTags}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_list_opt_String(treatmentTags, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 252)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetTreatmentTagsConstMeta,
      argValues: [that, treatmentTags],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetTreatmentTagsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_treatment_tags",
            argNames: ["that", "treatmentTags"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetUps(
      {required Post that, required PlatformInt64 ups}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_i_64(ups, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 253)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetUpsConstMeta,
      argValues: [that, ups],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetUpsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_ups",
        argNames: ["that", "ups"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetUpvoteRatio(
      {required Post that, required double upvoteRatio}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_f_64(upvoteRatio, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 254)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetUpvoteRatioConstMeta,
      argValues: [that, upvoteRatio],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetUpvoteRatioConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_upvote_ratio",
            argNames: ["that", "upvoteRatio"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetUrl(
      {required Post that, required String url}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_String(url, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 255)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetUrlConstMeta,
      argValues: [that, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetUrlConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_url",
        argNames: ["that", "url"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetUrlOverriddenByDest(
      {required Post that, String? urlOverriddenByDest}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(urlOverriddenByDest, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 256)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostPostAutoAccessorSetUrlOverriddenByDestConstMeta,
      argValues: [that, urlOverriddenByDest],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetUrlOverriddenByDestConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_url_overridden_by_dest",
            argNames: ["that", "urlOverriddenByDest"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetUserReports(
      {required Post that, required List<String?> userReports}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_list_opt_String(userReports, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 257)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetUserReportsConstMeta,
      argValues: [that, userReports],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostPostAutoAccessorSetUserReportsConstMeta =>
          const TaskConstMeta(
            debugName: "Post_auto_accessor_set_user_reports",
            argNames: ["that", "userReports"],
          );

  @override
  void redditApiModelPostPostAutoAccessorSetViewCount(
      {required Post that, String? viewCount}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_String(viewCount, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 258)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetViewCountConstMeta,
      argValues: [that, viewCount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetViewCountConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_view_count",
        argNames: ["that", "viewCount"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetVisited(
      {required Post that, required bool visited}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_bool(visited, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 259)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetVisitedConstMeta,
      argValues: [that, visited],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetVisitedConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_visited",
        argNames: ["that", "visited"],
      );

  @override
  void redditApiModelPostPostAutoAccessorSetWls(
      {required Post that, PlatformInt64? wls}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        sse_encode_opt_box_autoadd_i_64(wls, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 260)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostAutoAccessorSetWlsConstMeta,
      argValues: [that, wls],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostAutoAccessorSetWlsConstMeta =>
      const TaskConstMeta(
        debugName: "Post_auto_accessor_set_wls",
        argNames: ["that", "wls"],
      );

  @override
  Future<Post> redditApiModelPostPostDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 261, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Post_default",
        argNames: [],
      );

  @override
  Kind redditApiModelPostPostKind({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 262)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_kind,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostKindConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostKindConstMeta => const TaskConstMeta(
        debugName: "Post_kind",
        argNames: ["that"],
      );

  @override
  Thumbnail? redditApiModelPostPostThumbnail({required Post that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 263)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_thumbnail,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPostThumbnailConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPostThumbnailConstMeta =>
      const TaskConstMeta(
        debugName: "Post_thumbnail",
        argNames: ["that"],
      );

  @override
  Future<RedditVideo> redditApiModelPostRedditVideoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 264, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRedditVideo,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostRedditVideoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostRedditVideoDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "RedditVideo_default",
        argNames: [],
      );

  @override
  Future<SubredditId> redditApiModelPostSubredditIdDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 265, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostSubredditIdDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostSubredditIdDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "SubredditId_default",
        argNames: [],
      );

  @override
  String redditApiModelPostSubredditInfoAutoAccessorGetSubreddit(
      {required SubredditInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 266)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostSubredditInfoAutoAccessorGetSubredditConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostSubredditInfoAutoAccessorGetSubredditConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_get_subreddit",
            argNames: ["that"],
          );

  @override
  SubredditId redditApiModelPostSubredditInfoAutoAccessorGetSubredditId(
      {required SubredditInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 267)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostSubredditInfoAutoAccessorGetSubredditIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostSubredditInfoAutoAccessorGetSubredditIdConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_get_subreddit_id",
            argNames: ["that"],
          );

  @override
  String redditApiModelPostSubredditInfoAutoAccessorGetSubredditNamePrefixed(
      {required SubredditInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 268)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostSubredditInfoAutoAccessorGetSubredditNamePrefixedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostSubredditInfoAutoAccessorGetSubredditNamePrefixedConstMeta =>
          const TaskConstMeta(
            debugName:
                "SubredditInfo_auto_accessor_get_subreddit_name_prefixed",
            argNames: ["that"],
          );

  @override
  String redditApiModelPostSubredditInfoAutoAccessorGetSubredditType(
      {required SubredditInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 269)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostSubredditInfoAutoAccessorGetSubredditTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostSubredditInfoAutoAccessorGetSubredditTypeConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_get_subreddit_type",
            argNames: ["that"],
          );

  @override
  BigInt redditApiModelPostSubredditInfoAutoAccessorGetSubscribers(
      {required SubredditInfo that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 270)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostSubredditInfoAutoAccessorGetSubscribersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostSubredditInfoAutoAccessorGetSubscribersConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_get_subscribers",
            argNames: ["that"],
          );

  @override
  void redditApiModelPostSubredditInfoAutoAccessorSetSubreddit(
      {required SubredditInfo that, required String subreddit}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        sse_encode_String(subreddit, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 271)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostSubredditInfoAutoAccessorSetSubredditConstMeta,
      argValues: [that, subreddit],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostSubredditInfoAutoAccessorSetSubredditConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_set_subreddit",
            argNames: ["that", "subreddit"],
          );

  @override
  void redditApiModelPostSubredditInfoAutoAccessorSetSubredditId(
      {required SubredditInfo that, required SubredditId subredditId}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
            subredditId, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 272)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostSubredditInfoAutoAccessorSetSubredditIdConstMeta,
      argValues: [that, subredditId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostSubredditInfoAutoAccessorSetSubredditIdConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_set_subreddit_id",
            argNames: ["that", "subredditId"],
          );

  @override
  void redditApiModelPostSubredditInfoAutoAccessorSetSubredditNamePrefixed(
      {required SubredditInfo that, required String subredditNamePrefixed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        sse_encode_String(subredditNamePrefixed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 273)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostSubredditInfoAutoAccessorSetSubredditNamePrefixedConstMeta,
      argValues: [that, subredditNamePrefixed],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostSubredditInfoAutoAccessorSetSubredditNamePrefixedConstMeta =>
          const TaskConstMeta(
            debugName:
                "SubredditInfo_auto_accessor_set_subreddit_name_prefixed",
            argNames: ["that", "subredditNamePrefixed"],
          );

  @override
  void redditApiModelPostSubredditInfoAutoAccessorSetSubredditType(
      {required SubredditInfo that, required String subredditType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        sse_encode_String(subredditType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 274)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostSubredditInfoAutoAccessorSetSubredditTypeConstMeta,
      argValues: [that, subredditType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostSubredditInfoAutoAccessorSetSubredditTypeConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_set_subreddit_type",
            argNames: ["that", "subredditType"],
          );

  @override
  void redditApiModelPostSubredditInfoAutoAccessorSetSubscribers(
      {required SubredditInfo that, required BigInt subscribers}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
            that, serializer);
        sse_encode_u_64(subscribers, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 275)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelPostSubredditInfoAutoAccessorSetSubscribersConstMeta,
      argValues: [that, subscribers],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelPostSubredditInfoAutoAccessorSetSubscribersConstMeta =>
          const TaskConstMeta(
            debugName: "SubredditInfo_auto_accessor_set_subscribers",
            argNames: ["that", "subscribers"],
          );

  @override
  Future<SubredditInfo> redditApiModelPostSubredditInfoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 276, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostSubredditInfoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostSubredditInfoDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "SubredditInfo_default",
        argNames: [],
      );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAcceptFollowers(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 277)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAcceptFollowersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAcceptFollowersConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_accept_followers",
            argNames: ["that"],
          );

  @override
  BigInt? redditApiModelSubredditSubredditAutoAccessorGetAccountsActive(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 278)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAccountsActiveConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAccountsActiveConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_accounts_active",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAccountsActiveIsFuzzed(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 279)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAccountsActiveIsFuzzedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAccountsActiveIsFuzzedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_accounts_active_is_fuzzed",
            argNames: ["that"],
          );

  @override
  BigInt redditApiModelSubredditSubredditAutoAccessorGetActiveUserCount(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 280)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetActiveUserCountConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetActiveUserCountConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_active_user_count",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetAdvertiserCategory(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 281)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAdvertiserCategoryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAdvertiserCategoryConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_advertiser_category",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllOriginalContent(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 282)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllOriginalContentConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllOriginalContentConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_all_original_content",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowDiscovery(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 283)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowDiscoveryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowDiscoveryConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_discovery",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowGalleries(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 284)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowGalleriesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowGalleriesConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_galleries",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowImages(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 285)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowImagesConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowImagesConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_images",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowPolls(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 286)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowPollsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowPollsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_polls",
            argNames: ["that"],
          );

  @override
  bool
      redditApiModelSubredditSubredditAutoAccessorGetAllowPredictionContributors(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 287)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowPredictionContributorsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowPredictionContributorsConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_allow_prediction_contributors",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowPredictions(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 288)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_predictions",
            argNames: ["that"],
          );

  @override
  bool
      redditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsTournament(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 289)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsTournamentConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsTournamentConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_allow_predictions_tournament",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowTalks(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 290)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowTalksConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowTalksConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_talks",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowVideogifs(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 291)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowVideogifsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowVideogifsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_videogifs",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetAllowVideos(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 292)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowVideosConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowVideosConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allow_videos",
            argNames: ["that"],
          );

  @override
  List<String>
      redditApiModelSubredditSubredditAutoAccessorGetAllowedMediaInComments(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 293)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetAllowedMediaInCommentsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetAllowedMediaInCommentsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_allowed_media_in_comments",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundColor(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 294)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundColorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundColorConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_banner_background_color",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundImage(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 295)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundImageConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundImageConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_banner_background_image",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetBannerImg(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 296)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetBannerImgConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetBannerImgConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_banner_img",
            argNames: ["that"],
          );

  @override
  Int64List? redditApiModelSubredditSubredditAutoAccessorGetBannerSize(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 297)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_list_prim_i_64_strict,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetBannerSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetBannerSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_banner_size",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetCanAssignLinkFlair(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 298)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCanAssignLinkFlairConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCanAssignLinkFlairConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_can_assign_link_flair",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetCanAssignUserFlair(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 299)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCanAssignUserFlairConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCanAssignUserFlairConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_can_assign_user_flair",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetCollapseDeletedComments(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 300)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCollapseDeletedCommentsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCollapseDeletedCommentsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_collapse_deleted_comments",
            argNames: ["that"],
          );

  @override
  CommentContributionSettings
      redditApiModelSubredditSubredditAutoAccessorGetCommentContributionSettings(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 301)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_comment_contribution_settings,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCommentContributionSettingsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCommentContributionSettingsConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_comment_contribution_settings",
            argNames: ["that"],
          );

  @override
  PlatformInt64
      redditApiModelSubredditSubredditAutoAccessorGetCommentScoreHideMins(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 302)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCommentScoreHideMinsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCommentScoreHideMinsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_comment_score_hide_mins",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetCommunityIcon(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 303)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCommunityIconConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCommunityIconConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_community_icon",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetCommunityReviewed(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 304)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCommunityReviewedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCommunityReviewedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_community_reviewed",
            argNames: ["that"],
          );

  @override
  double redditApiModelSubredditSubredditAutoAccessorGetCreated(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 305)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCreatedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCreatedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_created",
            argNames: ["that"],
          );

  @override
  double redditApiModelSubredditSubredditAutoAccessorGetCreatedUtc(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 306)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_f_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetCreatedUtcConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetCreatedUtcConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_created_utc",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetDescription(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 307)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetDescriptionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetDescriptionConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_description",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetDescriptionHtml(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 308)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetDescriptionHtmlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetDescriptionHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_description_html",
            argNames: ["that"],
          );

  @override
  bool
      redditApiModelSubredditSubredditAutoAccessorGetDisableContributorRequests(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 309)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetDisableContributorRequestsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetDisableContributorRequestsConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_disable_contributor_requests",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetDisplayName(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 310)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetDisplayNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetDisplayNameConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_display_name",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetDisplayNamePrefixed(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 311)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetDisplayNamePrefixedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetDisplayNamePrefixedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_display_name_prefixed",
            argNames: ["that"],
          );

  @override
  Int64List? redditApiModelSubredditSubredditAutoAccessorGetEmojisCustomSize(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 312)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_list_prim_i_64_strict,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetEmojisCustomSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetEmojisCustomSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_emojis_custom_size",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetEmojisEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 313)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetEmojisEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetEmojisEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_emojis_enabled",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetFreeFormReports(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 314)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetFreeFormReportsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetFreeFormReportsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_free_form_reports",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetHasMenuWidget(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 315)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetHasMenuWidgetConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetHasMenuWidgetConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_has_menu_widget",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetHeaderImg(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 316)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetHeaderImgConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetHeaderImgConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_header_img",
            argNames: ["that"],
          );

  @override
  Int64List? redditApiModelSubredditSubredditAutoAccessorGetHeaderSize(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 317)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_list_prim_i_64_strict,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetHeaderSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetHeaderSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_header_size",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetHeaderTitle(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 318)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetHeaderTitleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetHeaderTitleConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_header_title",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetHideAds(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 319)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetHideAdsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetHideAdsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_hide_ads",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetIconImg(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 320)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetIconImgConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetIconImgConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_icon_img",
            argNames: ["that"],
          );

  @override
  UsizeArray2? redditApiModelSubredditSubredditAutoAccessorGetIconSize(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 321)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_usize_array_2,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetIconSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetIconSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_icon_size",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetId(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 322)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorGetIdConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetIdConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_id",
            argNames: ["that"],
          );

  @override
  bool? redditApiModelSubredditSubredditAutoAccessorGetIsCrosspostableSubreddit(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 323)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetIsCrosspostableSubredditConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetIsCrosspostableSubredditConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_is_crosspostable_subreddit",
            argNames: ["that"],
          );

  @override
  bool? redditApiModelSubredditSubredditAutoAccessorGetIsEnrolledInNewModmail(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 324)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetIsEnrolledInNewModmailConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetIsEnrolledInNewModmailConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_is_enrolled_in_new_modmail",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetKeyColor(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 325)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetKeyColorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetKeyColorConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_key_color",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetLang(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 326)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorGetLangConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetLangConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_lang",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetLinkFlairEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 327)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetLinkFlairEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetLinkFlairEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_link_flair_enabled",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetLinkFlairPosition(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 328)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetLinkFlairPositionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetLinkFlairPositionConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_link_flair_position",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetMobileBannerImage(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 329)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetMobileBannerImageConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetMobileBannerImageConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_mobile_banner_image",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetName(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 330)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorGetNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetNameConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_name",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetNotificationLevel(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 331)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetNotificationLevelConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetNotificationLevelConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_notification_level",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetOriginalContentTagEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 332)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetOriginalContentTagEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetOriginalContentTagEnabledConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_original_content_tag_enabled",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetOver18(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 333)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetOver18ConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetOver18ConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_over18",
            argNames: ["that"],
          );

  @override
  PlatformInt64
      redditApiModelSubredditSubredditAutoAccessorGetPredictionLeaderboardEntryType(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 334)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetPredictionLeaderboardEntryTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetPredictionLeaderboardEntryTypeConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_prediction_leaderboard_entry_type",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetPrimaryColor(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 335)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetPrimaryColorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetPrimaryColorConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_primary_color",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetPublicDescription(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 336)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetPublicDescriptionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetPublicDescriptionConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_public_description",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetPublicDescriptionHtml(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 337)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetPublicDescriptionHtmlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetPublicDescriptionHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_public_description_html",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetPublicTraffic(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 338)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetPublicTrafficConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetPublicTrafficConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_public_traffic",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetQuarantine(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 339)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetQuarantineConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetQuarantineConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_quarantine",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetRestrictCommenting(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 340)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetRestrictCommentingConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetRestrictCommentingConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_restrict_commenting",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetRestrictPosting(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 341)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetRestrictPostingConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetRestrictPostingConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_restrict_posting",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetShouldArchivePosts(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 342)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetShouldArchivePostsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetShouldArchivePostsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_should_archive_posts",
            argNames: ["that"],
          );

  @override
  bool
      redditApiModelSubredditSubredditAutoAccessorGetShouldShowMediaInCommentsSetting(
          {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 343)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetShouldShowMediaInCommentsSettingConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetShouldShowMediaInCommentsSettingConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_get_should_show_media_in_comments_setting",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetShowMedia(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 344)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetShowMediaConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetShowMediaConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_show_media",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetShowMediaPreview(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 345)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetShowMediaPreviewConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetShowMediaPreviewConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_show_media_preview",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetSpoilersEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 346)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSpoilersEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSpoilersEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_spoilers_enabled",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetSubmissionType(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 347)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSubmissionTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSubmissionTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_submission_type",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetSubmitLinkLabel(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 348)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSubmitLinkLabelConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSubmitLinkLabelConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_submit_link_label",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetSubmitText(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 349)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSubmitTextConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSubmitTextConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_submit_text",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetSubmitTextHtml(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 350)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSubmitTextHtmlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSubmitTextHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_submit_text_html",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetSubmitTextLabel(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 351)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSubmitTextLabelConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSubmitTextLabelConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_submit_text_label",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetSubredditType(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 352)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSubredditTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSubredditTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_subreddit_type",
            argNames: ["that"],
          );

  @override
  PlatformInt64 redditApiModelSubredditSubredditAutoAccessorGetSubscribers(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 353)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSubscribersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSubscribersConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_subscribers",
            argNames: ["that"],
          );

  @override
  String? redditApiModelSubredditSubredditAutoAccessorGetSuggestedCommentSort(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 354)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetSuggestedCommentSortConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetSuggestedCommentSortConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_suggested_comment_sort",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetTitle(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 355)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorGetTitleConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetTitleConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_title",
            argNames: ["that"],
          );

  @override
  String redditApiModelSubredditSubredditAutoAccessorGetUrl(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 356)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorGetUrlConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUrlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_url",
            argNames: ["that"],
          );

  @override
  bool? redditApiModelSubredditSubredditAutoAccessorGetUserCanFlairInSr(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 357)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserCanFlairInSrConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserCanFlairInSrConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_can_flair_in_sr",
            argNames: ["that"],
          );

  @override
  Flair redditApiModelSubredditSubredditAutoAccessorGetUserFlair(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 358)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserFlairConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserFlairConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_flair",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetUserFlairEnabledInSr(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 359)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserFlairEnabledInSrConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserFlairEnabledInSrConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_flair_enabled_in_sr",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetUserHasFavorited(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 360)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserHasFavoritedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserHasFavoritedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_has_favorited",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetUserIsBanned(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 361)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserIsBannedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserIsBannedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_is_banned",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetUserIsContributor(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 362)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserIsContributorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserIsContributorConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_is_contributor",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetUserIsModerator(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 363)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserIsModeratorConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserIsModeratorConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_is_moderator",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetUserIsMuted(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 364)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserIsMutedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserIsMutedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_is_muted",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetUserIsSubscriber(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 365)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserIsSubscriberConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserIsSubscriberConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_is_subscriber",
            argNames: ["that"],
          );

  @override
  bool? redditApiModelSubredditSubredditAutoAccessorGetUserSrFlairEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 366)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserSrFlairEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserSrFlairEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_sr_flair_enabled",
            argNames: ["that"],
          );

  @override
  bool redditApiModelSubredditSubredditAutoAccessorGetUserSrThemeEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 367)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetUserSrThemeEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetUserSrThemeEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_user_sr_theme_enabled",
            argNames: ["that"],
          );

  @override
  bool? redditApiModelSubredditSubredditAutoAccessorGetWikiEnabled(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 368)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorGetWikiEnabledConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetWikiEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_wiki_enabled",
            argNames: ["that"],
          );

  @override
  BigInt? redditApiModelSubredditSubredditAutoAccessorGetWls(
      {required Subreddit that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 369)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_u_64,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorGetWlsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorGetWlsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_get_wls",
            argNames: ["that"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAcceptFollowers(
      {required Subreddit that, required bool acceptFollowers}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(acceptFollowers, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 370)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAcceptFollowersConstMeta,
      argValues: [that, acceptFollowers],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAcceptFollowersConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_accept_followers",
            argNames: ["that", "acceptFollowers"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAccountsActive(
      {required Subreddit that, BigInt? accountsActive}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_u_64(accountsActive, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 371)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAccountsActiveConstMeta,
      argValues: [that, accountsActive],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAccountsActiveConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_accounts_active",
            argNames: ["that", "accountsActive"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAccountsActiveIsFuzzed(
      {required Subreddit that, required bool accountsActiveIsFuzzed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(accountsActiveIsFuzzed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 372)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAccountsActiveIsFuzzedConstMeta,
      argValues: [that, accountsActiveIsFuzzed],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAccountsActiveIsFuzzedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_accounts_active_is_fuzzed",
            argNames: ["that", "accountsActiveIsFuzzed"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetActiveUserCount(
      {required Subreddit that, required BigInt activeUserCount}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_u_64(activeUserCount, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 373)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetActiveUserCountConstMeta,
      argValues: [that, activeUserCount],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetActiveUserCountConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_active_user_count",
            argNames: ["that", "activeUserCount"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAdvertiserCategory(
      {required Subreddit that, required String advertiserCategory}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(advertiserCategory, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 374)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAdvertiserCategoryConstMeta,
      argValues: [that, advertiserCategory],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAdvertiserCategoryConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_advertiser_category",
            argNames: ["that", "advertiserCategory"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllOriginalContent(
      {required Subreddit that, required bool allOriginalContent}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allOriginalContent, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 375)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllOriginalContentConstMeta,
      argValues: [that, allOriginalContent],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllOriginalContentConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_all_original_content",
            argNames: ["that", "allOriginalContent"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowDiscovery(
      {required Subreddit that, required bool allowDiscovery}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowDiscovery, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 376)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowDiscoveryConstMeta,
      argValues: [that, allowDiscovery],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowDiscoveryConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_discovery",
            argNames: ["that", "allowDiscovery"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowGalleries(
      {required Subreddit that, required bool allowGalleries}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowGalleries, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 377)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowGalleriesConstMeta,
      argValues: [that, allowGalleries],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowGalleriesConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_galleries",
            argNames: ["that", "allowGalleries"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowImages(
      {required Subreddit that, required bool allowImages}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowImages, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 378)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowImagesConstMeta,
      argValues: [that, allowImages],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowImagesConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_images",
            argNames: ["that", "allowImages"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowPolls(
      {required Subreddit that, required bool allowPolls}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowPolls, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 379)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowPollsConstMeta,
      argValues: [that, allowPolls],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowPollsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_polls",
            argNames: ["that", "allowPolls"],
          );

  @override
  void
      redditApiModelSubredditSubredditAutoAccessorSetAllowPredictionContributors(
          {required Subreddit that,
          required bool allowPredictionContributors}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowPredictionContributors, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 380)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowPredictionContributorsConstMeta,
      argValues: [that, allowPredictionContributors],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowPredictionContributorsConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_allow_prediction_contributors",
            argNames: ["that", "allowPredictionContributors"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowPredictions(
      {required Subreddit that, required bool allowPredictions}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowPredictions, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 381)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsConstMeta,
      argValues: [that, allowPredictions],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_predictions",
            argNames: ["that", "allowPredictions"],
          );

  @override
  void
      redditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsTournament(
          {required Subreddit that, required bool allowPredictionsTournament}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowPredictionsTournament, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 382)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsTournamentConstMeta,
      argValues: [that, allowPredictionsTournament],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsTournamentConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_allow_predictions_tournament",
            argNames: ["that", "allowPredictionsTournament"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowTalks(
      {required Subreddit that, required bool allowTalks}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowTalks, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 383)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowTalksConstMeta,
      argValues: [that, allowTalks],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowTalksConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_talks",
            argNames: ["that", "allowTalks"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowVideogifs(
      {required Subreddit that, required bool allowVideogifs}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowVideogifs, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 384)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowVideogifsConstMeta,
      argValues: [that, allowVideogifs],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowVideogifsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_videogifs",
            argNames: ["that", "allowVideogifs"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowVideos(
      {required Subreddit that, required bool allowVideos}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(allowVideos, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 385)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowVideosConstMeta,
      argValues: [that, allowVideos],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowVideosConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allow_videos",
            argNames: ["that", "allowVideos"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetAllowedMediaInComments(
      {required Subreddit that, required List<String> allowedMediaInComments}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_list_String(allowedMediaInComments, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 386)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetAllowedMediaInCommentsConstMeta,
      argValues: [that, allowedMediaInComments],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetAllowedMediaInCommentsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_allowed_media_in_comments",
            argNames: ["that", "allowedMediaInComments"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundColor(
      {required Subreddit that, required String bannerBackgroundColor}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(bannerBackgroundColor, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 387)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundColorConstMeta,
      argValues: [that, bannerBackgroundColor],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundColorConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_banner_background_color",
            argNames: ["that", "bannerBackgroundColor"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundImage(
      {required Subreddit that, required String bannerBackgroundImage}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(bannerBackgroundImage, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 388)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundImageConstMeta,
      argValues: [that, bannerBackgroundImage],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundImageConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_banner_background_image",
            argNames: ["that", "bannerBackgroundImage"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetBannerImg(
      {required Subreddit that, required String bannerImg}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(bannerImg, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 389)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetBannerImgConstMeta,
      argValues: [that, bannerImg],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetBannerImgConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_banner_img",
            argNames: ["that", "bannerImg"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetBannerSize(
      {required Subreddit that, Int64List? bannerSize}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_list_prim_i_64_strict(bannerSize, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 390)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetBannerSizeConstMeta,
      argValues: [that, bannerSize],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetBannerSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_banner_size",
            argNames: ["that", "bannerSize"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCanAssignLinkFlair(
      {required Subreddit that, required bool canAssignLinkFlair}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(canAssignLinkFlair, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 391)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCanAssignLinkFlairConstMeta,
      argValues: [that, canAssignLinkFlair],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCanAssignLinkFlairConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_can_assign_link_flair",
            argNames: ["that", "canAssignLinkFlair"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCanAssignUserFlair(
      {required Subreddit that, required bool canAssignUserFlair}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(canAssignUserFlair, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 392)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCanAssignUserFlairConstMeta,
      argValues: [that, canAssignUserFlair],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCanAssignUserFlairConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_can_assign_user_flair",
            argNames: ["that", "canAssignUserFlair"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCollapseDeletedComments(
      {required Subreddit that, required bool collapseDeletedComments}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(collapseDeletedComments, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 393)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCollapseDeletedCommentsConstMeta,
      argValues: [that, collapseDeletedComments],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCollapseDeletedCommentsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_collapse_deleted_comments",
            argNames: ["that", "collapseDeletedComments"],
          );

  @override
  void
      redditApiModelSubredditSubredditAutoAccessorSetCommentContributionSettings(
          {required Subreddit that,
          required CommentContributionSettings commentContributionSettings}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_comment_contribution_settings(
            commentContributionSettings, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 394)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCommentContributionSettingsConstMeta,
      argValues: [that, commentContributionSettings],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCommentContributionSettingsConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_comment_contribution_settings",
            argNames: ["that", "commentContributionSettings"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCommentScoreHideMins(
      {required Subreddit that, required PlatformInt64 commentScoreHideMins}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_i_64(commentScoreHideMins, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 395)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCommentScoreHideMinsConstMeta,
      argValues: [that, commentScoreHideMins],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCommentScoreHideMinsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_comment_score_hide_mins",
            argNames: ["that", "commentScoreHideMins"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCommunityIcon(
      {required Subreddit that, required String communityIcon}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(communityIcon, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 396)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCommunityIconConstMeta,
      argValues: [that, communityIcon],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCommunityIconConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_community_icon",
            argNames: ["that", "communityIcon"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCommunityReviewed(
      {required Subreddit that, required bool communityReviewed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(communityReviewed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 397)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCommunityReviewedConstMeta,
      argValues: [that, communityReviewed],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCommunityReviewedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_community_reviewed",
            argNames: ["that", "communityReviewed"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCreated(
      {required Subreddit that, required double created}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_f_64(created, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 398)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCreatedConstMeta,
      argValues: [that, created],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCreatedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_created",
            argNames: ["that", "created"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetCreatedUtc(
      {required Subreddit that, required double createdUtc}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_f_64(createdUtc, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 399)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetCreatedUtcConstMeta,
      argValues: [that, createdUtc],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetCreatedUtcConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_created_utc",
            argNames: ["that", "createdUtc"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetDescription(
      {required Subreddit that, required String description}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(description, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 400)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetDescriptionConstMeta,
      argValues: [that, description],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetDescriptionConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_description",
            argNames: ["that", "description"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetDescriptionHtml(
      {required Subreddit that, String? descriptionHtml}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(descriptionHtml, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 401)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetDescriptionHtmlConstMeta,
      argValues: [that, descriptionHtml],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetDescriptionHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_description_html",
            argNames: ["that", "descriptionHtml"],
          );

  @override
  void
      redditApiModelSubredditSubredditAutoAccessorSetDisableContributorRequests(
          {required Subreddit that, required bool disableContributorRequests}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(disableContributorRequests, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 402)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetDisableContributorRequestsConstMeta,
      argValues: [that, disableContributorRequests],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetDisableContributorRequestsConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_disable_contributor_requests",
            argNames: ["that", "disableContributorRequests"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetDisplayName(
      {required Subreddit that, required String displayName}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(displayName, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 403)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetDisplayNameConstMeta,
      argValues: [that, displayName],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetDisplayNameConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_display_name",
            argNames: ["that", "displayName"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetDisplayNamePrefixed(
      {required Subreddit that, required String displayNamePrefixed}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(displayNamePrefixed, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 404)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetDisplayNamePrefixedConstMeta,
      argValues: [that, displayNamePrefixed],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetDisplayNamePrefixedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_display_name_prefixed",
            argNames: ["that", "displayNamePrefixed"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetEmojisCustomSize(
      {required Subreddit that, Int64List? emojisCustomSize}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_list_prim_i_64_strict(emojisCustomSize, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 405)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetEmojisCustomSizeConstMeta,
      argValues: [that, emojisCustomSize],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetEmojisCustomSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_emojis_custom_size",
            argNames: ["that", "emojisCustomSize"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetEmojisEnabled(
      {required Subreddit that, required bool emojisEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(emojisEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 406)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetEmojisEnabledConstMeta,
      argValues: [that, emojisEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetEmojisEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_emojis_enabled",
            argNames: ["that", "emojisEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetFreeFormReports(
      {required Subreddit that, required bool freeFormReports}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(freeFormReports, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 407)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetFreeFormReportsConstMeta,
      argValues: [that, freeFormReports],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetFreeFormReportsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_free_form_reports",
            argNames: ["that", "freeFormReports"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetHasMenuWidget(
      {required Subreddit that, required bool hasMenuWidget}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(hasMenuWidget, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 408)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetHasMenuWidgetConstMeta,
      argValues: [that, hasMenuWidget],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetHasMenuWidgetConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_has_menu_widget",
            argNames: ["that", "hasMenuWidget"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetHeaderImg(
      {required Subreddit that, String? headerImg}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(headerImg, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 409)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetHeaderImgConstMeta,
      argValues: [that, headerImg],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetHeaderImgConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_header_img",
            argNames: ["that", "headerImg"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetHeaderSize(
      {required Subreddit that, Int64List? headerSize}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_list_prim_i_64_strict(headerSize, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 410)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetHeaderSizeConstMeta,
      argValues: [that, headerSize],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetHeaderSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_header_size",
            argNames: ["that", "headerSize"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetHeaderTitle(
      {required Subreddit that, required String headerTitle}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(headerTitle, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 411)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetHeaderTitleConstMeta,
      argValues: [that, headerTitle],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetHeaderTitleConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_header_title",
            argNames: ["that", "headerTitle"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetHideAds(
      {required Subreddit that, required bool hideAds}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(hideAds, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 412)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetHideAdsConstMeta,
      argValues: [that, hideAds],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetHideAdsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_hide_ads",
            argNames: ["that", "hideAds"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetIconImg(
      {required Subreddit that, required String iconImg}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(iconImg, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 413)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetIconImgConstMeta,
      argValues: [that, iconImg],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetIconImgConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_icon_img",
            argNames: ["that", "iconImg"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetIconSize(
      {required Subreddit that, UsizeArray2? iconSize}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_usize_array_2(iconSize, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 414)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetIconSizeConstMeta,
      argValues: [that, iconSize],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetIconSizeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_icon_size",
            argNames: ["that", "iconSize"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetId(
      {required Subreddit that, required String id}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(id, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 415)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorSetIdConstMeta,
      argValues: [that, id],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetIdConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_id",
            argNames: ["that", "id"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetIsCrosspostableSubreddit(
      {required Subreddit that, bool? isCrosspostableSubreddit}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_bool(isCrosspostableSubreddit, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 416)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetIsCrosspostableSubredditConstMeta,
      argValues: [that, isCrosspostableSubreddit],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetIsCrosspostableSubredditConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_is_crosspostable_subreddit",
            argNames: ["that", "isCrosspostableSubreddit"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetIsEnrolledInNewModmail(
      {required Subreddit that, bool? isEnrolledInNewModmail}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_bool(isEnrolledInNewModmail, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 417)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetIsEnrolledInNewModmailConstMeta,
      argValues: [that, isEnrolledInNewModmail],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetIsEnrolledInNewModmailConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_is_enrolled_in_new_modmail",
            argNames: ["that", "isEnrolledInNewModmail"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetKeyColor(
      {required Subreddit that, required String keyColor}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(keyColor, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 418)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetKeyColorConstMeta,
      argValues: [that, keyColor],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetKeyColorConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_key_color",
            argNames: ["that", "keyColor"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetLang(
      {required Subreddit that, required String lang}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(lang, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 419)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorSetLangConstMeta,
      argValues: [that, lang],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetLangConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_lang",
            argNames: ["that", "lang"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetLinkFlairEnabled(
      {required Subreddit that, required bool linkFlairEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(linkFlairEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 420)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetLinkFlairEnabledConstMeta,
      argValues: [that, linkFlairEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetLinkFlairEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_link_flair_enabled",
            argNames: ["that", "linkFlairEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetLinkFlairPosition(
      {required Subreddit that, required String linkFlairPosition}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(linkFlairPosition, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 421)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetLinkFlairPositionConstMeta,
      argValues: [that, linkFlairPosition],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetLinkFlairPositionConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_link_flair_position",
            argNames: ["that", "linkFlairPosition"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetMobileBannerImage(
      {required Subreddit that, required String mobileBannerImage}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(mobileBannerImage, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 422)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetMobileBannerImageConstMeta,
      argValues: [that, mobileBannerImage],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetMobileBannerImageConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_mobile_banner_image",
            argNames: ["that", "mobileBannerImage"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetName(
      {required Subreddit that, required String name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 423)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorSetNameConstMeta,
      argValues: [that, name],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetNameConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_name",
            argNames: ["that", "name"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetNotificationLevel(
      {required Subreddit that, String? notificationLevel}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(notificationLevel, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 424)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetNotificationLevelConstMeta,
      argValues: [that, notificationLevel],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetNotificationLevelConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_notification_level",
            argNames: ["that", "notificationLevel"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetOriginalContentTagEnabled(
      {required Subreddit that, required bool originalContentTagEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(originalContentTagEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 425)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetOriginalContentTagEnabledConstMeta,
      argValues: [that, originalContentTagEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetOriginalContentTagEnabledConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_original_content_tag_enabled",
            argNames: ["that", "originalContentTagEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetOver18(
      {required Subreddit that, required bool over18}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(over18, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 426)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetOver18ConstMeta,
      argValues: [that, over18],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetOver18ConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_over18",
            argNames: ["that", "over18"],
          );

  @override
  void
      redditApiModelSubredditSubredditAutoAccessorSetPredictionLeaderboardEntryType(
          {required Subreddit that,
          required PlatformInt64 predictionLeaderboardEntryType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_i_64(predictionLeaderboardEntryType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 427)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetPredictionLeaderboardEntryTypeConstMeta,
      argValues: [that, predictionLeaderboardEntryType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetPredictionLeaderboardEntryTypeConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_prediction_leaderboard_entry_type",
            argNames: ["that", "predictionLeaderboardEntryType"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetPrimaryColor(
      {required Subreddit that, required String primaryColor}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(primaryColor, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 428)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetPrimaryColorConstMeta,
      argValues: [that, primaryColor],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetPrimaryColorConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_primary_color",
            argNames: ["that", "primaryColor"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetPublicDescription(
      {required Subreddit that, required String publicDescription}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(publicDescription, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 429)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetPublicDescriptionConstMeta,
      argValues: [that, publicDescription],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetPublicDescriptionConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_public_description",
            argNames: ["that", "publicDescription"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetPublicDescriptionHtml(
      {required Subreddit that, String? publicDescriptionHtml}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(publicDescriptionHtml, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 430)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetPublicDescriptionHtmlConstMeta,
      argValues: [that, publicDescriptionHtml],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetPublicDescriptionHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_public_description_html",
            argNames: ["that", "publicDescriptionHtml"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetPublicTraffic(
      {required Subreddit that, required bool publicTraffic}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(publicTraffic, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 431)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetPublicTrafficConstMeta,
      argValues: [that, publicTraffic],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetPublicTrafficConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_public_traffic",
            argNames: ["that", "publicTraffic"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetQuarantine(
      {required Subreddit that, required bool quarantine}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(quarantine, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 432)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetQuarantineConstMeta,
      argValues: [that, quarantine],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetQuarantineConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_quarantine",
            argNames: ["that", "quarantine"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetRestrictCommenting(
      {required Subreddit that, required bool restrictCommenting}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(restrictCommenting, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 433)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetRestrictCommentingConstMeta,
      argValues: [that, restrictCommenting],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetRestrictCommentingConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_restrict_commenting",
            argNames: ["that", "restrictCommenting"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetRestrictPosting(
      {required Subreddit that, required bool restrictPosting}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(restrictPosting, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 434)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetRestrictPostingConstMeta,
      argValues: [that, restrictPosting],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetRestrictPostingConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_restrict_posting",
            argNames: ["that", "restrictPosting"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetShouldArchivePosts(
      {required Subreddit that, required bool shouldArchivePosts}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(shouldArchivePosts, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 435)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetShouldArchivePostsConstMeta,
      argValues: [that, shouldArchivePosts],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetShouldArchivePostsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_should_archive_posts",
            argNames: ["that", "shouldArchivePosts"],
          );

  @override
  void
      redditApiModelSubredditSubredditAutoAccessorSetShouldShowMediaInCommentsSetting(
          {required Subreddit that,
          required bool shouldShowMediaInCommentsSetting}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(shouldShowMediaInCommentsSetting, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 436)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetShouldShowMediaInCommentsSettingConstMeta,
      argValues: [that, shouldShowMediaInCommentsSetting],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetShouldShowMediaInCommentsSettingConstMeta =>
          const TaskConstMeta(
            debugName:
                "Subreddit_auto_accessor_set_should_show_media_in_comments_setting",
            argNames: ["that", "shouldShowMediaInCommentsSetting"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetShowMedia(
      {required Subreddit that, required bool showMedia}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(showMedia, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 437)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetShowMediaConstMeta,
      argValues: [that, showMedia],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetShowMediaConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_show_media",
            argNames: ["that", "showMedia"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetShowMediaPreview(
      {required Subreddit that, required bool showMediaPreview}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(showMediaPreview, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 438)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetShowMediaPreviewConstMeta,
      argValues: [that, showMediaPreview],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetShowMediaPreviewConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_show_media_preview",
            argNames: ["that", "showMediaPreview"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSpoilersEnabled(
      {required Subreddit that, required bool spoilersEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(spoilersEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 439)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSpoilersEnabledConstMeta,
      argValues: [that, spoilersEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSpoilersEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_spoilers_enabled",
            argNames: ["that", "spoilersEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSubmissionType(
      {required Subreddit that, required String submissionType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(submissionType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 440)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSubmissionTypeConstMeta,
      argValues: [that, submissionType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSubmissionTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_submission_type",
            argNames: ["that", "submissionType"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSubmitLinkLabel(
      {required Subreddit that, required String submitLinkLabel}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(submitLinkLabel, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 441)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSubmitLinkLabelConstMeta,
      argValues: [that, submitLinkLabel],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSubmitLinkLabelConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_submit_link_label",
            argNames: ["that", "submitLinkLabel"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSubmitText(
      {required Subreddit that, required String submitText}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(submitText, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 442)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSubmitTextConstMeta,
      argValues: [that, submitText],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSubmitTextConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_submit_text",
            argNames: ["that", "submitText"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSubmitTextHtml(
      {required Subreddit that, String? submitTextHtml}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(submitTextHtml, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 443)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSubmitTextHtmlConstMeta,
      argValues: [that, submitTextHtml],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSubmitTextHtmlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_submit_text_html",
            argNames: ["that", "submitTextHtml"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSubmitTextLabel(
      {required Subreddit that, required String submitTextLabel}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(submitTextLabel, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 444)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSubmitTextLabelConstMeta,
      argValues: [that, submitTextLabel],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSubmitTextLabelConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_submit_text_label",
            argNames: ["that", "submitTextLabel"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSubredditType(
      {required Subreddit that, required String subredditType}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(subredditType, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 445)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSubredditTypeConstMeta,
      argValues: [that, subredditType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSubredditTypeConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_subreddit_type",
            argNames: ["that", "subredditType"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSubscribers(
      {required Subreddit that, required PlatformInt64 subscribers}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_i_64(subscribers, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 446)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSubscribersConstMeta,
      argValues: [that, subscribers],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSubscribersConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_subscribers",
            argNames: ["that", "subscribers"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetSuggestedCommentSort(
      {required Subreddit that, String? suggestedCommentSort}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_String(suggestedCommentSort, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 447)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetSuggestedCommentSortConstMeta,
      argValues: [that, suggestedCommentSort],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetSuggestedCommentSortConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_suggested_comment_sort",
            argNames: ["that", "suggestedCommentSort"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetTitle(
      {required Subreddit that, required String title}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(title, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 448)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorSetTitleConstMeta,
      argValues: [that, title],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetTitleConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_title",
            argNames: ["that", "title"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUrl(
      {required Subreddit that, required String url}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_String(url, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 449)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorSetUrlConstMeta,
      argValues: [that, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUrlConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_url",
            argNames: ["that", "url"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserCanFlairInSr(
      {required Subreddit that, bool? userCanFlairInSr}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_bool(userCanFlairInSr, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 450)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserCanFlairInSrConstMeta,
      argValues: [that, userCanFlairInSr],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserCanFlairInSrConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_can_flair_in_sr",
            argNames: ["that", "userCanFlairInSr"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserFlair(
      {required Subreddit that, required Flair userFlair}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
            userFlair, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 451)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserFlairConstMeta,
      argValues: [that, userFlair],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserFlairConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_flair",
            argNames: ["that", "userFlair"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserFlairEnabledInSr(
      {required Subreddit that, required bool userFlairEnabledInSr}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(userFlairEnabledInSr, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 452)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserFlairEnabledInSrConstMeta,
      argValues: [that, userFlairEnabledInSr],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserFlairEnabledInSrConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_flair_enabled_in_sr",
            argNames: ["that", "userFlairEnabledInSr"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserHasFavorited(
      {required Subreddit that, required bool userHasFavorited}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(userHasFavorited, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 453)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserHasFavoritedConstMeta,
      argValues: [that, userHasFavorited],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserHasFavoritedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_has_favorited",
            argNames: ["that", "userHasFavorited"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserIsBanned(
      {required Subreddit that, required bool userIsBanned}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(userIsBanned, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 454)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserIsBannedConstMeta,
      argValues: [that, userIsBanned],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserIsBannedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_is_banned",
            argNames: ["that", "userIsBanned"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserIsContributor(
      {required Subreddit that, required bool userIsContributor}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(userIsContributor, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 455)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserIsContributorConstMeta,
      argValues: [that, userIsContributor],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserIsContributorConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_is_contributor",
            argNames: ["that", "userIsContributor"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserIsModerator(
      {required Subreddit that, required bool userIsModerator}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(userIsModerator, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 456)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserIsModeratorConstMeta,
      argValues: [that, userIsModerator],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserIsModeratorConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_is_moderator",
            argNames: ["that", "userIsModerator"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserIsMuted(
      {required Subreddit that, required bool userIsMuted}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(userIsMuted, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 457)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserIsMutedConstMeta,
      argValues: [that, userIsMuted],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserIsMutedConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_is_muted",
            argNames: ["that", "userIsMuted"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserIsSubscriber(
      {required Subreddit that, required bool userIsSubscriber}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(userIsSubscriber, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 458)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserIsSubscriberConstMeta,
      argValues: [that, userIsSubscriber],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserIsSubscriberConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_is_subscriber",
            argNames: ["that", "userIsSubscriber"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserSrFlairEnabled(
      {required Subreddit that, bool? userSrFlairEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_bool(userSrFlairEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 459)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserSrFlairEnabledConstMeta,
      argValues: [that, userSrFlairEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserSrFlairEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_sr_flair_enabled",
            argNames: ["that", "userSrFlairEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetUserSrThemeEnabled(
      {required Subreddit that, required bool userSrThemeEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_bool(userSrThemeEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 460)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetUserSrThemeEnabledConstMeta,
      argValues: [that, userSrThemeEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetUserSrThemeEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_user_sr_theme_enabled",
            argNames: ["that", "userSrThemeEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetWikiEnabled(
      {required Subreddit that, bool? wikiEnabled}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_bool(wikiEnabled, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 461)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditSubredditAutoAccessorSetWikiEnabledConstMeta,
      argValues: [that, wikiEnabled],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetWikiEnabledConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_wiki_enabled",
            argNames: ["that", "wikiEnabled"],
          );

  @override
  void redditApiModelSubredditSubredditAutoAccessorSetWls(
      {required Subreddit that, BigInt? wls}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            that, serializer);
        sse_encode_opt_box_autoadd_u_64(wls, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 462)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditAutoAccessorSetWlsConstMeta,
      argValues: [that, wls],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditSubredditAutoAccessorSetWlsConstMeta =>
          const TaskConstMeta(
            debugName: "Subreddit_auto_accessor_set_wls",
            argNames: ["that", "wls"],
          );

  @override
  Future<Subreddit> redditApiModelSubredditSubredditDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 463, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditSubredditDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditSubredditDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "Subreddit_default",
        argNames: [],
      );

  @override
  Future<CommentContributionSettings>
      redditApiModelSubredditCommentContributionSettingsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 464, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_comment_contribution_settings,
        decodeErrorData: null,
      ),
      constMeta:
          kRedditApiModelSubredditCommentContributionSettingsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kRedditApiModelSubredditCommentContributionSettingsDefaultConstMeta =>
          const TaskConstMeta(
            debugName: "comment_contribution_settings_default",
            argNames: [],
          );

  @override
  Future<Features> redditApiModelUserFeaturesDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 465, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_features,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelUserFeaturesDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelUserFeaturesDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "features_default",
        argNames: [],
      );

  @override
  Future<Feed> redditApiModelFeedFeedDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 466, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_feed,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelFeedFeedDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelFeedFeedDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "feed_default",
        argNames: [],
      );

  @override
  Future<Gallery> redditApiModelPostGalleryDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 467, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_gallery,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostGalleryDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostGalleryDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "gallery_default",
        argNames: [],
      );

  @override
  Future<Gildings> redditApiModelPostGildingsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 468, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_gildings,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostGildingsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostGildingsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "gildings_default",
        argNames: [],
      );

  @override
  Future<ImageBase> redditApiModelPostImageBaseDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 469, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_image_base,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostImageBaseDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostImageBaseDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "image_base_default",
        argNames: [],
      );

  @override
  Future<void> crateApiSimpleInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 470, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<MediaEmbed> redditApiModelPostMediaEmbedDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 471, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_media_embed,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostMediaEmbedDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostMediaEmbedDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "media_embed_default",
        argNames: [],
      );

  @override
  Future<Multi> redditApiModelMultiMultiDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 472, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_multi,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiMultiDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiMultiDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "multi_default",
        argNames: [],
      );

  @override
  Future<NotificationLevel> redditApiModelSubredditNotificationLevelDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 473, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_notification_level,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSubredditNotificationLevelDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSubredditNotificationLevelDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "notification_level_default",
        argNames: [],
      );

  @override
  Future<Preferences> redditApiModelUserPreferencesDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 474, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_preferences,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelUserPreferencesDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelUserPreferencesDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "preferences_default",
        argNames: [],
      );

  @override
  Future<Preview> redditApiModelPostPreviewDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 475, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_preview,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostPreviewDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostPreviewDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "preview_default",
        argNames: [],
      );

  @override
  Client crateApiSimpleRedditApiClient() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 476)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleRedditApiClientConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleRedditApiClientConstMeta =>
      const TaskConstMeta(
        debugName: "reddit_api_client",
        argNames: [],
      );

  @override
  Future<RedditImage> redditApiModelPostRedditImageDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 477, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_reddit_image,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostRedditImageDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostRedditImageDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "reddit_image_default",
        argNames: [],
      );

  @override
  Future<SecureMediaEmbed> redditApiModelPostSecureMediaEmbedDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 478, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_secure_media_embed,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostSecureMediaEmbedDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostSecureMediaEmbedDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "secure_media_embed_default",
        argNames: [],
      );

  @override
  Future<Snoovatar> redditApiModelUserSnoovatarDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 479, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_snoovatar,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelUserSnoovatarDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelUserSnoovatarDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "snoovatar_default",
        argNames: [],
      );

  @override
  Future<Url> redditApiModelSortAddToUrl(
      {required Sort that, required Url url}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_sort(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
            url, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 480, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelSortAddToUrlConstMeta,
      argValues: [that, url],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelSortAddToUrlConstMeta => const TaskConstMeta(
        debugName: "sort_add_to_url",
        argNames: ["that", "url"],
      );

  @override
  Future<SubredditName> redditApiModelMultiSubredditNameDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 481, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_subreddit_name,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelMultiSubredditNameDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelMultiSubredditNameDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "subreddit_name_default",
        argNames: [],
      );

  @override
  Future<User> redditApiModelUserUserDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 482, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_user,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelUserUserDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelUserUserDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "user_default",
        argNames: [],
      );

  @override
  Future<UserInfo> redditApiModelUserUserInfoDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 483, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_user_info,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelUserUserInfoDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelUserUserInfoDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "user_info_default",
        argNames: [],
      );

  @override
  Future<UserSubreddit> redditApiModelUserUserSubredditDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 484, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_user_subreddit,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelUserUserSubredditDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelUserUserSubredditDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "user_subreddit_default",
        argNames: [],
      );

  @override
  Future<Variants> redditApiModelPostVariantsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 485, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_variants,
        decodeErrorData: null,
      ),
      constMeta: kRedditApiModelPostVariantsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kRedditApiModelPostVariantsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "variants_default",
        argNames: [],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_AuthorInfo => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_AuthorInfo => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Client => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Client => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_FeedState => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_FeedState => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_FeedStream => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_FeedStream => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Flair =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Flair =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Fullname => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Fullname => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Listing => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Listing => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Media =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Media =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Oembed => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Oembed => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Pager =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Pager =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Post =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Post =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_PostId => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_PostId => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_RedditVideo => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRedditVideo;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_RedditVideo => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRedditVideo;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SecureMedia => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SecureMedia => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Subreddit => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Subreddit => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SubredditId => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SubredditId => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SubredditInfo => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SubredditInfo => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Url => wire
      .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Url => wire
      .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  AuthorInfo
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AuthorInfoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Client
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FeedState
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FeedStateImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FeedStream
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FeedStreamImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Flair
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FlairImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Fullname
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FullnameImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Listing
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ListingImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Media
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Oembed
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OembedImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Pager
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Post
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PostImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PostId
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PostIdImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  RedditVideo
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRedditVideo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RedditVideoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SecureMedia
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SecureMediaImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Subreddit
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubredditId
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditIdImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubredditInfo
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Url dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UrlImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AuthorInfo
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AuthorInfoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FeedState
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FeedStateImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Flair
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FlairImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Listing
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ListingImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Oembed
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OembedImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Pager
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Post
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PostImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Subreddit
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubredditInfo
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  AuthorInfo
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AuthorInfoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Client
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FeedState
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FeedStateImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Flair
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FlairImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Listing
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ListingImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Oembed
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OembedImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Pager
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Post
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PostImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Subreddit
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubredditInfo
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Url dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UrlImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DateTime dco_decode_Chrono_Local(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeTimestamp(ts: dco_decode_i_64(raw).toInt(), isUtc: false);
  }

  @protected
  DateTime dco_decode_Chrono_Utc(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeTimestamp(ts: dco_decode_i_64(raw).toInt(), isUtc: true);
  }

  @protected
  Map<String, String> dco_decode_Map_String_String_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(dco_decode_list_record_string_string(raw)
        .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  AuthorInfo
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AuthorInfoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Client
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FeedState
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FeedStateImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  FeedStream
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FeedStreamImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Flair
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FlairImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Fullname
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FullnameImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Listing
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ListingImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Media
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MediaImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Oembed
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OembedImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Pager
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Post
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PostImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PostId
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PostIdImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  RedditVideo
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRedditVideo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return RedditVideoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SecureMedia
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SecureMediaImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Subreddit
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubredditId
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditIdImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubredditInfo
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Url dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UrlImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  AuthorInfo
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
        raw);
  }

  @protected
  Media
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
        raw);
  }

  @protected
  Post
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
        raw);
  }

  @protected
  SecureMedia
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
        raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  Feed dco_decode_box_autoadd_feed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_feed(raw);
  }

  @protected
  Gallery dco_decode_box_autoadd_gallery(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_gallery(raw);
  }

  @protected
  PlatformInt64 dco_decode_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_i_64(raw);
  }

  @protected
  MediaEmbed dco_decode_box_autoadd_media_embed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_media_embed(raw);
  }

  @protected
  Multi dco_decode_box_autoadd_multi(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_multi(raw);
  }

  @protected
  Preview dco_decode_box_autoadd_preview(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_preview(raw);
  }

  @protected
  SecureMediaEmbed dco_decode_box_autoadd_secure_media_embed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_secure_media_embed(raw);
  }

  @protected
  Sort dco_decode_box_autoadd_sort(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_sort(raw);
  }

  @protected
  Thumbnail dco_decode_box_autoadd_thumbnail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_thumbnail(raw);
  }

  @protected
  BigInt dco_decode_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_u_64(raw);
  }

  @protected
  User dco_decode_box_autoadd_user(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_user(raw);
  }

  @protected
  CommentContributionSettings dco_decode_comment_contribution_settings(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return CommentContributionSettings(
      allowedMediaTypes: dco_decode_list_String(arr[0]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  Features dco_decode_features(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 25)
      throw Exception('unexpected arr length: expect 25 but see ${arr.length}');
    return Features(
      modmailHarassmentFilter: dco_decode_bool(arr[0]),
      modServiceMuteWrites: dco_decode_bool(arr[1]),
      promotedTrendBlanks: dco_decode_bool(arr[2]),
      showAmpLink: dco_decode_bool(arr[3]),
      isEmailPermissionRequired: dco_decode_bool(arr[4]),
      modAwards: dco_decode_bool(arr[5]),
      expensiveCoinsPackage: dco_decode_bool(arr[6]),
      chatSubreddit: dco_decode_bool(arr[7]),
      awardsOnStreams: dco_decode_bool(arr[8]),
      mwebXpromoModalListingClickDailyDismissibleIos: dco_decode_bool(arr[9]),
      cookieConsentBanner: dco_decode_bool(arr[10]),
      modlogCopyrightRemoval: dco_decode_bool(arr[11]),
      doNotTrack: dco_decode_bool(arr[12]),
      imagesInComments: dco_decode_bool(arr[13]),
      modServiceMuteReads: dco_decode_bool(arr[14]),
      chatUserSettings: dco_decode_bool(arr[15]),
      usePrefAccountDeployment: dco_decode_bool(arr[16]),
      mwebXpromoInterstitialCommentsIos: dco_decode_bool(arr[17]),
      mwebXpromoModalListingClickDailyDismissibleAndroid:
          dco_decode_bool(arr[18]),
      premiumSubscriptionsTable: dco_decode_bool(arr[19]),
      mwebXpromoInterstitialCommentsAndroid: dco_decode_bool(arr[20]),
      crowdControlForPost: dco_decode_bool(arr[21]),
      chatGroupRollout: dco_decode_bool(arr[22]),
      resizedStylesImages: dco_decode_bool(arr[23]),
      noreferrerToNoopener: dco_decode_bool(arr[24]),
    );
  }

  @protected
  Feed dco_decode_feed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Feed_Home();
      case 1:
        return Feed_All();
      case 2:
        return Feed_Popular();
      case 3:
        return Feed_Subreddit(
          dco_decode_String(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Gallery dco_decode_gallery(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.isNotEmpty)
      throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return Gallery();
  }

  @protected
  Gildings dco_decode_gildings(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.isNotEmpty)
      throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return Gildings();
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  ImageBase dco_decode_image_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ImageBase(
      url: dco_decode_String(arr[0]),
      width: dco_decode_i_64(arr[1]),
      height: dco_decode_i_64(arr[2]),
    );
  }

  @protected
  Kind dco_decode_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Kind.values[raw as int];
  }

  @protected
  List<Subreddit>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit)
        .toList();
  }

  @protected
  List<Map<String, String>> dco_decode_list_Map_String_String_None(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_Map_String_String_None)
        .toList();
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<ImageBase> dco_decode_list_image_base(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_image_base).toList();
  }

  @protected
  List<Multi> dco_decode_list_multi(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_multi).toList();
  }

  @protected
  List<String?> dco_decode_list_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_opt_String).toList();
  }

  @protected
  Int64List dco_decode_list_prim_i_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeInt64List(raw);
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  Uint64List dco_decode_list_prim_usize_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint64List;
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  List<RedditImage> dco_decode_list_reddit_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_reddit_image).toList();
  }

  @protected
  List<SubredditName> dco_decode_list_subreddit_name(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_subreddit_name).toList();
  }

  @protected
  List<Thing> dco_decode_list_thing(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_thing).toList();
  }

  @protected
  MediaEmbed dco_decode_media_embed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return MediaEmbed(
      content: dco_decode_String(arr[0]),
      width: dco_decode_i_64(arr[1]),
      scrolling: dco_decode_bool(arr[2]),
      height: dco_decode_i_64(arr[3]),
    );
  }

  @protected
  Multi dco_decode_multi(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 19)
      throw Exception('unexpected arr length: expect 19 but see ${arr.length}');
    return Multi(
      canEdit: dco_decode_bool(arr[0]),
      displayName: dco_decode_String(arr[1]),
      name: dco_decode_String(arr[2]),
      descriptionHtml: dco_decode_String(arr[3]),
      numSubscribers: dco_decode_i_64(arr[4]),
      copiedFrom: dco_decode_opt_String(arr[5]),
      iconUrl: dco_decode_String(arr[6]),
      subreddits: dco_decode_list_subreddit_name(arr[7]),
      createdUtc: dco_decode_f_64(arr[8]),
      visibility: dco_decode_String(arr[9]),
      created: dco_decode_f_64(arr[10]),
      over18: dco_decode_bool(arr[11]),
      path: dco_decode_String(arr[12]),
      owner: dco_decode_String(arr[13]),
      keyColor: dco_decode_opt_String(arr[14]),
      isSubscriber: dco_decode_bool(arr[15]),
      ownerId: dco_decode_String(arr[16]),
      descriptionMd: dco_decode_String(arr[17]),
      isFavorited: dco_decode_bool(arr[18]),
    );
  }

  @protected
  NotificationLevel dco_decode_notification_level(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NotificationLevel.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  AuthorInfo?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
            raw);
  }

  @protected
  Media?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
            raw);
  }

  @protected
  Post?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            raw);
  }

  @protected
  SecureMedia?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
            raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_64(raw);
  }

  @protected
  Gallery? dco_decode_opt_box_autoadd_gallery(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_gallery(raw);
  }

  @protected
  PlatformInt64? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  MediaEmbed? dco_decode_opt_box_autoadd_media_embed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_media_embed(raw);
  }

  @protected
  Preview? dco_decode_opt_box_autoadd_preview(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_preview(raw);
  }

  @protected
  SecureMediaEmbed? dco_decode_opt_box_autoadd_secure_media_embed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_secure_media_embed(raw);
  }

  @protected
  Thumbnail? dco_decode_opt_box_autoadd_thumbnail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_thumbnail(raw);
  }

  @protected
  BigInt? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  Int64List? dco_decode_opt_list_prim_i_64_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_i_64_strict(raw);
  }

  @protected
  UsizeArray2? dco_decode_opt_usize_array_2(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_usize_array_2(raw);
  }

  @protected
  Preferences dco_decode_preferences(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return Preferences(
      prefAutoplay: dco_decode_bool(arr[0]),
      prefVideoAutoplay: dco_decode_bool(arr[1]),
      prefNoProfanity: dco_decode_bool(arr[2]),
      prefGeopopular: dco_decode_String(arr[3]),
      prefShowTrending: dco_decode_bool(arr[4]),
      prefShowPresence: dco_decode_bool(arr[5]),
      prefNightmode: dco_decode_bool(arr[6]),
      prefTopKarmaSubreddits: dco_decode_bool(arr[7]),
      prefClickgadget: dco_decode_i_64(arr[8]),
      prefShowTwitter: dco_decode_bool(arr[9]),
    );
  }

  @protected
  Preview dco_decode_preview(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Preview(
      images: dco_decode_list_reddit_image(arr[0]),
      enabled: dco_decode_bool(arr[1]),
    );
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  RedditAPI dco_decode_reddit_api(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.isNotEmpty)
      throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return RedditAPI();
  }

  @protected
  RedditImage dco_decode_reddit_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return RedditImage(
      source: dco_decode_image_base(arr[0]),
      resolutions: dco_decode_list_image_base(arr[1]),
      variants: dco_decode_variants(arr[2]),
      id: dco_decode_String(arr[3]),
    );
  }

  @protected
  SecureMediaEmbed dco_decode_secure_media_embed(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return SecureMediaEmbed(
      content: dco_decode_String(arr[0]),
      width: dco_decode_i_64(arr[1]),
      scrolling: dco_decode_bool(arr[2]),
      mediaDomainUrl: dco_decode_String(arr[3]),
      height: dco_decode_i_64(arr[4]),
    );
  }

  @protected
  Snoovatar dco_decode_snoovatar(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Snoovatar(
      prefShowSnoovatar: dco_decode_bool(arr[0]),
      snoovatarSize: dco_decode_opt_String(arr[1]),
      snoovatarImg: dco_decode_String(arr[2]),
    );
  }

  @protected
  Sort dco_decode_sort(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Sort_Best();
      case 1:
        return Sort_Hot();
      case 2:
        return Sort_New(
          dco_decode_timeframe(raw[1]),
        );
      case 3:
        return Sort_Top(
          dco_decode_timeframe(raw[1]),
        );
      case 4:
        return Sort_Rising();
      case 5:
        return Sort_Controversial(
          dco_decode_timeframe(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  SubredditName dco_decode_subreddit_name(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return SubredditName(
      name: dco_decode_String(arr[0]),
    );
  }

  @protected
  Thing dco_decode_thing(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return Thing_Listing(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
              raw[1]),
        );
      case 1:
        return Thing_Comment();
      case 2:
        return Thing_User(
          dco_decode_box_autoadd_user(raw[1]),
        );
      case 3:
        return Thing_Post(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
              raw[1]),
        );
      case 4:
        return Thing_Message();
      case 5:
        return Thing_Subreddit(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
              raw[1]),
        );
      case 6:
        return Thing_Award();
      case 7:
        return Thing_Multi(
          dco_decode_box_autoadd_multi(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Thumbnail dco_decode_thumbnail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return Thumbnail(
      url: dco_decode_String(arr[0]),
      height: dco_decode_u_64(arr[1]),
      width: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  Timeframe dco_decode_timeframe(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Timeframe.values[raw as int];
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  User dco_decode_user(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 28)
      throw Exception('unexpected arr length: expect 28 but see ${arr.length}');
    return User(
      info: dco_decode_user_info(arr[0]),
      goldExpiration: dco_decode_opt_String(arr[1]),
      hasGoldSubscription: dco_decode_bool(arr[2]),
      isSponsor: dco_decode_bool(arr[3]),
      numFriends: dco_decode_i_64(arr[4]),
      features: dco_decode_features(arr[5]),
      canEditName: dco_decode_bool(arr[6]),
      newModmailExists: dco_decode_opt_String(arr[7]),
      coins: dco_decode_i_64(arr[8]),
      canCreateSubreddit: dco_decode_bool(arr[9]),
      suspensionExpirationUtc: dco_decode_opt_box_autoadd_f_32(arr[10]),
      hasStripeSubscription: dco_decode_bool(arr[11]),
      hasAndroidSubscription: dco_decode_bool(arr[12]),
      hasModMail: dco_decode_bool(arr[13]),
      hasMail: dco_decode_bool(arr[14]),
      hasPaypalSubscription: dco_decode_bool(arr[15]),
      hasSubscribedToPremium: dco_decode_bool(arr[16]),
      inRedesignBeta: dco_decode_bool(arr[17]),
      passwordSet: dco_decode_bool(arr[18]),
      modhash: dco_decode_String(arr[19]),
      isSuspended: dco_decode_bool(arr[20]),
      forcePasswordReset: dco_decode_bool(arr[21]),
      inboxCount: dco_decode_i_64(arr[22]),
      goldCreddits: dco_decode_i_64(arr[23]),
      hasIosSubscription: dco_decode_bool(arr[24]),
      inBeta: dco_decode_bool(arr[25]),
      hasVisitedNewProfile: dco_decode_bool(arr[26]),
      hasExternalAccount: dco_decode_bool(arr[27]),
    );
  }

  @protected
  UserInfo dco_decode_user_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 24)
      throw Exception('unexpected arr length: expect 24 but see ${arr.length}');
    return UserInfo(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      subreddit: dco_decode_user_subreddit(arr[2]),
      created: dco_decode_f_64(arr[3]),
      over18: dco_decode_bool(arr[4]),
      createdUtc: dco_decode_f_64(arr[5]),
      isBlocked: dco_decode_bool(arr[6]),
      isEmployee: dco_decode_bool(arr[7]),
      isFriend: dco_decode_bool(arr[8]),
      awardeeKarma: dco_decode_i_64(arr[9]),
      isGold: dco_decode_bool(arr[10]),
      isMod: dco_decode_bool(arr[11]),
      verified: dco_decode_bool(arr[12]),
      awarderKarma: dco_decode_i_64(arr[13]),
      hasVerifiedEmail: dco_decode_bool(arr[14]),
      hasSubscribed: dco_decode_bool(arr[15]),
      iconImg: dco_decode_String(arr[16]),
      hideFromRobots: dco_decode_bool(arr[17]),
      linkKarma: dco_decode_i_64(arr[18]),
      totalKarma: dco_decode_i_64(arr[19]),
      commentKarma: dco_decode_i_64(arr[20]),
      acceptFollowers: dco_decode_bool(arr[21]),
      acceptChats: dco_decode_bool(arr[22]),
      acceptPms: dco_decode_bool(arr[23]),
    );
  }

  @protected
  UserSubreddit dco_decode_user_subreddit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 40)
      throw Exception('unexpected arr length: expect 40 but see ${arr.length}');
    return UserSubreddit(
      defaultSet: dco_decode_bool(arr[0]),
      userIsContributor: dco_decode_bool(arr[1]),
      bannerImg: dco_decode_String(arr[2]),
      allowedMediaInComments: dco_decode_list_String(arr[3]),
      userIsBanned: dco_decode_bool(arr[4]),
      freeFormReports: dco_decode_bool(arr[5]),
      communityIcon: dco_decode_opt_String(arr[6]),
      showMedia: dco_decode_bool(arr[7]),
      iconColor: dco_decode_String(arr[8]),
      userIsMuted: dco_decode_opt_box_autoadd_bool(arr[9]),
      displayName: dco_decode_String(arr[10]),
      headerImg: dco_decode_opt_String(arr[11]),
      title: dco_decode_String(arr[12]),
      coins: dco_decode_i_64(arr[13]),
      previousNames: dco_decode_list_String(arr[14]),
      over18: dco_decode_bool(arr[15]),
      iconSize: dco_decode_list_prim_i_64_strict(arr[16]),
      primaryColor: dco_decode_String(arr[17]),
      iconImg: dco_decode_String(arr[18]),
      description: dco_decode_String(arr[19]),
      submitLinkLabel: dco_decode_String(arr[20]),
      headerSize: dco_decode_opt_String(arr[21]),
      restrictPosting: dco_decode_bool(arr[22]),
      restrictCommenting: dco_decode_bool(arr[23]),
      subscribers: dco_decode_i_64(arr[24]),
      submitTextLabel: dco_decode_String(arr[25]),
      isDefaultIcon: dco_decode_bool(arr[26]),
      linkFlairPosition: dco_decode_String(arr[27]),
      displayNamePrefixed: dco_decode_String(arr[28]),
      keyColor: dco_decode_String(arr[29]),
      isDefaultBanner: dco_decode_bool(arr[30]),
      url: dco_decode_String(arr[31]),
      quarantine: dco_decode_bool(arr[32]),
      bannerSize: dco_decode_opt_String(arr[33]),
      userIsModerator: dco_decode_bool(arr[34]),
      publicDescription: dco_decode_String(arr[35]),
      linkFlairEnabled: dco_decode_bool(arr[36]),
      disableContributorRequests: dco_decode_bool(arr[37]),
      subredditType: dco_decode_String(arr[38]),
      userIsSubscriber: dco_decode_bool(arr[39]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  UsizeArray2 dco_decode_usize_array_2(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UsizeArray2(dco_decode_list_prim_usize_strict(raw));
  }

  @protected
  Variants dco_decode_variants(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.isNotEmpty)
      throw Exception('unexpected arr length: expect 0 but see ${arr.length}');
    return Variants();
  }

  @protected
  VoteDirection dco_decode_vote_direction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VoteDirection.values[raw as int];
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  AuthorInfo
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AuthorInfoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Client
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  FeedState
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FeedStateImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  FeedStream
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FeedStreamImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Flair
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FlairImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Fullname
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FullnameImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Listing
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ListingImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Media
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Oembed
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OembedImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Pager
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Post
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PostImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PostId
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PostIdImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  RedditVideo
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRedditVideo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return RedditVideoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SecureMedia
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SecureMediaImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Subreddit
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubredditId
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditIdImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubredditInfo
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Url sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return UrlImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AuthorInfo
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AuthorInfoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  FeedState
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FeedStateImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Flair
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FlairImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Listing
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ListingImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Oembed
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OembedImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Pager
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Post
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PostImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Subreddit
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubredditInfo
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  AuthorInfo
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AuthorInfoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Client
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  FeedState
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FeedStateImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Flair
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FlairImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Listing
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ListingImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Oembed
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OembedImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Pager
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Post
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PostImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Subreddit
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubredditInfo
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Url sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return UrlImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DateTime sse_decode_Chrono_Local(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_64(deserializer);
    return DateTime.fromMicrosecondsSinceEpoch(inner.toInt(), isUtc: false);
  }

  @protected
  DateTime sse_decode_Chrono_Utc(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_64(deserializer);
    return DateTime.fromMicrosecondsSinceEpoch(inner.toInt(), isUtc: true);
  }

  @protected
  Map<String, String> sse_decode_Map_String_String_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_record_string_string(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  AuthorInfo
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return AuthorInfoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Client
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  FeedState
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FeedStateImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  FeedStream
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FeedStreamImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Flair
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FlairImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Fullname
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return FullnameImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Listing
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ListingImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Media
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MediaImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Oembed
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return OembedImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Pager
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Post
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PostImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PostId
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PostIdImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  RedditVideo
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRedditVideo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return RedditVideoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SecureMedia
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SecureMediaImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Subreddit
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubredditId
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditIdImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubredditInfo
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubredditInfoImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Url sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return UrlImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  AuthorInfo
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
        deserializer));
  }

  @protected
  Media
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
        deserializer));
  }

  @protected
  Post
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
        deserializer));
  }

  @protected
  SecureMedia
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
        deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_64(deserializer));
  }

  @protected
  Feed sse_decode_box_autoadd_feed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_feed(deserializer));
  }

  @protected
  Gallery sse_decode_box_autoadd_gallery(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_gallery(deserializer));
  }

  @protected
  PlatformInt64 sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_64(deserializer));
  }

  @protected
  MediaEmbed sse_decode_box_autoadd_media_embed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_media_embed(deserializer));
  }

  @protected
  Multi sse_decode_box_autoadd_multi(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_multi(deserializer));
  }

  @protected
  Preview sse_decode_box_autoadd_preview(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_preview(deserializer));
  }

  @protected
  SecureMediaEmbed sse_decode_box_autoadd_secure_media_embed(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_secure_media_embed(deserializer));
  }

  @protected
  Sort sse_decode_box_autoadd_sort(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_sort(deserializer));
  }

  @protected
  Thumbnail sse_decode_box_autoadd_thumbnail(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_thumbnail(deserializer));
  }

  @protected
  BigInt sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_64(deserializer));
  }

  @protected
  User sse_decode_box_autoadd_user(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_user(deserializer));
  }

  @protected
  CommentContributionSettings sse_decode_comment_contribution_settings(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_allowedMediaTypes = sse_decode_list_String(deserializer);
    return CommentContributionSettings(
        allowedMediaTypes: var_allowedMediaTypes);
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  Features sse_decode_features(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_modmailHarassmentFilter = sse_decode_bool(deserializer);
    var var_modServiceMuteWrites = sse_decode_bool(deserializer);
    var var_promotedTrendBlanks = sse_decode_bool(deserializer);
    var var_showAmpLink = sse_decode_bool(deserializer);
    var var_isEmailPermissionRequired = sse_decode_bool(deserializer);
    var var_modAwards = sse_decode_bool(deserializer);
    var var_expensiveCoinsPackage = sse_decode_bool(deserializer);
    var var_chatSubreddit = sse_decode_bool(deserializer);
    var var_awardsOnStreams = sse_decode_bool(deserializer);
    var var_mwebXpromoModalListingClickDailyDismissibleIos =
        sse_decode_bool(deserializer);
    var var_cookieConsentBanner = sse_decode_bool(deserializer);
    var var_modlogCopyrightRemoval = sse_decode_bool(deserializer);
    var var_doNotTrack = sse_decode_bool(deserializer);
    var var_imagesInComments = sse_decode_bool(deserializer);
    var var_modServiceMuteReads = sse_decode_bool(deserializer);
    var var_chatUserSettings = sse_decode_bool(deserializer);
    var var_usePrefAccountDeployment = sse_decode_bool(deserializer);
    var var_mwebXpromoInterstitialCommentsIos = sse_decode_bool(deserializer);
    var var_mwebXpromoModalListingClickDailyDismissibleAndroid =
        sse_decode_bool(deserializer);
    var var_premiumSubscriptionsTable = sse_decode_bool(deserializer);
    var var_mwebXpromoInterstitialCommentsAndroid =
        sse_decode_bool(deserializer);
    var var_crowdControlForPost = sse_decode_bool(deserializer);
    var var_chatGroupRollout = sse_decode_bool(deserializer);
    var var_resizedStylesImages = sse_decode_bool(deserializer);
    var var_noreferrerToNoopener = sse_decode_bool(deserializer);
    return Features(
        modmailHarassmentFilter: var_modmailHarassmentFilter,
        modServiceMuteWrites: var_modServiceMuteWrites,
        promotedTrendBlanks: var_promotedTrendBlanks,
        showAmpLink: var_showAmpLink,
        isEmailPermissionRequired: var_isEmailPermissionRequired,
        modAwards: var_modAwards,
        expensiveCoinsPackage: var_expensiveCoinsPackage,
        chatSubreddit: var_chatSubreddit,
        awardsOnStreams: var_awardsOnStreams,
        mwebXpromoModalListingClickDailyDismissibleIos:
            var_mwebXpromoModalListingClickDailyDismissibleIos,
        cookieConsentBanner: var_cookieConsentBanner,
        modlogCopyrightRemoval: var_modlogCopyrightRemoval,
        doNotTrack: var_doNotTrack,
        imagesInComments: var_imagesInComments,
        modServiceMuteReads: var_modServiceMuteReads,
        chatUserSettings: var_chatUserSettings,
        usePrefAccountDeployment: var_usePrefAccountDeployment,
        mwebXpromoInterstitialCommentsIos:
            var_mwebXpromoInterstitialCommentsIos,
        mwebXpromoModalListingClickDailyDismissibleAndroid:
            var_mwebXpromoModalListingClickDailyDismissibleAndroid,
        premiumSubscriptionsTable: var_premiumSubscriptionsTable,
        mwebXpromoInterstitialCommentsAndroid:
            var_mwebXpromoInterstitialCommentsAndroid,
        crowdControlForPost: var_crowdControlForPost,
        chatGroupRollout: var_chatGroupRollout,
        resizedStylesImages: var_resizedStylesImages,
        noreferrerToNoopener: var_noreferrerToNoopener);
  }

  @protected
  Feed sse_decode_feed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return Feed_Home();
      case 1:
        return Feed_All();
      case 2:
        return Feed_Popular();
      case 3:
        var var_field0 = sse_decode_String(deserializer);
        return Feed_Subreddit(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Gallery sse_decode_gallery(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Gallery();
  }

  @protected
  Gildings sse_decode_gildings(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Gildings();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  ImageBase sse_decode_image_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_width = sse_decode_i_64(deserializer);
    var var_height = sse_decode_i_64(deserializer);
    return ImageBase(url: var_url, width: var_width, height: var_height);
  }

  @protected
  Kind sse_decode_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Kind.values[inner];
  }

  @protected
  List<Subreddit>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Subreddit>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<Map<String, String>> sse_decode_list_Map_String_String_None(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Map<String, String>>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_Map_String_String_None(deserializer));
    }
    return ans_;
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<ImageBase> sse_decode_list_image_base(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ImageBase>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_image_base(deserializer));
    }
    return ans_;
  }

  @protected
  List<Multi> sse_decode_list_multi(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Multi>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_multi(deserializer));
    }
    return ans_;
  }

  @protected
  List<String?> sse_decode_list_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String?>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_opt_String(deserializer));
    }
    return ans_;
  }

  @protected
  Int64List sse_decode_list_prim_i_64_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt64List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint64List sse_decode_list_prim_usize_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  List<RedditImage> sse_decode_list_reddit_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <RedditImage>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_reddit_image(deserializer));
    }
    return ans_;
  }

  @protected
  List<SubredditName> sse_decode_list_subreddit_name(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SubredditName>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_subreddit_name(deserializer));
    }
    return ans_;
  }

  @protected
  List<Thing> sse_decode_list_thing(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Thing>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_thing(deserializer));
    }
    return ans_;
  }

  @protected
  MediaEmbed sse_decode_media_embed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_content = sse_decode_String(deserializer);
    var var_width = sse_decode_i_64(deserializer);
    var var_scrolling = sse_decode_bool(deserializer);
    var var_height = sse_decode_i_64(deserializer);
    return MediaEmbed(
        content: var_content,
        width: var_width,
        scrolling: var_scrolling,
        height: var_height);
  }

  @protected
  Multi sse_decode_multi(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_canEdit = sse_decode_bool(deserializer);
    var var_displayName = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_descriptionHtml = sse_decode_String(deserializer);
    var var_numSubscribers = sse_decode_i_64(deserializer);
    var var_copiedFrom = sse_decode_opt_String(deserializer);
    var var_iconUrl = sse_decode_String(deserializer);
    var var_subreddits = sse_decode_list_subreddit_name(deserializer);
    var var_createdUtc = sse_decode_f_64(deserializer);
    var var_visibility = sse_decode_String(deserializer);
    var var_created = sse_decode_f_64(deserializer);
    var var_over18 = sse_decode_bool(deserializer);
    var var_path = sse_decode_String(deserializer);
    var var_owner = sse_decode_String(deserializer);
    var var_keyColor = sse_decode_opt_String(deserializer);
    var var_isSubscriber = sse_decode_bool(deserializer);
    var var_ownerId = sse_decode_String(deserializer);
    var var_descriptionMd = sse_decode_String(deserializer);
    var var_isFavorited = sse_decode_bool(deserializer);
    return Multi(
        canEdit: var_canEdit,
        displayName: var_displayName,
        name: var_name,
        descriptionHtml: var_descriptionHtml,
        numSubscribers: var_numSubscribers,
        copiedFrom: var_copiedFrom,
        iconUrl: var_iconUrl,
        subreddits: var_subreddits,
        createdUtc: var_createdUtc,
        visibility: var_visibility,
        created: var_created,
        over18: var_over18,
        path: var_path,
        owner: var_owner,
        keyColor: var_keyColor,
        isSubscriber: var_isSubscriber,
        ownerId: var_ownerId,
        descriptionMd: var_descriptionMd,
        isFavorited: var_isFavorited);
  }

  @protected
  NotificationLevel sse_decode_notification_level(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return NotificationLevel.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  AuthorInfo?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  Media?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  Post?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  SecureMedia?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Gallery? sse_decode_opt_box_autoadd_gallery(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_gallery(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PlatformInt64? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  MediaEmbed? sse_decode_opt_box_autoadd_media_embed(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_media_embed(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Preview? sse_decode_opt_box_autoadd_preview(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_preview(deserializer));
    } else {
      return null;
    }
  }

  @protected
  SecureMediaEmbed? sse_decode_opt_box_autoadd_secure_media_embed(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_secure_media_embed(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Thumbnail? sse_decode_opt_box_autoadd_thumbnail(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_thumbnail(deserializer));
    } else {
      return null;
    }
  }

  @protected
  BigInt? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Int64List? sse_decode_opt_list_prim_i_64_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_i_64_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  UsizeArray2? sse_decode_opt_usize_array_2(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_usize_array_2(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Preferences sse_decode_preferences(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_prefAutoplay = sse_decode_bool(deserializer);
    var var_prefVideoAutoplay = sse_decode_bool(deserializer);
    var var_prefNoProfanity = sse_decode_bool(deserializer);
    var var_prefGeopopular = sse_decode_String(deserializer);
    var var_prefShowTrending = sse_decode_bool(deserializer);
    var var_prefShowPresence = sse_decode_bool(deserializer);
    var var_prefNightmode = sse_decode_bool(deserializer);
    var var_prefTopKarmaSubreddits = sse_decode_bool(deserializer);
    var var_prefClickgadget = sse_decode_i_64(deserializer);
    var var_prefShowTwitter = sse_decode_bool(deserializer);
    return Preferences(
        prefAutoplay: var_prefAutoplay,
        prefVideoAutoplay: var_prefVideoAutoplay,
        prefNoProfanity: var_prefNoProfanity,
        prefGeopopular: var_prefGeopopular,
        prefShowTrending: var_prefShowTrending,
        prefShowPresence: var_prefShowPresence,
        prefNightmode: var_prefNightmode,
        prefTopKarmaSubreddits: var_prefTopKarmaSubreddits,
        prefClickgadget: var_prefClickgadget,
        prefShowTwitter: var_prefShowTwitter);
  }

  @protected
  Preview sse_decode_preview(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_images = sse_decode_list_reddit_image(deserializer);
    var var_enabled = sse_decode_bool(deserializer);
    return Preview(images: var_images, enabled: var_enabled);
  }

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  RedditAPI sse_decode_reddit_api(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return RedditAPI();
  }

  @protected
  RedditImage sse_decode_reddit_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_source = sse_decode_image_base(deserializer);
    var var_resolutions = sse_decode_list_image_base(deserializer);
    var var_variants = sse_decode_variants(deserializer);
    var var_id = sse_decode_String(deserializer);
    return RedditImage(
        source: var_source,
        resolutions: var_resolutions,
        variants: var_variants,
        id: var_id);
  }

  @protected
  SecureMediaEmbed sse_decode_secure_media_embed(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_content = sse_decode_String(deserializer);
    var var_width = sse_decode_i_64(deserializer);
    var var_scrolling = sse_decode_bool(deserializer);
    var var_mediaDomainUrl = sse_decode_String(deserializer);
    var var_height = sse_decode_i_64(deserializer);
    return SecureMediaEmbed(
        content: var_content,
        width: var_width,
        scrolling: var_scrolling,
        mediaDomainUrl: var_mediaDomainUrl,
        height: var_height);
  }

  @protected
  Snoovatar sse_decode_snoovatar(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_prefShowSnoovatar = sse_decode_bool(deserializer);
    var var_snoovatarSize = sse_decode_opt_String(deserializer);
    var var_snoovatarImg = sse_decode_String(deserializer);
    return Snoovatar(
        prefShowSnoovatar: var_prefShowSnoovatar,
        snoovatarSize: var_snoovatarSize,
        snoovatarImg: var_snoovatarImg);
  }

  @protected
  Sort sse_decode_sort(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return Sort_Best();
      case 1:
        return Sort_Hot();
      case 2:
        var var_field0 = sse_decode_timeframe(deserializer);
        return Sort_New(var_field0);
      case 3:
        var var_field0 = sse_decode_timeframe(deserializer);
        return Sort_Top(var_field0);
      case 4:
        return Sort_Rising();
      case 5:
        var var_field0 = sse_decode_timeframe(deserializer);
        return Sort_Controversial(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  SubredditName sse_decode_subreddit_name(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    return SubredditName(name: var_name);
  }

  @protected
  Thing sse_decode_thing(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
                deserializer);
        return Thing_Listing(var_field0);
      case 1:
        return Thing_Comment();
      case 2:
        var var_field0 = sse_decode_box_autoadd_user(deserializer);
        return Thing_User(var_field0);
      case 3:
        var var_field0 =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
                deserializer);
        return Thing_Post(var_field0);
      case 4:
        return Thing_Message();
      case 5:
        var var_field0 =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
                deserializer);
        return Thing_Subreddit(var_field0);
      case 6:
        return Thing_Award();
      case 7:
        var var_field0 = sse_decode_box_autoadd_multi(deserializer);
        return Thing_Multi(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Thumbnail sse_decode_thumbnail(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_url = sse_decode_String(deserializer);
    var var_height = sse_decode_u_64(deserializer);
    var var_width = sse_decode_u_64(deserializer);
    return Thumbnail(url: var_url, height: var_height, width: var_width);
  }

  @protected
  Timeframe sse_decode_timeframe(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Timeframe.values[inner];
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  User sse_decode_user(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_info = sse_decode_user_info(deserializer);
    var var_goldExpiration = sse_decode_opt_String(deserializer);
    var var_hasGoldSubscription = sse_decode_bool(deserializer);
    var var_isSponsor = sse_decode_bool(deserializer);
    var var_numFriends = sse_decode_i_64(deserializer);
    var var_features = sse_decode_features(deserializer);
    var var_canEditName = sse_decode_bool(deserializer);
    var var_newModmailExists = sse_decode_opt_String(deserializer);
    var var_coins = sse_decode_i_64(deserializer);
    var var_canCreateSubreddit = sse_decode_bool(deserializer);
    var var_suspensionExpirationUtc =
        sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_hasStripeSubscription = sse_decode_bool(deserializer);
    var var_hasAndroidSubscription = sse_decode_bool(deserializer);
    var var_hasModMail = sse_decode_bool(deserializer);
    var var_hasMail = sse_decode_bool(deserializer);
    var var_hasPaypalSubscription = sse_decode_bool(deserializer);
    var var_hasSubscribedToPremium = sse_decode_bool(deserializer);
    var var_inRedesignBeta = sse_decode_bool(deserializer);
    var var_passwordSet = sse_decode_bool(deserializer);
    var var_modhash = sse_decode_String(deserializer);
    var var_isSuspended = sse_decode_bool(deserializer);
    var var_forcePasswordReset = sse_decode_bool(deserializer);
    var var_inboxCount = sse_decode_i_64(deserializer);
    var var_goldCreddits = sse_decode_i_64(deserializer);
    var var_hasIosSubscription = sse_decode_bool(deserializer);
    var var_inBeta = sse_decode_bool(deserializer);
    var var_hasVisitedNewProfile = sse_decode_bool(deserializer);
    var var_hasExternalAccount = sse_decode_bool(deserializer);
    return User(
        info: var_info,
        goldExpiration: var_goldExpiration,
        hasGoldSubscription: var_hasGoldSubscription,
        isSponsor: var_isSponsor,
        numFriends: var_numFriends,
        features: var_features,
        canEditName: var_canEditName,
        newModmailExists: var_newModmailExists,
        coins: var_coins,
        canCreateSubreddit: var_canCreateSubreddit,
        suspensionExpirationUtc: var_suspensionExpirationUtc,
        hasStripeSubscription: var_hasStripeSubscription,
        hasAndroidSubscription: var_hasAndroidSubscription,
        hasModMail: var_hasModMail,
        hasMail: var_hasMail,
        hasPaypalSubscription: var_hasPaypalSubscription,
        hasSubscribedToPremium: var_hasSubscribedToPremium,
        inRedesignBeta: var_inRedesignBeta,
        passwordSet: var_passwordSet,
        modhash: var_modhash,
        isSuspended: var_isSuspended,
        forcePasswordReset: var_forcePasswordReset,
        inboxCount: var_inboxCount,
        goldCreddits: var_goldCreddits,
        hasIosSubscription: var_hasIosSubscription,
        inBeta: var_inBeta,
        hasVisitedNewProfile: var_hasVisitedNewProfile,
        hasExternalAccount: var_hasExternalAccount);
  }

  @protected
  UserInfo sse_decode_user_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_subreddit = sse_decode_user_subreddit(deserializer);
    var var_created = sse_decode_f_64(deserializer);
    var var_over18 = sse_decode_bool(deserializer);
    var var_createdUtc = sse_decode_f_64(deserializer);
    var var_isBlocked = sse_decode_bool(deserializer);
    var var_isEmployee = sse_decode_bool(deserializer);
    var var_isFriend = sse_decode_bool(deserializer);
    var var_awardeeKarma = sse_decode_i_64(deserializer);
    var var_isGold = sse_decode_bool(deserializer);
    var var_isMod = sse_decode_bool(deserializer);
    var var_verified = sse_decode_bool(deserializer);
    var var_awarderKarma = sse_decode_i_64(deserializer);
    var var_hasVerifiedEmail = sse_decode_bool(deserializer);
    var var_hasSubscribed = sse_decode_bool(deserializer);
    var var_iconImg = sse_decode_String(deserializer);
    var var_hideFromRobots = sse_decode_bool(deserializer);
    var var_linkKarma = sse_decode_i_64(deserializer);
    var var_totalKarma = sse_decode_i_64(deserializer);
    var var_commentKarma = sse_decode_i_64(deserializer);
    var var_acceptFollowers = sse_decode_bool(deserializer);
    var var_acceptChats = sse_decode_bool(deserializer);
    var var_acceptPms = sse_decode_bool(deserializer);
    return UserInfo(
        id: var_id,
        name: var_name,
        subreddit: var_subreddit,
        created: var_created,
        over18: var_over18,
        createdUtc: var_createdUtc,
        isBlocked: var_isBlocked,
        isEmployee: var_isEmployee,
        isFriend: var_isFriend,
        awardeeKarma: var_awardeeKarma,
        isGold: var_isGold,
        isMod: var_isMod,
        verified: var_verified,
        awarderKarma: var_awarderKarma,
        hasVerifiedEmail: var_hasVerifiedEmail,
        hasSubscribed: var_hasSubscribed,
        iconImg: var_iconImg,
        hideFromRobots: var_hideFromRobots,
        linkKarma: var_linkKarma,
        totalKarma: var_totalKarma,
        commentKarma: var_commentKarma,
        acceptFollowers: var_acceptFollowers,
        acceptChats: var_acceptChats,
        acceptPms: var_acceptPms);
  }

  @protected
  UserSubreddit sse_decode_user_subreddit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_defaultSet = sse_decode_bool(deserializer);
    var var_userIsContributor = sse_decode_bool(deserializer);
    var var_bannerImg = sse_decode_String(deserializer);
    var var_allowedMediaInComments = sse_decode_list_String(deserializer);
    var var_userIsBanned = sse_decode_bool(deserializer);
    var var_freeFormReports = sse_decode_bool(deserializer);
    var var_communityIcon = sse_decode_opt_String(deserializer);
    var var_showMedia = sse_decode_bool(deserializer);
    var var_iconColor = sse_decode_String(deserializer);
    var var_userIsMuted = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_displayName = sse_decode_String(deserializer);
    var var_headerImg = sse_decode_opt_String(deserializer);
    var var_title = sse_decode_String(deserializer);
    var var_coins = sse_decode_i_64(deserializer);
    var var_previousNames = sse_decode_list_String(deserializer);
    var var_over18 = sse_decode_bool(deserializer);
    var var_iconSize = sse_decode_list_prim_i_64_strict(deserializer);
    var var_primaryColor = sse_decode_String(deserializer);
    var var_iconImg = sse_decode_String(deserializer);
    var var_description = sse_decode_String(deserializer);
    var var_submitLinkLabel = sse_decode_String(deserializer);
    var var_headerSize = sse_decode_opt_String(deserializer);
    var var_restrictPosting = sse_decode_bool(deserializer);
    var var_restrictCommenting = sse_decode_bool(deserializer);
    var var_subscribers = sse_decode_i_64(deserializer);
    var var_submitTextLabel = sse_decode_String(deserializer);
    var var_isDefaultIcon = sse_decode_bool(deserializer);
    var var_linkFlairPosition = sse_decode_String(deserializer);
    var var_displayNamePrefixed = sse_decode_String(deserializer);
    var var_keyColor = sse_decode_String(deserializer);
    var var_isDefaultBanner = sse_decode_bool(deserializer);
    var var_url = sse_decode_String(deserializer);
    var var_quarantine = sse_decode_bool(deserializer);
    var var_bannerSize = sse_decode_opt_String(deserializer);
    var var_userIsModerator = sse_decode_bool(deserializer);
    var var_publicDescription = sse_decode_String(deserializer);
    var var_linkFlairEnabled = sse_decode_bool(deserializer);
    var var_disableContributorRequests = sse_decode_bool(deserializer);
    var var_subredditType = sse_decode_String(deserializer);
    var var_userIsSubscriber = sse_decode_bool(deserializer);
    return UserSubreddit(
        defaultSet: var_defaultSet,
        userIsContributor: var_userIsContributor,
        bannerImg: var_bannerImg,
        allowedMediaInComments: var_allowedMediaInComments,
        userIsBanned: var_userIsBanned,
        freeFormReports: var_freeFormReports,
        communityIcon: var_communityIcon,
        showMedia: var_showMedia,
        iconColor: var_iconColor,
        userIsMuted: var_userIsMuted,
        displayName: var_displayName,
        headerImg: var_headerImg,
        title: var_title,
        coins: var_coins,
        previousNames: var_previousNames,
        over18: var_over18,
        iconSize: var_iconSize,
        primaryColor: var_primaryColor,
        iconImg: var_iconImg,
        description: var_description,
        submitLinkLabel: var_submitLinkLabel,
        headerSize: var_headerSize,
        restrictPosting: var_restrictPosting,
        restrictCommenting: var_restrictCommenting,
        subscribers: var_subscribers,
        submitTextLabel: var_submitTextLabel,
        isDefaultIcon: var_isDefaultIcon,
        linkFlairPosition: var_linkFlairPosition,
        displayNamePrefixed: var_displayNamePrefixed,
        keyColor: var_keyColor,
        isDefaultBanner: var_isDefaultBanner,
        url: var_url,
        quarantine: var_quarantine,
        bannerSize: var_bannerSize,
        userIsModerator: var_userIsModerator,
        publicDescription: var_publicDescription,
        linkFlairEnabled: var_linkFlairEnabled,
        disableContributorRequests: var_disableContributorRequests,
        subredditType: var_subredditType,
        userIsSubscriber: var_userIsSubscriber);
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  UsizeArray2 sse_decode_usize_array_2(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_usize_strict(deserializer);
    return UsizeArray2(inner);
  }

  @protected
  Variants sse_decode_variants(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Variants();
  }

  @protected
  VoteDirection sse_decode_vote_direction(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return VoteDirection.values[inner];
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          AuthorInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as AuthorInfoImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          Client self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ClientImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
          FeedState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FeedStateImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream(
          FeedStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FeedStreamImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
          Flair self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FlairImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          Fullname self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FullnameImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          Listing self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ListingImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          Media self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MediaImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
          Oembed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as OembedImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          Pager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PagerImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          Post self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PostImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
          PostId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PostIdImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRedditVideo(
          RedditVideo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as RedditVideoImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          SecureMedia self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SecureMediaImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          Subreddit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
          SubredditId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditIdImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SubredditInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditInfoImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
          Url self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as UrlImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          AuthorInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as AuthorInfoImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
          FeedState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FeedStateImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
          Flair self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FlairImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          Listing self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ListingImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
          Oembed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as OembedImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          Pager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PagerImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          Post self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PostImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          Subreddit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SubredditInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditInfoImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          AuthorInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as AuthorInfoImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          Client self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ClientImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
          FeedState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FeedStateImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
          Flair self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FlairImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          Listing self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ListingImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
          Oembed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as OembedImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          Pager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PagerImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          Post self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PostImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          Subreddit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SubredditInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditInfoImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
          Url self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as UrlImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_Chrono_Local(DateTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(
        PlatformInt64Util.from(self.microsecondsSinceEpoch), serializer);
  }

  @protected
  void sse_encode_Chrono_Utc(DateTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(
        PlatformInt64Util.from(self.microsecondsSinceEpoch), serializer);
  }

  @protected
  void sse_encode_Map_String_String_None(
      Map<String, String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_string(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          AuthorInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as AuthorInfoImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerClient(
          Client self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ClientImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedState(
          FeedState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FeedStateImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFeedStream(
          FeedStream self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FeedStreamImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFlair(
          Flair self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FlairImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerFullname(
          Fullname self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as FullnameImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
          Listing self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ListingImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          Media self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MediaImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerOembed(
          Oembed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as OembedImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPager(
          Pager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PagerImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          Post self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PostImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPostID(
          PostId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PostIdImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerRedditVideo(
          RedditVideo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as RedditVideoImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          SecureMedia self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SecureMediaImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          Subreddit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditID(
          SubredditId self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditIdImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubredditInfo(
          SubredditInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubredditInfoImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerUrl(
          Url self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as UrlImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          AuthorInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
        self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          Media self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
        self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          Post self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
        self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          SecureMedia self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
        self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_feed(Feed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_feed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_gallery(Gallery self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_gallery(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(
      PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_media_embed(
      MediaEmbed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_media_embed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_multi(Multi self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_multi(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_preview(Preview self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_preview(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_secure_media_embed(
      SecureMediaEmbed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_secure_media_embed(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sort(Sort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_sort(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_thumbnail(
      Thumbnail self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_thumbnail(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_user(User self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user(self, serializer);
  }

  @protected
  void sse_encode_comment_contribution_settings(
      CommentContributionSettings self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_String(self.allowedMediaTypes, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_features(Features self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.modmailHarassmentFilter, serializer);
    sse_encode_bool(self.modServiceMuteWrites, serializer);
    sse_encode_bool(self.promotedTrendBlanks, serializer);
    sse_encode_bool(self.showAmpLink, serializer);
    sse_encode_bool(self.isEmailPermissionRequired, serializer);
    sse_encode_bool(self.modAwards, serializer);
    sse_encode_bool(self.expensiveCoinsPackage, serializer);
    sse_encode_bool(self.chatSubreddit, serializer);
    sse_encode_bool(self.awardsOnStreams, serializer);
    sse_encode_bool(
        self.mwebXpromoModalListingClickDailyDismissibleIos, serializer);
    sse_encode_bool(self.cookieConsentBanner, serializer);
    sse_encode_bool(self.modlogCopyrightRemoval, serializer);
    sse_encode_bool(self.doNotTrack, serializer);
    sse_encode_bool(self.imagesInComments, serializer);
    sse_encode_bool(self.modServiceMuteReads, serializer);
    sse_encode_bool(self.chatUserSettings, serializer);
    sse_encode_bool(self.usePrefAccountDeployment, serializer);
    sse_encode_bool(self.mwebXpromoInterstitialCommentsIos, serializer);
    sse_encode_bool(
        self.mwebXpromoModalListingClickDailyDismissibleAndroid, serializer);
    sse_encode_bool(self.premiumSubscriptionsTable, serializer);
    sse_encode_bool(self.mwebXpromoInterstitialCommentsAndroid, serializer);
    sse_encode_bool(self.crowdControlForPost, serializer);
    sse_encode_bool(self.chatGroupRollout, serializer);
    sse_encode_bool(self.resizedStylesImages, serializer);
    sse_encode_bool(self.noreferrerToNoopener, serializer);
  }

  @protected
  void sse_encode_feed(Feed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Feed_Home():
        sse_encode_i_32(0, serializer);
      case Feed_All():
        sse_encode_i_32(1, serializer);
      case Feed_Popular():
        sse_encode_i_32(2, serializer);
      case Feed_Subreddit(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_String(field0, serializer);
    }
  }

  @protected
  void sse_encode_gallery(Gallery self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_gildings(Gildings self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_image_base(ImageBase self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_i_64(self.width, serializer);
    sse_encode_i_64(self.height, serializer);
  }

  @protected
  void sse_encode_kind(Kind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          List<Subreddit> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
          item, serializer);
    }
  }

  @protected
  void sse_encode_list_Map_String_String_None(
      List<Map<String, String>> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Map_String_String_None(item, serializer);
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_image_base(
      List<ImageBase> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_image_base(item, serializer);
    }
  }

  @protected
  void sse_encode_list_multi(List<Multi> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_multi(item, serializer);
    }
  }

  @protected
  void sse_encode_list_opt_String(
      List<String?> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_opt_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_i_64_strict(
      Int64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt64List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_prim_usize_strict(
      Uint64List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_record_string_string(
      List<(String, String)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_list_reddit_image(
      List<RedditImage> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_reddit_image(item, serializer);
    }
  }

  @protected
  void sse_encode_list_subreddit_name(
      List<SubredditName> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_subreddit_name(item, serializer);
    }
  }

  @protected
  void sse_encode_list_thing(List<Thing> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_thing(item, serializer);
    }
  }

  @protected
  void sse_encode_media_embed(MediaEmbed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.content, serializer);
    sse_encode_i_64(self.width, serializer);
    sse_encode_bool(self.scrolling, serializer);
    sse_encode_i_64(self.height, serializer);
  }

  @protected
  void sse_encode_multi(Multi self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.canEdit, serializer);
    sse_encode_String(self.displayName, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.descriptionHtml, serializer);
    sse_encode_i_64(self.numSubscribers, serializer);
    sse_encode_opt_String(self.copiedFrom, serializer);
    sse_encode_String(self.iconUrl, serializer);
    sse_encode_list_subreddit_name(self.subreddits, serializer);
    sse_encode_f_64(self.createdUtc, serializer);
    sse_encode_String(self.visibility, serializer);
    sse_encode_f_64(self.created, serializer);
    sse_encode_bool(self.over18, serializer);
    sse_encode_String(self.path, serializer);
    sse_encode_String(self.owner, serializer);
    sse_encode_opt_String(self.keyColor, serializer);
    sse_encode_bool(self.isSubscriber, serializer);
    sse_encode_String(self.ownerId, serializer);
    sse_encode_String(self.descriptionMd, serializer);
    sse_encode_bool(self.isFavorited, serializer);
  }

  @protected
  void sse_encode_notification_level(
      NotificationLevel self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          AuthorInfo? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerAuthorInfo(
          self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          Media? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMedia(
          self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          Post? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
          self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          SecureMedia? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSecureMedia(
          self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_64(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_gallery(
      Gallery? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_gallery(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(
      PlatformInt64? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_media_embed(
      MediaEmbed? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_media_embed(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_preview(
      Preview? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_preview(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_secure_media_embed(
      SecureMediaEmbed? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_secure_media_embed(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_thumbnail(
      Thumbnail? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_thumbnail(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(BigInt? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_i_64_strict(
      Int64List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_i_64_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_usize_array_2(
      UsizeArray2? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_usize_array_2(self, serializer);
    }
  }

  @protected
  void sse_encode_preferences(Preferences self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.prefAutoplay, serializer);
    sse_encode_bool(self.prefVideoAutoplay, serializer);
    sse_encode_bool(self.prefNoProfanity, serializer);
    sse_encode_String(self.prefGeopopular, serializer);
    sse_encode_bool(self.prefShowTrending, serializer);
    sse_encode_bool(self.prefShowPresence, serializer);
    sse_encode_bool(self.prefNightmode, serializer);
    sse_encode_bool(self.prefTopKarmaSubreddits, serializer);
    sse_encode_i_64(self.prefClickgadget, serializer);
    sse_encode_bool(self.prefShowTwitter, serializer);
  }

  @protected
  void sse_encode_preview(Preview self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_reddit_image(self.images, serializer);
    sse_encode_bool(self.enabled, serializer);
  }

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_reddit_api(RedditAPI self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_reddit_image(RedditImage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_image_base(self.source, serializer);
    sse_encode_list_image_base(self.resolutions, serializer);
    sse_encode_variants(self.variants, serializer);
    sse_encode_String(self.id, serializer);
  }

  @protected
  void sse_encode_secure_media_embed(
      SecureMediaEmbed self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.content, serializer);
    sse_encode_i_64(self.width, serializer);
    sse_encode_bool(self.scrolling, serializer);
    sse_encode_String(self.mediaDomainUrl, serializer);
    sse_encode_i_64(self.height, serializer);
  }

  @protected
  void sse_encode_snoovatar(Snoovatar self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.prefShowSnoovatar, serializer);
    sse_encode_opt_String(self.snoovatarSize, serializer);
    sse_encode_String(self.snoovatarImg, serializer);
  }

  @protected
  void sse_encode_sort(Sort self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Sort_Best():
        sse_encode_i_32(0, serializer);
      case Sort_Hot():
        sse_encode_i_32(1, serializer);
      case Sort_New(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_timeframe(field0, serializer);
      case Sort_Top(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_timeframe(field0, serializer);
      case Sort_Rising():
        sse_encode_i_32(4, serializer);
      case Sort_Controversial(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_timeframe(field0, serializer);
    }
  }

  @protected
  void sse_encode_subreddit_name(SubredditName self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
  }

  @protected
  void sse_encode_thing(Thing self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Thing_Listing(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerListing(
            field0, serializer);
      case Thing_Comment():
        sse_encode_i_32(1, serializer);
      case Thing_User(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_box_autoadd_user(field0, serializer);
      case Thing_Post(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPost(
            field0, serializer);
      case Thing_Message():
        sse_encode_i_32(4, serializer);
      case Thing_Subreddit(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubreddit(
            field0, serializer);
      case Thing_Award():
        sse_encode_i_32(6, serializer);
      case Thing_Multi(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_box_autoadd_multi(field0, serializer);
    }
  }

  @protected
  void sse_encode_thumbnail(Thumbnail self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.url, serializer);
    sse_encode_u_64(self.height, serializer);
    sse_encode_u_64(self.width, serializer);
  }

  @protected
  void sse_encode_timeframe(Timeframe self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_user(User self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user_info(self.info, serializer);
    sse_encode_opt_String(self.goldExpiration, serializer);
    sse_encode_bool(self.hasGoldSubscription, serializer);
    sse_encode_bool(self.isSponsor, serializer);
    sse_encode_i_64(self.numFriends, serializer);
    sse_encode_features(self.features, serializer);
    sse_encode_bool(self.canEditName, serializer);
    sse_encode_opt_String(self.newModmailExists, serializer);
    sse_encode_i_64(self.coins, serializer);
    sse_encode_bool(self.canCreateSubreddit, serializer);
    sse_encode_opt_box_autoadd_f_32(self.suspensionExpirationUtc, serializer);
    sse_encode_bool(self.hasStripeSubscription, serializer);
    sse_encode_bool(self.hasAndroidSubscription, serializer);
    sse_encode_bool(self.hasModMail, serializer);
    sse_encode_bool(self.hasMail, serializer);
    sse_encode_bool(self.hasPaypalSubscription, serializer);
    sse_encode_bool(self.hasSubscribedToPremium, serializer);
    sse_encode_bool(self.inRedesignBeta, serializer);
    sse_encode_bool(self.passwordSet, serializer);
    sse_encode_String(self.modhash, serializer);
    sse_encode_bool(self.isSuspended, serializer);
    sse_encode_bool(self.forcePasswordReset, serializer);
    sse_encode_i_64(self.inboxCount, serializer);
    sse_encode_i_64(self.goldCreddits, serializer);
    sse_encode_bool(self.hasIosSubscription, serializer);
    sse_encode_bool(self.inBeta, serializer);
    sse_encode_bool(self.hasVisitedNewProfile, serializer);
    sse_encode_bool(self.hasExternalAccount, serializer);
  }

  @protected
  void sse_encode_user_info(UserInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_user_subreddit(self.subreddit, serializer);
    sse_encode_f_64(self.created, serializer);
    sse_encode_bool(self.over18, serializer);
    sse_encode_f_64(self.createdUtc, serializer);
    sse_encode_bool(self.isBlocked, serializer);
    sse_encode_bool(self.isEmployee, serializer);
    sse_encode_bool(self.isFriend, serializer);
    sse_encode_i_64(self.awardeeKarma, serializer);
    sse_encode_bool(self.isGold, serializer);
    sse_encode_bool(self.isMod, serializer);
    sse_encode_bool(self.verified, serializer);
    sse_encode_i_64(self.awarderKarma, serializer);
    sse_encode_bool(self.hasVerifiedEmail, serializer);
    sse_encode_bool(self.hasSubscribed, serializer);
    sse_encode_String(self.iconImg, serializer);
    sse_encode_bool(self.hideFromRobots, serializer);
    sse_encode_i_64(self.linkKarma, serializer);
    sse_encode_i_64(self.totalKarma, serializer);
    sse_encode_i_64(self.commentKarma, serializer);
    sse_encode_bool(self.acceptFollowers, serializer);
    sse_encode_bool(self.acceptChats, serializer);
    sse_encode_bool(self.acceptPms, serializer);
  }

  @protected
  void sse_encode_user_subreddit(UserSubreddit self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.defaultSet, serializer);
    sse_encode_bool(self.userIsContributor, serializer);
    sse_encode_String(self.bannerImg, serializer);
    sse_encode_list_String(self.allowedMediaInComments, serializer);
    sse_encode_bool(self.userIsBanned, serializer);
    sse_encode_bool(self.freeFormReports, serializer);
    sse_encode_opt_String(self.communityIcon, serializer);
    sse_encode_bool(self.showMedia, serializer);
    sse_encode_String(self.iconColor, serializer);
    sse_encode_opt_box_autoadd_bool(self.userIsMuted, serializer);
    sse_encode_String(self.displayName, serializer);
    sse_encode_opt_String(self.headerImg, serializer);
    sse_encode_String(self.title, serializer);
    sse_encode_i_64(self.coins, serializer);
    sse_encode_list_String(self.previousNames, serializer);
    sse_encode_bool(self.over18, serializer);
    sse_encode_list_prim_i_64_strict(self.iconSize, serializer);
    sse_encode_String(self.primaryColor, serializer);
    sse_encode_String(self.iconImg, serializer);
    sse_encode_String(self.description, serializer);
    sse_encode_String(self.submitLinkLabel, serializer);
    sse_encode_opt_String(self.headerSize, serializer);
    sse_encode_bool(self.restrictPosting, serializer);
    sse_encode_bool(self.restrictCommenting, serializer);
    sse_encode_i_64(self.subscribers, serializer);
    sse_encode_String(self.submitTextLabel, serializer);
    sse_encode_bool(self.isDefaultIcon, serializer);
    sse_encode_String(self.linkFlairPosition, serializer);
    sse_encode_String(self.displayNamePrefixed, serializer);
    sse_encode_String(self.keyColor, serializer);
    sse_encode_bool(self.isDefaultBanner, serializer);
    sse_encode_String(self.url, serializer);
    sse_encode_bool(self.quarantine, serializer);
    sse_encode_opt_String(self.bannerSize, serializer);
    sse_encode_bool(self.userIsModerator, serializer);
    sse_encode_String(self.publicDescription, serializer);
    sse_encode_bool(self.linkFlairEnabled, serializer);
    sse_encode_bool(self.disableContributorRequests, serializer);
    sse_encode_String(self.subredditType, serializer);
    sse_encode_bool(self.userIsSubscriber, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_usize_array_2(UsizeArray2 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_usize_strict(self.inner, serializer);
  }

  @protected
  void sse_encode_variants(Variants self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_vote_direction(VoteDirection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }
}

@sealed
class AuthorInfoImpl extends RustOpaque implements AuthorInfo {
  // Not to be used by end users
  AuthorInfoImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  AuthorInfoImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_AuthorInfo,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_AuthorInfo,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_AuthorInfoPtr,
  );

  Flair get flair =>
      RustLib.instance.api.redditApiModelPostAuthorInfoAutoAccessorGetFlair(
        that: this,
      );

  String get fullname =>
      RustLib.instance.api.redditApiModelPostAuthorInfoAutoAccessorGetFullname(
        that: this,
      );

  bool get isBlocked =>
      RustLib.instance.api.redditApiModelPostAuthorInfoAutoAccessorGetIsBlocked(
        that: this,
      );

  bool get patreonFlair => RustLib.instance.api
          .redditApiModelPostAuthorInfoAutoAccessorGetPatreonFlair(
        that: this,
      );

  bool get premium =>
      RustLib.instance.api.redditApiModelPostAuthorInfoAutoAccessorGetPremium(
        that: this,
      );

  String get username =>
      RustLib.instance.api.redditApiModelPostAuthorInfoAutoAccessorGetUsername(
        that: this,
      );

  set flair(Flair flair) =>
      RustLib.instance.api.redditApiModelPostAuthorInfoAutoAccessorSetFlair(
          that: this, flair: flair);

  set fullname(String fullname) =>
      RustLib.instance.api.redditApiModelPostAuthorInfoAutoAccessorSetFullname(
          that: this, fullname: fullname);

  set isBlocked(bool isBlocked) =>
      RustLib.instance.api.redditApiModelPostAuthorInfoAutoAccessorSetIsBlocked(
          that: this, isBlocked: isBlocked);

  set patreonFlair(bool patreonFlair) => RustLib.instance.api
      .redditApiModelPostAuthorInfoAutoAccessorSetPatreonFlair(
          that: this, patreonFlair: patreonFlair);

  set premium(bool premium) =>
      RustLib.instance.api.redditApiModelPostAuthorInfoAutoAccessorSetPremium(
          that: this, premium: premium);

  set username(String username) =>
      RustLib.instance.api.redditApiModelPostAuthorInfoAutoAccessorSetUsername(
          that: this, username: username);
}

@sealed
class ClientImpl extends RustOpaque implements Client {
  // Not to be used by end users
  ClientImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ClientImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Client,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Client,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ClientPtr,
  );

  /// Authenticate the current client
  Future<void> authenticate({required String refreshToken}) =>
      RustLib.instance.api.redditApiClientClientAuthenticate(
          that: this, refreshToken: refreshToken);

  /// Get the info of the current user.
  /// # Errors
  /// Returns an error if the http client fails or if the parsing of the response fails.
  Future<UserInfo> loggedUserInfo() =>
      RustLib.instance.api.redditApiClientClientLoggedUserInfo(
        that: this,
      );

  /// Get the list of multireddits the current user is subscribed to.
  /// # Errors
  /// Returns an error if the http client fails or if the parsing of the response fails.
  Future<List<Multi>> multis() =>
      RustLib.instance.api.redditApiClientClientMultis(
        that: this,
      );

  /// Save a saveable item (i.e. a [`Post`] or a [`Comment`]).
  /// # Errors
  /// Returns an error if the request failed.
  Future<void> save({required Fullname thing}) =>
      RustLib.instance.api.redditApiClientClientSave(that: this, thing: thing);

  /// Get the list of subreddits the current user is subscribed to.
  /// # Errors
  /// Returns an error if the http client fails or if the parsing of the response fails.
  Future<List<Subreddit>> subsriptions() =>
      RustLib.instance.api.redditApiClientClientSubsriptions(
        that: this,
      );

  /// Unsave a saveable item (i.e. a [`Post`] or a [`Comment`]).
  /// # Errors
  /// Returns an error if the request failed.
  Future<void> unsave({required Fullname thing}) => RustLib.instance.api
      .redditApiClientClientUnsave(that: this, thing: thing);

  /// Vote on a votable item (i.e. a [`Post`] or a [`Comment`]).
  /// # Errors
  /// Returns an error if the request failed.
  Future<void> vote(
          {required Fullname thing, required VoteDirection direction}) =>
      RustLib.instance.api.redditApiClientClientVote(
          that: this, thing: thing, direction: direction);
}

@sealed
class FeedStateImpl extends RustOpaque implements FeedState {
  // Not to be used by end users
  FeedStateImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  FeedStateImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_FeedState,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_FeedState,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_FeedStatePtr,
  );

  bool get done => RustLib.instance.api.crateApiSimpleFeedStateGetDone(
        that: this,
      );

  Feed get feed => RustLib.instance.api.crateApiSimpleFeedStateGetFeed(
        that: this,
      );

  int get length => RustLib.instance.api.crateApiSimpleFeedStateGetLength(
        that: this,
      );

  bool get loading => RustLib.instance.api.crateApiSimpleFeedStateGetLoading(
        that: this,
      );

  Sort get sort => RustLib.instance.api.crateApiSimpleFeedStateGetSort(
        that: this,
      );

  String get sortString =>
      RustLib.instance.api.crateApiSimpleFeedStateGetSortString(
        that: this,
      );

  String get title => RustLib.instance.api.crateApiSimpleFeedStateGetTitle(
        that: this,
      );

  /// Returns true if there is no more posts to load
  Future<bool> next() => RustLib.instance.api.crateApiSimpleFeedStateNext(
        that: this,
      );

  Post? nth({required int n}) =>
      RustLib.instance.api.crateApiSimpleFeedStateNth(that: this, n: n);

  Future<void> refresh() => RustLib.instance.api.crateApiSimpleFeedStateRefresh(
        that: this,
      );

  set feed(Feed feed) => RustLib.instance.api
      .crateApiSimpleFeedStateSetFeed(that: this, feed: feed);

  set sort(Sort sort) => RustLib.instance.api
      .crateApiSimpleFeedStateSetSort(that: this, sort: sort);
}

@sealed
class FeedStreamImpl extends RustOpaque implements FeedStream {
  // Not to be used by end users
  FeedStreamImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  FeedStreamImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_FeedStream,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_FeedStream,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_FeedStreamPtr,
  );
}

@sealed
class FlairImpl extends RustOpaque implements Flair {
  // Not to be used by end users
  FlairImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  FlairImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Flair,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Flair,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_FlairPtr,
  );

  String? get cssClass =>
      RustLib.instance.api.redditApiModelFlairFlairAutoAccessorGetCssClass(
        that: this,
      );

  String? get flairType =>
      RustLib.instance.api.redditApiModelFlairFlairAutoAccessorGetFlairType(
        that: this,
      );

  String? get position =>
      RustLib.instance.api.redditApiModelFlairFlairAutoAccessorGetPosition(
        that: this,
      );

  List<Map<String, String>> get richtext =>
      RustLib.instance.api.redditApiModelFlairFlairAutoAccessorGetRichtext(
        that: this,
      );

  String? get templateId =>
      RustLib.instance.api.redditApiModelFlairFlairAutoAccessorGetTemplateId(
        that: this,
      );

  String? get text =>
      RustLib.instance.api.redditApiModelFlairFlairAutoAccessorGetText(
        that: this,
      );

  set cssClass(String? cssClass) =>
      RustLib.instance.api.redditApiModelFlairFlairAutoAccessorSetCssClass(
          that: this, cssClass: cssClass);

  set flairType(String? flairType) =>
      RustLib.instance.api.redditApiModelFlairFlairAutoAccessorSetFlairType(
          that: this, flairType: flairType);

  set position(String? position) =>
      RustLib.instance.api.redditApiModelFlairFlairAutoAccessorSetPosition(
          that: this, position: position);

  set richtext(List<Map<String, String>> richtext) =>
      RustLib.instance.api.redditApiModelFlairFlairAutoAccessorSetRichtext(
          that: this, richtext: richtext);

  set templateId(String? templateId) =>
      RustLib.instance.api.redditApiModelFlairFlairAutoAccessorSetTemplateId(
          that: this, templateId: templateId);

  set text(String? text) => RustLib.instance.api
      .redditApiModelFlairFlairAutoAccessorSetText(that: this, text: text);
}

@sealed
class FullnameImpl extends RustOpaque implements Fullname {
  // Not to be used by end users
  FullnameImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  FullnameImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Fullname,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Fullname,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_FullnamePtr,
  );
}

@sealed
class ListingImpl extends RustOpaque implements Listing {
  // Not to be used by end users
  ListingImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ListingImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Listing,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Listing,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ListingPtr,
  );

  String? get after =>
      RustLib.instance.api.redditApiModelListingAutoAccessorGetAfter(
        that: this,
      );

  String? get before =>
      RustLib.instance.api.redditApiModelListingAutoAccessorGetBefore(
        that: this,
      );

  List<Thing> get children =>
      RustLib.instance.api.redditApiModelListingAutoAccessorGetChildren(
        that: this,
      );

  BigInt get dist =>
      RustLib.instance.api.redditApiModelListingAutoAccessorGetDist(
        that: this,
      );

  String? get modhash =>
      RustLib.instance.api.redditApiModelListingAutoAccessorGetModhash(
        that: this,
      );

  set after(String? after) => RustLib.instance.api
      .redditApiModelListingAutoAccessorSetAfter(that: this, after: after);

  set before(String? before) => RustLib.instance.api
      .redditApiModelListingAutoAccessorSetBefore(that: this, before: before);

  set children(List<Thing> children) =>
      RustLib.instance.api.redditApiModelListingAutoAccessorSetChildren(
          that: this, children: children);

  set dist(BigInt dist) => RustLib.instance.api
      .redditApiModelListingAutoAccessorSetDist(that: this, dist: dist);

  set modhash(String? modhash) =>
      RustLib.instance.api.redditApiModelListingAutoAccessorSetModhash(
          that: this, modhash: modhash);
}

@sealed
class MediaImpl extends RustOpaque implements Media {
  // Not to be used by end users
  MediaImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MediaImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Media,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Media,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_MediaPtr,
  );
}

@sealed
class OembedImpl extends RustOpaque implements Oembed {
  // Not to be used by end users
  OembedImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  OembedImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Oembed,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Oembed,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_OembedPtr,
  );

  String get authorName =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorGetAuthorName(
        that: this,
      );

  String get authorUrl =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorGetAuthorUrl(
        that: this,
      );

  PlatformInt64 get height =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorGetHeight(
        that: this,
      );

  String get html =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorGetHtml(
        that: this,
      );

  String get providerName =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorGetProviderName(
        that: this,
      );

  String get providerUrl =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorGetProviderUrl(
        that: this,
      );

  String get title =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorGetTitle(
        that: this,
      );

  String get typeField =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorGetTypeField(
        that: this,
      );

  String get version =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorGetVersion(
        that: this,
      );

  PlatformInt64 get width =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorGetWidth(
        that: this,
      );

  set authorName(String authorName) =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorSetAuthorName(
          that: this, authorName: authorName);

  set authorUrl(String authorUrl) =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorSetAuthorUrl(
          that: this, authorUrl: authorUrl);

  set height(PlatformInt64 height) =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorSetHeight(
          that: this, height: height);

  set html(String html) => RustLib.instance.api
      .redditApiModelPostOembedAutoAccessorSetHtml(that: this, html: html);

  set providerName(String providerName) =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorSetProviderName(
          that: this, providerName: providerName);

  set providerUrl(String providerUrl) =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorSetProviderUrl(
          that: this, providerUrl: providerUrl);

  set title(String title) => RustLib.instance.api
      .redditApiModelPostOembedAutoAccessorSetTitle(that: this, title: title);

  set typeField(String typeField) =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorSetTypeField(
          that: this, typeField: typeField);

  set version(String version) =>
      RustLib.instance.api.redditApiModelPostOembedAutoAccessorSetVersion(
          that: this, version: version);

  set width(PlatformInt64 width) => RustLib.instance.api
      .redditApiModelPostOembedAutoAccessorSetWidth(that: this, width: width);
}

@sealed
class PagerImpl extends RustOpaque implements Pager {
  // Not to be used by end users
  PagerImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PagerImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Pager,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Pager,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PagerPtr,
  );

  Future<Url> addToUrl({required Url url}) =>
      RustLib.instance.api.redditApiClientPagerAddToUrl(that: this, url: url);

  Future<void> after({String? after}) =>
      RustLib.instance.api.redditApiClientPagerAfter(that: this, after: after);

  Future<void> before({String? before}) => RustLib.instance.api
      .redditApiClientPagerBefore(that: this, before: before);
}

@sealed
class PostIdImpl extends RustOpaque implements PostId {
  // Not to be used by end users
  PostIdImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PostIdImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_PostId,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_PostId,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PostIdPtr,
  );
}

@sealed
class PostImpl extends RustOpaque implements Post {
  // Not to be used by end users
  PostImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PostImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Post,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Post,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PostPtr,
  );

  List<String?> get allAwardings =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetAllAwardings(
        that: this,
      );

  bool get allowLiveComments => RustLib.instance.api
          .redditApiModelPostPostAutoAccessorGetAllowLiveComments(
        that: this,
      );

  double? get approvedAtUtc =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetApprovedAtUtc(
        that: this,
      );

  String? get approvedBy =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetApprovedBy(
        that: this,
      );

  bool get archived =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetArchived(
        that: this,
      );

  AuthorInfo? get author =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetAuthor(
        that: this,
      );

  List<String?> get awarders =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetAwarders(
        that: this,
      );

  double? get bannedAtUtc =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetBannedAtUtc(
        that: this,
      );

  String? get bannedBy =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetBannedBy(
        that: this,
      );

  bool get canGild =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetCanGild(
        that: this,
      );

  bool get canModPost =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetCanModPost(
        that: this,
      );

  String? get category =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetCategory(
        that: this,
      );

  bool get clicked =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetClicked(
        that: this,
      );

  List<String> get contentCategories => RustLib.instance.api
          .redditApiModelPostPostAutoAccessorGetContentCategories(
        that: this,
      );

  bool get contestMode =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetContestMode(
        that: this,
      );

  DateTime get created =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetCreated(
        that: this,
      );

  DateTime get createdUtc =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetCreatedUtc(
        that: this,
      );

  String? get discussionType =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetDiscussionType(
        that: this,
      );

  String? get distinguished =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetDistinguished(
        that: this,
      );

  String get domain =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetDomain(
        that: this,
      );

  PlatformInt64 get downs =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetDowns(
        that: this,
      );

  double? get edited =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetEdited(
        that: this,
      );

  Gallery? get gallery =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetGallery(
        that: this,
      );

  PlatformInt64 get gilded =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetGilded(
        that: this,
      );

  Gildings get gildings =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetGildings(
        that: this,
      );

  bool get hidden =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetHidden(
        that: this,
      );

  bool get hideScore =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetHideScore(
        that: this,
      );

  PostId get id => RustLib.instance.api.redditApiModelPostPostAutoAccessorGetId(
        that: this,
      );

  bool get isCreatedFromAdsUi => RustLib.instance.api
          .redditApiModelPostPostAutoAccessorGetIsCreatedFromAdsUi(
        that: this,
      );

  bool get isCrosspostable =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetIsCrosspostable(
        that: this,
      );

  bool get isMeta =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetIsMeta(
        that: this,
      );

  bool get isOriginalContent => RustLib.instance.api
          .redditApiModelPostPostAutoAccessorGetIsOriginalContent(
        that: this,
      );

  bool get isRedditMediaDomain => RustLib.instance.api
          .redditApiModelPostPostAutoAccessorGetIsRedditMediaDomain(
        that: this,
      );

  bool get isRobotIndexable => RustLib.instance.api
          .redditApiModelPostPostAutoAccessorGetIsRobotIndexable(
        that: this,
      );

  bool get isSelf =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetIsSelf(
        that: this,
      );

  bool get isVideo =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetIsVideo(
        that: this,
      );

  bool? get likes =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetLikes(
        that: this,
      );

  Flair get linkFlair =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetLinkFlair(
        that: this,
      );

  bool get locked =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetLocked(
        that: this,
      );

  Media? get media =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetMedia(
        that: this,
      );

  MediaEmbed? get mediaEmbed =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetMediaEmbed(
        that: this,
      );

  bool get mediaOnly =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetMediaOnly(
        that: this,
      );

  String? get modNote =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetModNote(
        that: this,
      );

  String? get modReasonBy =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetModReasonBy(
        that: this,
      );

  String? get modReasonTitle =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetModReasonTitle(
        that: this,
      );

  List<String?> get modReports =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetModReports(
        that: this,
      );

  Fullname get name =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetName(
        that: this,
      );

  bool get noFollow =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetNoFollow(
        that: this,
      );

  PlatformInt64 get numComments =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetNumComments(
        that: this,
      );

  PlatformInt64? get numCrossposts =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetNumCrossposts(
        that: this,
      );

  BigInt? get numDuplicates =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetNumDuplicates(
        that: this,
      );

  String? get numReports =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetNumReports(
        that: this,
      );

  bool get over18 =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetOver18(
        that: this,
      );

  String get permalink =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetPermalink(
        that: this,
      );

  bool get pinned =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetPinned(
        that: this,
      );

  String? get postHint =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetPostHint(
        that: this,
      );

  Preview? get preview =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetPreview(
        that: this,
      );

  PlatformInt64? get pwls =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetPwls(
        that: this,
      );

  bool get quarantine =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetQuarantine(
        that: this,
      );

  String? get removalReason =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetRemovalReason(
        that: this,
      );

  String? get removedBy =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetRemovedBy(
        that: this,
      );

  String? get removedByCategory => RustLib.instance.api
          .redditApiModelPostPostAutoAccessorGetRemovedByCategory(
        that: this,
      );

  String? get reportReasons =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetReportReasons(
        that: this,
      );

  bool get saved =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetSaved(
        that: this,
      );

  PlatformInt64 get score =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetScore(
        that: this,
      );

  SecureMedia? get secureMedia =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetSecureMedia(
        that: this,
      );

  SecureMediaEmbed? get secureMediaEmbed => RustLib.instance.api
          .redditApiModelPostPostAutoAccessorGetSecureMediaEmbed(
        that: this,
      );

  String? get selftext =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetSelftext(
        that: this,
      );

  String? get selftextHtml =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetSelftextHtml(
        that: this,
      );

  bool get sendReplies =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetSendReplies(
        that: this,
      );

  bool get spoiler =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetSpoiler(
        that: this,
      );

  bool get stickied =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetStickied(
        that: this,
      );

  SubredditInfo get subreddit =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetSubreddit(
        that: this,
      );

  String? get suggestedSort =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetSuggestedSort(
        that: this,
      );

  String get title =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetTitle(
        that: this,
      );

  String? get topAwardedType =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetTopAwardedType(
        that: this,
      );

  PlatformInt64? get totalAwardsReceived => RustLib.instance.api
          .redditApiModelPostPostAutoAccessorGetTotalAwardsReceived(
        that: this,
      );

  List<String?> get treatmentTags =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetTreatmentTags(
        that: this,
      );

  PlatformInt64 get ups =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetUps(
        that: this,
      );

  double get upvoteRatio =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetUpvoteRatio(
        that: this,
      );

  String get url =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetUrl(
        that: this,
      );

  String? get urlOverriddenByDest => RustLib.instance.api
          .redditApiModelPostPostAutoAccessorGetUrlOverriddenByDest(
        that: this,
      );

  List<String?> get userReports =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetUserReports(
        that: this,
      );

  String? get viewCount =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetViewCount(
        that: this,
      );

  bool get visited =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetVisited(
        that: this,
      );

  PlatformInt64? get wls =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorGetWls(
        that: this,
      );

  set allAwardings(List<String?> allAwardings) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetAllAwardings(
          that: this, allAwardings: allAwardings);

  set allowLiveComments(bool allowLiveComments) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetAllowLiveComments(
          that: this, allowLiveComments: allowLiveComments);

  set approvedAtUtc(double? approvedAtUtc) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetApprovedAtUtc(
          that: this, approvedAtUtc: approvedAtUtc);

  set approvedBy(String? approvedBy) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetApprovedBy(
          that: this, approvedBy: approvedBy);

  set archived(bool archived) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetArchived(
          that: this, archived: archived);

  set author(AuthorInfo? author) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetAuthor(that: this, author: author);

  set awarders(List<String?> awarders) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetAwarders(
          that: this, awarders: awarders);

  set bannedAtUtc(double? bannedAtUtc) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetBannedAtUtc(
          that: this, bannedAtUtc: bannedAtUtc);

  set bannedBy(String? bannedBy) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetBannedBy(
          that: this, bannedBy: bannedBy);

  set canGild(bool canGild) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetCanGild(
          that: this, canGild: canGild);

  set canModPost(bool canModPost) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetCanModPost(
          that: this, canModPost: canModPost);

  set category(String? category) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetCategory(
          that: this, category: category);

  set clicked(bool clicked) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetClicked(
          that: this, clicked: clicked);

  set contentCategories(List<String> contentCategories) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetContentCategories(
          that: this, contentCategories: contentCategories);

  set contestMode(bool contestMode) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetContestMode(
          that: this, contestMode: contestMode);

  set created(DateTime created) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetCreated(
          that: this, created: created);

  set createdUtc(DateTime createdUtc) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetCreatedUtc(
          that: this, createdUtc: createdUtc);

  set discussionType(String? discussionType) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetDiscussionType(
          that: this, discussionType: discussionType);

  set distinguished(String? distinguished) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetDistinguished(
          that: this, distinguished: distinguished);

  set domain(String domain) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetDomain(that: this, domain: domain);

  set downs(PlatformInt64 downs) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetDowns(that: this, downs: downs);

  set edited(double? edited) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetEdited(that: this, edited: edited);

  set gallery(Gallery? gallery) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetGallery(
          that: this, gallery: gallery);

  set gilded(PlatformInt64 gilded) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetGilded(that: this, gilded: gilded);

  set gildings(Gildings gildings) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetGildings(
          that: this, gildings: gildings);

  set hidden(bool hidden) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetHidden(that: this, hidden: hidden);

  set hideScore(bool hideScore) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetHideScore(
          that: this, hideScore: hideScore);

  set id(PostId id) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetId(that: this, id: id);

  set isCreatedFromAdsUi(bool isCreatedFromAdsUi) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetIsCreatedFromAdsUi(
          that: this, isCreatedFromAdsUi: isCreatedFromAdsUi);

  set isCrosspostable(bool isCrosspostable) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetIsCrosspostable(
          that: this, isCrosspostable: isCrosspostable);

  set isMeta(bool isMeta) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetIsMeta(that: this, isMeta: isMeta);

  set isOriginalContent(bool isOriginalContent) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetIsOriginalContent(
          that: this, isOriginalContent: isOriginalContent);

  set isRedditMediaDomain(bool isRedditMediaDomain) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetIsRedditMediaDomain(
          that: this, isRedditMediaDomain: isRedditMediaDomain);

  set isRobotIndexable(bool isRobotIndexable) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetIsRobotIndexable(
          that: this, isRobotIndexable: isRobotIndexable);

  set isSelf(bool isSelf) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetIsSelf(that: this, isSelf: isSelf);

  set isVideo(bool isVideo) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetIsVideo(
          that: this, isVideo: isVideo);

  set likes(bool? likes) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetLikes(that: this, likes: likes);

  set linkFlair(Flair linkFlair) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetLinkFlair(
          that: this, linkFlair: linkFlair);

  set locked(bool locked) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetLocked(that: this, locked: locked);

  set media(Media? media) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetMedia(that: this, media: media);

  set mediaEmbed(MediaEmbed? mediaEmbed) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetMediaEmbed(
          that: this, mediaEmbed: mediaEmbed);

  set mediaOnly(bool mediaOnly) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetMediaOnly(
          that: this, mediaOnly: mediaOnly);

  set modNote(String? modNote) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetModNote(
          that: this, modNote: modNote);

  set modReasonBy(String? modReasonBy) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetModReasonBy(
          that: this, modReasonBy: modReasonBy);

  set modReasonTitle(String? modReasonTitle) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetModReasonTitle(
          that: this, modReasonTitle: modReasonTitle);

  set modReports(List<String?> modReports) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetModReports(
          that: this, modReports: modReports);

  set name(Fullname name) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetName(that: this, name: name);

  set noFollow(bool noFollow) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetNoFollow(
          that: this, noFollow: noFollow);

  set numComments(PlatformInt64 numComments) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetNumComments(
          that: this, numComments: numComments);

  set numCrossposts(PlatformInt64? numCrossposts) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetNumCrossposts(
          that: this, numCrossposts: numCrossposts);

  set numDuplicates(BigInt? numDuplicates) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetNumDuplicates(
          that: this, numDuplicates: numDuplicates);

  set numReports(String? numReports) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetNumReports(
          that: this, numReports: numReports);

  set over18(bool over18) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetOver18(that: this, over18: over18);

  set permalink(String permalink) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetPermalink(
          that: this, permalink: permalink);

  set pinned(bool pinned) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetPinned(that: this, pinned: pinned);

  set postHint(String? postHint) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetPostHint(
          that: this, postHint: postHint);

  set preview(Preview? preview) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetPreview(
          that: this, preview: preview);

  set pwls(PlatformInt64? pwls) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetPwls(that: this, pwls: pwls);

  set quarantine(bool quarantine) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetQuarantine(
          that: this, quarantine: quarantine);

  set removalReason(String? removalReason) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetRemovalReason(
          that: this, removalReason: removalReason);

  set removedBy(String? removedBy) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetRemovedBy(
          that: this, removedBy: removedBy);

  set removedByCategory(String? removedByCategory) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetRemovedByCategory(
          that: this, removedByCategory: removedByCategory);

  set reportReasons(String? reportReasons) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetReportReasons(
          that: this, reportReasons: reportReasons);

  set saved(bool saved) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetSaved(that: this, saved: saved);

  set score(PlatformInt64 score) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetScore(that: this, score: score);

  set secureMedia(SecureMedia? secureMedia) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetSecureMedia(
          that: this, secureMedia: secureMedia);

  set secureMediaEmbed(SecureMediaEmbed? secureMediaEmbed) =>
      RustLib.instance.api
          .redditApiModelPostPostAutoAccessorSetSecureMediaEmbed(
              that: this, secureMediaEmbed: secureMediaEmbed);

  set selftext(String? selftext) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetSelftext(
          that: this, selftext: selftext);

  set selftextHtml(String? selftextHtml) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetSelftextHtml(
          that: this, selftextHtml: selftextHtml);

  set sendReplies(bool sendReplies) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetSendReplies(
          that: this, sendReplies: sendReplies);

  set spoiler(bool spoiler) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetSpoiler(
          that: this, spoiler: spoiler);

  set stickied(bool stickied) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetStickied(
          that: this, stickied: stickied);

  set subreddit(SubredditInfo subreddit) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetSubreddit(
          that: this, subreddit: subreddit);

  set suggestedSort(String? suggestedSort) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetSuggestedSort(
          that: this, suggestedSort: suggestedSort);

  set title(String title) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetTitle(that: this, title: title);

  set topAwardedType(String? topAwardedType) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetTopAwardedType(
          that: this, topAwardedType: topAwardedType);

  set totalAwardsReceived(PlatformInt64? totalAwardsReceived) =>
      RustLib.instance.api
          .redditApiModelPostPostAutoAccessorSetTotalAwardsReceived(
              that: this, totalAwardsReceived: totalAwardsReceived);

  set treatmentTags(List<String?> treatmentTags) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetTreatmentTags(
          that: this, treatmentTags: treatmentTags);

  set ups(PlatformInt64 ups) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetUps(that: this, ups: ups);

  set upvoteRatio(double upvoteRatio) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetUpvoteRatio(
          that: this, upvoteRatio: upvoteRatio);

  set url(String url) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetUrl(that: this, url: url);

  set urlOverriddenByDest(String? urlOverriddenByDest) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetUrlOverriddenByDest(
          that: this, urlOverriddenByDest: urlOverriddenByDest);

  set userReports(List<String?> userReports) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetUserReports(
          that: this, userReports: userReports);

  set viewCount(String? viewCount) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetViewCount(
          that: this, viewCount: viewCount);

  set visited(bool visited) =>
      RustLib.instance.api.redditApiModelPostPostAutoAccessorSetVisited(
          that: this, visited: visited);

  set wls(PlatformInt64? wls) => RustLib.instance.api
      .redditApiModelPostPostAutoAccessorSetWls(that: this, wls: wls);

  Kind get kind => RustLib.instance.api.redditApiModelPostPostKind(
        that: this,
      );

  Thumbnail? get thumbnail =>
      RustLib.instance.api.redditApiModelPostPostThumbnail(
        that: this,
      );
}

@sealed
class RedditVideoImpl extends RustOpaque implements RedditVideo {
  // Not to be used by end users
  RedditVideoImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  RedditVideoImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_RedditVideo,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_RedditVideo,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_RedditVideoPtr,
  );
}

@sealed
class SecureMediaImpl extends RustOpaque implements SecureMedia {
  // Not to be used by end users
  SecureMediaImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SecureMediaImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SecureMedia,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SecureMedia,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SecureMediaPtr,
  );
}

@sealed
class SubredditIdImpl extends RustOpaque implements SubredditId {
  // Not to be used by end users
  SubredditIdImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SubredditIdImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SubredditId,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubredditId,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubredditIdPtr,
  );
}

@sealed
class SubredditImpl extends RustOpaque implements Subreddit {
  // Not to be used by end users
  SubredditImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SubredditImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Subreddit,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Subreddit,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubredditPtr,
  );

  bool get acceptFollowers => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAcceptFollowers(
        that: this,
      );

  BigInt? get accountsActive => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAccountsActive(
        that: this,
      );

  bool get accountsActiveIsFuzzed => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAccountsActiveIsFuzzed(
        that: this,
      );

  BigInt get activeUserCount => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetActiveUserCount(
        that: this,
      );

  String get advertiserCategory => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAdvertiserCategory(
        that: this,
      );

  bool get allOriginalContent => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllOriginalContent(
        that: this,
      );

  bool get allowDiscovery => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowDiscovery(
        that: this,
      );

  bool get allowGalleries => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowGalleries(
        that: this,
      );

  bool get allowImages => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowImages(
        that: this,
      );

  bool get allowPolls => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowPolls(
        that: this,
      );

  bool get allowPredictionContributors => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowPredictionContributors(
        that: this,
      );

  bool get allowPredictions => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowPredictions(
        that: this,
      );

  bool get allowPredictionsTournament => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowPredictionsTournament(
        that: this,
      );

  bool get allowTalks => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowTalks(
        that: this,
      );

  bool get allowVideogifs => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowVideogifs(
        that: this,
      );

  bool get allowVideos => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowVideos(
        that: this,
      );

  List<String> get allowedMediaInComments => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetAllowedMediaInComments(
        that: this,
      );

  String get bannerBackgroundColor => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundColor(
        that: this,
      );

  String get bannerBackgroundImage => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetBannerBackgroundImage(
        that: this,
      );

  String get bannerImg => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetBannerImg(
        that: this,
      );

  Int64List? get bannerSize => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetBannerSize(
        that: this,
      );

  bool get canAssignLinkFlair => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCanAssignLinkFlair(
        that: this,
      );

  bool get canAssignUserFlair => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCanAssignUserFlair(
        that: this,
      );

  bool get collapseDeletedComments => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCollapseDeletedComments(
        that: this,
      );

  CommentContributionSettings get commentContributionSettings =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCommentContributionSettings(
        that: this,
      );

  PlatformInt64 get commentScoreHideMins => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCommentScoreHideMins(
        that: this,
      );

  String get communityIcon => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCommunityIcon(
        that: this,
      );

  bool get communityReviewed => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCommunityReviewed(
        that: this,
      );

  double get created => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCreated(
        that: this,
      );

  double get createdUtc => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetCreatedUtc(
        that: this,
      );

  String get description => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetDescription(
        that: this,
      );

  String? get descriptionHtml => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetDescriptionHtml(
        that: this,
      );

  bool get disableContributorRequests => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetDisableContributorRequests(
        that: this,
      );

  String get displayName => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetDisplayName(
        that: this,
      );

  String get displayNamePrefixed => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetDisplayNamePrefixed(
        that: this,
      );

  Int64List? get emojisCustomSize => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetEmojisCustomSize(
        that: this,
      );

  bool get emojisEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetEmojisEnabled(
        that: this,
      );

  bool get freeFormReports => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetFreeFormReports(
        that: this,
      );

  bool get hasMenuWidget => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetHasMenuWidget(
        that: this,
      );

  String? get headerImg => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetHeaderImg(
        that: this,
      );

  Int64List? get headerSize => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetHeaderSize(
        that: this,
      );

  String get headerTitle => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetHeaderTitle(
        that: this,
      );

  bool get hideAds => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetHideAds(
        that: this,
      );

  String get iconImg => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetIconImg(
        that: this,
      );

  UsizeArray2? get iconSize => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetIconSize(
        that: this,
      );

  String get id =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorGetId(
        that: this,
      );

  bool? get isCrosspostableSubreddit => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetIsCrosspostableSubreddit(
        that: this,
      );

  bool? get isEnrolledInNewModmail => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetIsEnrolledInNewModmail(
        that: this,
      );

  String get keyColor => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetKeyColor(
        that: this,
      );

  String get lang =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorGetLang(
        that: this,
      );

  bool get linkFlairEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetLinkFlairEnabled(
        that: this,
      );

  String get linkFlairPosition => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetLinkFlairPosition(
        that: this,
      );

  String get mobileBannerImage => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetMobileBannerImage(
        that: this,
      );

  String get name =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorGetName(
        that: this,
      );

  String? get notificationLevel => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetNotificationLevel(
        that: this,
      );

  bool get originalContentTagEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetOriginalContentTagEnabled(
        that: this,
      );

  bool get over18 => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetOver18(
        that: this,
      );

  PlatformInt64 get predictionLeaderboardEntryType => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetPredictionLeaderboardEntryType(
        that: this,
      );

  String get primaryColor => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetPrimaryColor(
        that: this,
      );

  String get publicDescription => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetPublicDescription(
        that: this,
      );

  String? get publicDescriptionHtml => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetPublicDescriptionHtml(
        that: this,
      );

  bool get publicTraffic => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetPublicTraffic(
        that: this,
      );

  bool get quarantine => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetQuarantine(
        that: this,
      );

  bool get restrictCommenting => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetRestrictCommenting(
        that: this,
      );

  bool get restrictPosting => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetRestrictPosting(
        that: this,
      );

  bool get shouldArchivePosts => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetShouldArchivePosts(
        that: this,
      );

  bool get shouldShowMediaInCommentsSetting => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetShouldShowMediaInCommentsSetting(
        that: this,
      );

  bool get showMedia => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetShowMedia(
        that: this,
      );

  bool get showMediaPreview => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetShowMediaPreview(
        that: this,
      );

  bool get spoilersEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSpoilersEnabled(
        that: this,
      );

  String get submissionType => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSubmissionType(
        that: this,
      );

  String get submitLinkLabel => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSubmitLinkLabel(
        that: this,
      );

  String get submitText => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSubmitText(
        that: this,
      );

  String? get submitTextHtml => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSubmitTextHtml(
        that: this,
      );

  String get submitTextLabel => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSubmitTextLabel(
        that: this,
      );

  String get subredditType => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSubredditType(
        that: this,
      );

  PlatformInt64 get subscribers => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSubscribers(
        that: this,
      );

  String? get suggestedCommentSort => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetSuggestedCommentSort(
        that: this,
      );

  String get title =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorGetTitle(
        that: this,
      );

  String get url =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorGetUrl(
        that: this,
      );

  bool? get userCanFlairInSr => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserCanFlairInSr(
        that: this,
      );

  Flair get userFlair => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserFlair(
        that: this,
      );

  bool get userFlairEnabledInSr => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserFlairEnabledInSr(
        that: this,
      );

  bool get userHasFavorited => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserHasFavorited(
        that: this,
      );

  bool get userIsBanned => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserIsBanned(
        that: this,
      );

  bool get userIsContributor => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserIsContributor(
        that: this,
      );

  bool get userIsModerator => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserIsModerator(
        that: this,
      );

  bool get userIsMuted => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserIsMuted(
        that: this,
      );

  bool get userIsSubscriber => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserIsSubscriber(
        that: this,
      );

  bool? get userSrFlairEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserSrFlairEnabled(
        that: this,
      );

  bool get userSrThemeEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetUserSrThemeEnabled(
        that: this,
      );

  bool? get wikiEnabled => RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorGetWikiEnabled(
        that: this,
      );

  BigInt? get wls =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorGetWls(
        that: this,
      );

  set acceptFollowers(bool acceptFollowers) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAcceptFollowers(
          that: this, acceptFollowers: acceptFollowers);

  set accountsActive(BigInt? accountsActive) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAccountsActive(
          that: this, accountsActive: accountsActive);

  set accountsActiveIsFuzzed(bool accountsActiveIsFuzzed) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAccountsActiveIsFuzzed(
          that: this, accountsActiveIsFuzzed: accountsActiveIsFuzzed);

  set activeUserCount(BigInt activeUserCount) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetActiveUserCount(
          that: this, activeUserCount: activeUserCount);

  set advertiserCategory(String advertiserCategory) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAdvertiserCategory(
          that: this, advertiserCategory: advertiserCategory);

  set allOriginalContent(bool allOriginalContent) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllOriginalContent(
          that: this, allOriginalContent: allOriginalContent);

  set allowDiscovery(bool allowDiscovery) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowDiscovery(
          that: this, allowDiscovery: allowDiscovery);

  set allowGalleries(bool allowGalleries) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowGalleries(
          that: this, allowGalleries: allowGalleries);

  set allowImages(bool allowImages) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowImages(
          that: this, allowImages: allowImages);

  set allowPolls(bool allowPolls) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowPolls(
          that: this, allowPolls: allowPolls);

  set allowPredictionContributors(bool allowPredictionContributors) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowPredictionContributors(
          that: this, allowPredictionContributors: allowPredictionContributors);

  set allowPredictions(bool allowPredictions) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowPredictions(
          that: this, allowPredictions: allowPredictions);

  set allowPredictionsTournament(bool allowPredictionsTournament) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowPredictionsTournament(
          that: this, allowPredictionsTournament: allowPredictionsTournament);

  set allowTalks(bool allowTalks) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowTalks(
          that: this, allowTalks: allowTalks);

  set allowVideogifs(bool allowVideogifs) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowVideogifs(
          that: this, allowVideogifs: allowVideogifs);

  set allowVideos(bool allowVideos) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowVideos(
          that: this, allowVideos: allowVideos);

  set allowedMediaInComments(List<String> allowedMediaInComments) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetAllowedMediaInComments(
          that: this, allowedMediaInComments: allowedMediaInComments);

  set bannerBackgroundColor(String bannerBackgroundColor) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundColor(
              that: this, bannerBackgroundColor: bannerBackgroundColor);

  set bannerBackgroundImage(String bannerBackgroundImage) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetBannerBackgroundImage(
              that: this, bannerBackgroundImage: bannerBackgroundImage);

  set bannerImg(String bannerImg) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetBannerImg(
          that: this, bannerImg: bannerImg);

  set bannerSize(Int64List? bannerSize) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetBannerSize(
          that: this, bannerSize: bannerSize);

  set canAssignLinkFlair(bool canAssignLinkFlair) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetCanAssignLinkFlair(
          that: this, canAssignLinkFlair: canAssignLinkFlair);

  set canAssignUserFlair(bool canAssignUserFlair) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetCanAssignUserFlair(
          that: this, canAssignUserFlair: canAssignUserFlair);

  set collapseDeletedComments(bool collapseDeletedComments) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetCollapseDeletedComments(
          that: this, collapseDeletedComments: collapseDeletedComments);

  set commentContributionSettings(
          CommentContributionSettings commentContributionSettings) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetCommentContributionSettings(
              that: this,
              commentContributionSettings: commentContributionSettings);

  set commentScoreHideMins(PlatformInt64 commentScoreHideMins) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetCommentScoreHideMins(
              that: this, commentScoreHideMins: commentScoreHideMins);

  set communityIcon(String communityIcon) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetCommunityIcon(
          that: this, communityIcon: communityIcon);

  set communityReviewed(bool communityReviewed) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetCommunityReviewed(
          that: this, communityReviewed: communityReviewed);

  set created(double created) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetCreated(
          that: this, created: created);

  set createdUtc(double createdUtc) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetCreatedUtc(
          that: this, createdUtc: createdUtc);

  set description(String description) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetDescription(
          that: this, description: description);

  set descriptionHtml(String? descriptionHtml) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetDescriptionHtml(
          that: this, descriptionHtml: descriptionHtml);

  set disableContributorRequests(bool disableContributorRequests) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetDisableContributorRequests(
          that: this, disableContributorRequests: disableContributorRequests);

  set displayName(String displayName) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetDisplayName(
          that: this, displayName: displayName);

  set displayNamePrefixed(String displayNamePrefixed) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetDisplayNamePrefixed(
          that: this, displayNamePrefixed: displayNamePrefixed);

  set emojisCustomSize(Int64List? emojisCustomSize) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetEmojisCustomSize(
          that: this, emojisCustomSize: emojisCustomSize);

  set emojisEnabled(bool emojisEnabled) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetEmojisEnabled(
          that: this, emojisEnabled: emojisEnabled);

  set freeFormReports(bool freeFormReports) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetFreeFormReports(
          that: this, freeFormReports: freeFormReports);

  set hasMenuWidget(bool hasMenuWidget) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetHasMenuWidget(
          that: this, hasMenuWidget: hasMenuWidget);

  set headerImg(String? headerImg) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetHeaderImg(
          that: this, headerImg: headerImg);

  set headerSize(Int64List? headerSize) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetHeaderSize(
          that: this, headerSize: headerSize);

  set headerTitle(String headerTitle) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetHeaderTitle(
          that: this, headerTitle: headerTitle);

  set hideAds(bool hideAds) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetHideAds(
          that: this, hideAds: hideAds);

  set iconImg(String iconImg) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetIconImg(
          that: this, iconImg: iconImg);

  set iconSize(UsizeArray2? iconSize) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetIconSize(
          that: this, iconSize: iconSize);

  set id(String id) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetId(that: this, id: id);

  set isCrosspostableSubreddit(bool? isCrosspostableSubreddit) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetIsCrosspostableSubreddit(
          that: this, isCrosspostableSubreddit: isCrosspostableSubreddit);

  set isEnrolledInNewModmail(bool? isEnrolledInNewModmail) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetIsEnrolledInNewModmail(
          that: this, isEnrolledInNewModmail: isEnrolledInNewModmail);

  set keyColor(String keyColor) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetKeyColor(
          that: this, keyColor: keyColor);

  set lang(String lang) =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorSetLang(
          that: this, lang: lang);

  set linkFlairEnabled(bool linkFlairEnabled) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetLinkFlairEnabled(
          that: this, linkFlairEnabled: linkFlairEnabled);

  set linkFlairPosition(String linkFlairPosition) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetLinkFlairPosition(
          that: this, linkFlairPosition: linkFlairPosition);

  set mobileBannerImage(String mobileBannerImage) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetMobileBannerImage(
          that: this, mobileBannerImage: mobileBannerImage);

  set name(String name) =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorSetName(
          that: this, name: name);

  set notificationLevel(String? notificationLevel) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetNotificationLevel(
          that: this, notificationLevel: notificationLevel);

  set originalContentTagEnabled(bool originalContentTagEnabled) => RustLib
      .instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetOriginalContentTagEnabled(
          that: this, originalContentTagEnabled: originalContentTagEnabled);

  set over18(bool over18) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetOver18(
          that: this, over18: over18);

  set predictionLeaderboardEntryType(
          PlatformInt64 predictionLeaderboardEntryType) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetPredictionLeaderboardEntryType(
              that: this,
              predictionLeaderboardEntryType: predictionLeaderboardEntryType);

  set primaryColor(String primaryColor) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetPrimaryColor(
          that: this, primaryColor: primaryColor);

  set publicDescription(String publicDescription) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetPublicDescription(
          that: this, publicDescription: publicDescription);

  set publicDescriptionHtml(String? publicDescriptionHtml) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetPublicDescriptionHtml(
              that: this, publicDescriptionHtml: publicDescriptionHtml);

  set publicTraffic(bool publicTraffic) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetPublicTraffic(
          that: this, publicTraffic: publicTraffic);

  set quarantine(bool quarantine) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetQuarantine(
          that: this, quarantine: quarantine);

  set restrictCommenting(bool restrictCommenting) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetRestrictCommenting(
          that: this, restrictCommenting: restrictCommenting);

  set restrictPosting(bool restrictPosting) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetRestrictPosting(
          that: this, restrictPosting: restrictPosting);

  set shouldArchivePosts(bool shouldArchivePosts) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetShouldArchivePosts(
          that: this, shouldArchivePosts: shouldArchivePosts);

  set shouldShowMediaInCommentsSetting(bool shouldShowMediaInCommentsSetting) =>
      RustLib.instance.api
          .redditApiModelSubredditSubredditAutoAccessorSetShouldShowMediaInCommentsSetting(
              that: this,
              shouldShowMediaInCommentsSetting:
                  shouldShowMediaInCommentsSetting);

  set showMedia(bool showMedia) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetShowMedia(
          that: this, showMedia: showMedia);

  set showMediaPreview(bool showMediaPreview) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetShowMediaPreview(
          that: this, showMediaPreview: showMediaPreview);

  set spoilersEnabled(bool spoilersEnabled) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSpoilersEnabled(
          that: this, spoilersEnabled: spoilersEnabled);

  set submissionType(String submissionType) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSubmissionType(
          that: this, submissionType: submissionType);

  set submitLinkLabel(String submitLinkLabel) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSubmitLinkLabel(
          that: this, submitLinkLabel: submitLinkLabel);

  set submitText(String submitText) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSubmitText(
          that: this, submitText: submitText);

  set submitTextHtml(String? submitTextHtml) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSubmitTextHtml(
          that: this, submitTextHtml: submitTextHtml);

  set submitTextLabel(String submitTextLabel) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSubmitTextLabel(
          that: this, submitTextLabel: submitTextLabel);

  set subredditType(String subredditType) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSubredditType(
          that: this, subredditType: subredditType);

  set subscribers(PlatformInt64 subscribers) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSubscribers(
          that: this, subscribers: subscribers);

  set suggestedCommentSort(String? suggestedCommentSort) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetSuggestedCommentSort(
          that: this, suggestedCommentSort: suggestedCommentSort);

  set title(String title) =>
      RustLib.instance.api.redditApiModelSubredditSubredditAutoAccessorSetTitle(
          that: this, title: title);

  set url(String url) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUrl(that: this, url: url);

  set userCanFlairInSr(bool? userCanFlairInSr) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserCanFlairInSr(
          that: this, userCanFlairInSr: userCanFlairInSr);

  set userFlair(Flair userFlair) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserFlair(
          that: this, userFlair: userFlair);

  set userFlairEnabledInSr(bool userFlairEnabledInSr) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserFlairEnabledInSr(
          that: this, userFlairEnabledInSr: userFlairEnabledInSr);

  set userHasFavorited(bool userHasFavorited) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserHasFavorited(
          that: this, userHasFavorited: userHasFavorited);

  set userIsBanned(bool userIsBanned) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserIsBanned(
          that: this, userIsBanned: userIsBanned);

  set userIsContributor(bool userIsContributor) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserIsContributor(
          that: this, userIsContributor: userIsContributor);

  set userIsModerator(bool userIsModerator) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserIsModerator(
          that: this, userIsModerator: userIsModerator);

  set userIsMuted(bool userIsMuted) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserIsMuted(
          that: this, userIsMuted: userIsMuted);

  set userIsSubscriber(bool userIsSubscriber) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserIsSubscriber(
          that: this, userIsSubscriber: userIsSubscriber);

  set userSrFlairEnabled(bool? userSrFlairEnabled) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserSrFlairEnabled(
          that: this, userSrFlairEnabled: userSrFlairEnabled);

  set userSrThemeEnabled(bool userSrThemeEnabled) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetUserSrThemeEnabled(
          that: this, userSrThemeEnabled: userSrThemeEnabled);

  set wikiEnabled(bool? wikiEnabled) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetWikiEnabled(
          that: this, wikiEnabled: wikiEnabled);

  set wls(BigInt? wls) => RustLib.instance.api
      .redditApiModelSubredditSubredditAutoAccessorSetWls(that: this, wls: wls);
}

@sealed
class SubredditInfoImpl extends RustOpaque implements SubredditInfo {
  // Not to be used by end users
  SubredditInfoImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SubredditInfoImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SubredditInfo,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubredditInfo,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubredditInfoPtr,
  );

  String get subreddit => RustLib.instance.api
          .redditApiModelPostSubredditInfoAutoAccessorGetSubreddit(
        that: this,
      );

  SubredditId get subredditId => RustLib.instance.api
          .redditApiModelPostSubredditInfoAutoAccessorGetSubredditId(
        that: this,
      );

  String get subredditNamePrefixed => RustLib.instance.api
          .redditApiModelPostSubredditInfoAutoAccessorGetSubredditNamePrefixed(
        that: this,
      );

  String get subredditType => RustLib.instance.api
          .redditApiModelPostSubredditInfoAutoAccessorGetSubredditType(
        that: this,
      );

  BigInt get subscribers => RustLib.instance.api
          .redditApiModelPostSubredditInfoAutoAccessorGetSubscribers(
        that: this,
      );

  set subreddit(String subreddit) => RustLib.instance.api
      .redditApiModelPostSubredditInfoAutoAccessorSetSubreddit(
          that: this, subreddit: subreddit);

  set subredditId(SubredditId subredditId) => RustLib.instance.api
      .redditApiModelPostSubredditInfoAutoAccessorSetSubredditId(
          that: this, subredditId: subredditId);

  set subredditNamePrefixed(String subredditNamePrefixed) =>
      RustLib.instance.api
          .redditApiModelPostSubredditInfoAutoAccessorSetSubredditNamePrefixed(
              that: this, subredditNamePrefixed: subredditNamePrefixed);

  set subredditType(String subredditType) => RustLib.instance.api
      .redditApiModelPostSubredditInfoAutoAccessorSetSubredditType(
          that: this, subredditType: subredditType);

  set subscribers(BigInt subscribers) => RustLib.instance.api
      .redditApiModelPostSubredditInfoAutoAccessorSetSubscribers(
          that: this, subscribers: subscribers);
}

@sealed
class UrlImpl extends RustOpaque implements Url {
  // Not to be used by end users
  UrlImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  UrlImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Url,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Url,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_UrlPtr,
  );
}
