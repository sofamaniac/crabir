// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../client.dart';
import '../model.dart';
import 'flair.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'subreddit.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `try_from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Common>>
abstract class Common implements RustOpaqueInterface {
  static Future<Common> default_() =>
      RustLib.instance.api.redditApiModelSubredditCommonDefault();

  /// flutter_rust_bridge:sync,getter
  bool get acceptFollowers;

  /// flutter_rust_bridge:sync,getter
  List<String> get allowedMediaInComments;

  /// flutter_rust_bridge:sync,getter
  String? get bannerImg;

  /// flutter_rust_bridge:sync,getter
  Int64List? get bannerSize;

  /// flutter_rust_bridge:sync,getter
  double get created;

  /// flutter_rust_bridge:sync,getter
  double get createdUtc;

  /// flutter_rust_bridge:sync,getter
  bool get disableContributorRequests;

  /// flutter_rust_bridge:sync,getter
  String get displayName;

  /// flutter_rust_bridge:sync,getter
  String get displayNamePrefixed;

  /// flutter_rust_bridge:sync,getter
  bool get freeFormReports;

  /// flutter_rust_bridge:sync,getter
  String? get headerImg;

  /// flutter_rust_bridge:sync,getter
  Int64List? get headerSize;

  /// flutter_rust_bridge:sync,getter
  String? get keyColor;

  /// flutter_rust_bridge:sync,getter
  bool get linkFlairEnabled;

  /// flutter_rust_bridge:sync,getter
  String? get linkFlairPosition;

  /// flutter_rust_bridge:sync,getter
  Fullname get name;

  /// flutter_rust_bridge:sync,getter
  String? get primaryColor;

  /// flutter_rust_bridge:sync,getter
  String? get publicDescription;

  /// flutter_rust_bridge:sync,getter
  bool get quarantine;

  /// flutter_rust_bridge:sync,getter
  bool get restrictCommenting;

  /// flutter_rust_bridge:sync,getter
  bool get restrictPosting;

  /// flutter_rust_bridge:sync,getter
  bool get showMedia;

  /// flutter_rust_bridge:sync,getter
  String? get submitLinkLabel;

  /// flutter_rust_bridge:sync,getter
  String? get submitTextLabel;

  /// flutter_rust_bridge:sync,getter
  String? get subredditType;

  /// flutter_rust_bridge:sync,getter
  PlatformInt64 get subscribers;

  /// flutter_rust_bridge:sync,getter
  String? get title;

  /// flutter_rust_bridge:sync,getter
  String get url;

  /// flutter_rust_bridge:sync,getter
  bool get userIsBanned;

  /// flutter_rust_bridge:sync,getter
  bool get userIsContributor;

  /// flutter_rust_bridge:sync,getter
  bool get userIsModerator;

  /// flutter_rust_bridge:sync,getter
  bool get userIsMuted;

  /// flutter_rust_bridge:sync,getter
  bool get userIsSubscriber;

  SubredditIcon get icon;
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Details>>
abstract class Details implements RustOpaqueInterface {
  static Future<Details> default_() =>
      RustLib.instance.api.redditApiModelSubredditDetailsDefault();

  /// flutter_rust_bridge:sync,getter
  bool get defaultSet;

  /// flutter_rust_bridge:sync,getter
  String? get description;

  /// flutter_rust_bridge:sync,getter
  String? get iconColor;

  /// flutter_rust_bridge:sync,getter
  Common get other;

  /// flutter_rust_bridge:sync,getter
  bool get over18;

  /// flutter_rust_bridge:sync,getter
  List<String> get previousNames;

  SubredditIcon get icon;
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Subreddit>>
abstract class Subreddit implements RustOpaqueInterface {
  static Future<Subreddit> default_() =>
      RustLib.instance.api.redditApiModelSubredditSubredditDefault();

  /// flutter_rust_bridge:sync,getter
  int get accountsActive;

  /// flutter_rust_bridge:sync,getter
  int get activeUserCount;

  /// flutter_rust_bridge:sync,getter
  String? get advertiserCategory;

  /// flutter_rust_bridge:sync,getter
  bool get allOriginalContent;

  /// flutter_rust_bridge:sync,getter
  bool get allowDiscovery;

  /// flutter_rust_bridge:sync,getter
  bool get allowGalleries;

  /// flutter_rust_bridge:sync,getter
  bool get allowImages;

  /// flutter_rust_bridge:sync,getter
  bool get allowPolls;

  /// flutter_rust_bridge:sync,getter
  bool get allowPredictionContributors;

  /// flutter_rust_bridge:sync,getter
  bool get allowPredictions;

  /// flutter_rust_bridge:sync,getter
  bool get allowPredictionsTournament;

  /// flutter_rust_bridge:sync,getter
  bool get allowTalks;

  /// flutter_rust_bridge:sync,getter
  bool get allowVideogifs;

  /// flutter_rust_bridge:sync,getter
  bool get allowVideos;

  /// flutter_rust_bridge:sync,getter
  String? get bannerBackgroundColor;

  /// flutter_rust_bridge:sync,getter
  String? get bannerBackgroundImage;

  /// flutter_rust_bridge:sync,getter
  bool get canAssignLinkFlair;

  /// flutter_rust_bridge:sync,getter
  bool get canAssignUserFlair;

  /// flutter_rust_bridge:sync,getter
  bool get collapseDeletedComments;

  /// flutter_rust_bridge:sync,getter
  CommentContributionSettings get commentContributionSettings;

  /// flutter_rust_bridge:sync,getter
  PlatformInt64? get commentScoreHideMins;

  /// flutter_rust_bridge:sync,getter
  bool get communityReviewed;

  /// flutter_rust_bridge:sync,getter
  String? get description;

  /// flutter_rust_bridge:sync,getter
  String? get descriptionHtml;

  /// flutter_rust_bridge:sync,getter
  Int64List? get emojisCustomSize;

  /// flutter_rust_bridge:sync,getter
  bool get emojisEnabled;

  /// flutter_rust_bridge:sync,getter
  bool get hasMenuWidget;

  /// flutter_rust_bridge:sync,getter
  String? get headerTitle;

  /// flutter_rust_bridge:sync,getter
  bool get hideAds;

  /// flutter_rust_bridge:sync,getter
  String get id;

  /// flutter_rust_bridge:sync,getter
  bool? get isCrosspostableSubreddit;

  /// flutter_rust_bridge:sync,getter
  bool? get isEnrolledInNewModmail;

  /// flutter_rust_bridge:sync,getter
  String? get lang;

  /// flutter_rust_bridge:sync,getter
  String? get mobileBannerImage;

  /// flutter_rust_bridge:sync,getter
  String? get notificationLevel;

  /// flutter_rust_bridge:sync,getter
  bool get originalContentTagEnabled;

  /// flutter_rust_bridge:sync,getter
  Common get other;

  /// flutter_rust_bridge:sync,getter
  bool get over18;

  /// flutter_rust_bridge:sync,getter
  PlatformInt64 get predictionLeaderboardEntryType;

  /// flutter_rust_bridge:sync,getter
  String? get publicDescriptionHtml;

  /// flutter_rust_bridge:sync,getter
  bool get publicTraffic;

  /// flutter_rust_bridge:sync,getter
  bool get shouldArchivePosts;

  /// flutter_rust_bridge:sync,getter
  bool get shouldShowMediaInCommentsSetting;

  /// flutter_rust_bridge:sync,getter
  bool get showMediaPreview;

  /// flutter_rust_bridge:sync,getter
  bool get spoilersEnabled;

  /// flutter_rust_bridge:sync,getter
  String? get submissionType;

  /// flutter_rust_bridge:sync,getter
  String? get submitText;

  /// flutter_rust_bridge:sync,getter
  String? get submitTextHtml;

  /// flutter_rust_bridge:sync,getter
  String? get suggestedCommentSort;

  /// flutter_rust_bridge:sync,getter
  bool? get userCanFlairInSr;

  /// flutter_rust_bridge:sync,getter
  Flair get userFlair;

  /// flutter_rust_bridge:sync,getter
  bool get userFlairEnabledInSr;

  /// flutter_rust_bridge:sync,getter
  bool get userHasFavorited;

  /// flutter_rust_bridge:sync,getter
  bool? get userSrFlairEnabled;

  /// flutter_rust_bridge:sync,getter
  bool get userSrThemeEnabled;

  /// flutter_rust_bridge:sync,getter
  bool? get wikiEnabled;

  /// flutter_rust_bridge:sync,getter
  int? get wls;

  SubredditIcon get icon;

  Future<void> subscribe({required Client client});

  Future<void> unsubscribe({required Client client});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SubredditID>>
abstract class SubredditId implements RustOpaqueInterface {
  static Future<SubredditId> default_() =>
      RustLib.instance.api.redditApiModelSubredditSubredditIdDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SubredditInfo>>
abstract class SubredditInfo implements RustOpaqueInterface {
  Details? get details;

  String get subreddit;

  SubredditId get subredditId;

  String get subredditNamePrefixed;

  int get subscribers;

  set details(Details? details);

  set subreddit(String subreddit);

  set subredditId(SubredditId subredditId);

  set subredditNamePrefixed(String subredditNamePrefixed);

  set subscribers(int subscribers);

  static Future<SubredditInfo> default_() =>
      RustLib.instance.api.redditApiModelSubredditSubredditInfoDefault();

  /// flutter_rust_bridge:sync,getter
  Details? get details;

  /// The subreddit's name (e.g. "awww")
  /// flutter_rust_bridge:sync,getter
  String get subreddit;

  /// flutter_rust_bridge:sync,getter
  SubredditId get subredditId;

  /// The subreddit's name prefixed with "r/"
  /// flutter_rust_bridge:sync,getter
  String get subredditNamePrefixed;

  /// The number of subscribers of the subreddit
  /// flutter_rust_bridge:sync,getter
  int get subscribers;
}

class CommentContributionSettings {
  final List<String> allowedMediaTypes;

  const CommentContributionSettings({
    required this.allowedMediaTypes,
  });

  static Future<CommentContributionSettings> default_() => RustLib.instance.api
      .redditApiModelSubredditCommentContributionSettingsDefault();

  @override
  int get hashCode => allowedMediaTypes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CommentContributionSettings &&
          runtimeType == other.runtimeType &&
          allowedMediaTypes == other.allowedMediaTypes;
}

class Icon {
  final String url;
  final BigInt width;
  final BigInt height;

  const Icon({
    required this.url,
    required this.width,
    required this.height,
  });

  @override
  int get hashCode => url.hashCode ^ width.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Icon &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          width == other.width &&
          height == other.height;
}

enum NotificationLevel {
  unknown,
  low,
  ;

  static Future<NotificationLevel> default_() =>
      RustLib.instance.api.redditApiModelSubredditNotificationLevelDefault();
}

@freezed
sealed class SubredditIcon with _$SubredditIcon {
  const SubredditIcon._();

  const factory SubredditIcon.image(
    Icon field0,
  ) = SubredditIcon_Image;
  const factory SubredditIcon.color(
    String field0,
  ) = SubredditIcon_Color;
}
