// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../client.dart';
import '../model.dart';
import 'author.dart';
import 'comment.dart';
import 'flair.dart';
import 'gallery.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'subreddit.dart';
part 'post.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `SecureMedia`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `try_from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Post>>
abstract class Post implements RustOpaqueInterface, Votable {
  static Future<Post> default_() =>
      RustLib.instance.api.redditApiModelPostPostDefault();

  /// flutter_rust_bridge:sync,getter
  List<String?> get allAwardings;

  /// flutter_rust_bridge:sync,getter
  bool get allowLiveComments;

  /// flutter_rust_bridge:sync,getter
  double? get approvedAtUtc;

  /// flutter_rust_bridge:sync,getter
  String? get approvedBy;

  /// flutter_rust_bridge:sync,getter
  bool get archived;

  /// flutter_rust_bridge:sync,getter
  AuthorInfo? get author;

  /// flutter_rust_bridge:sync,getter
  List<String?> get awarders;

  /// flutter_rust_bridge:sync,getter
  double? get bannedAtUtc;

  /// flutter_rust_bridge:sync,getter
  bool get canGild;

  /// flutter_rust_bridge:sync,getter
  bool get canModPost;

  /// flutter_rust_bridge:sync,getter
  String? get category;

  /// flutter_rust_bridge:sync,getter
  bool get clicked;

  /// flutter_rust_bridge:sync,getter
  List<String> get contentCategories;

  /// flutter_rust_bridge:sync,getter
  bool get contestMode;

  /// Date of creation in logged in user locale
  /// flutter_rust_bridge:sync,getter
  DateTime get created;

  /// Date of creation in UTC
  /// flutter_rust_bridge:sync,getter
  DateTime get createdUtc;

  /// flutter_rust_bridge:sync,getter
  List<Post> get crosspostParentList;

  /// flutter_rust_bridge:sync,getter
  String? get discussionType;

  /// flutter_rust_bridge:sync,getter
  String? get distinguished;

  /// flutter_rust_bridge:sync,getter
  String get domain;

  /// flutter_rust_bridge:sync,getter
  int get downs;

  /// flutter_rust_bridge:sync,getter
  double? get edited;

  /// flutter_rust_bridge:sync,getter
  Gallery? get gallery;

  /// flutter_rust_bridge:sync,getter
  int get gilded;

  /// flutter_rust_bridge:sync,getter
  Gildings get gildings;

  /// flutter_rust_bridge:sync,getter
  bool get hidden;

  /// flutter_rust_bridge:sync,getter
  bool get hideScore;

  /// flutter_rust_bridge:sync,getter
  PostId get id;

  /// flutter_rust_bridge:sync,getter
  bool get isCreatedFromAdsUi;

  /// flutter_rust_bridge:sync,getter
  bool get isCrosspostable;

  /// flutter_rust_bridge:sync,getter
  bool get isGallery;

  /// flutter_rust_bridge:sync,getter
  bool get isMeta;

  /// flutter_rust_bridge:sync,getter
  bool get isOriginalContent;

  /// flutter_rust_bridge:sync,getter
  bool get isRedditMediaDomain;

  /// flutter_rust_bridge:sync,getter
  bool get isRobotIndexable;

  /// flutter_rust_bridge:sync,getter
  bool get isSelf;

  /// flutter_rust_bridge:sync,getter
  bool get isVideo;

  /// Some(true) if upvoted, Some(false) if downvoted, None otherwise
  /// flutter_rust_bridge:sync,getter
  bool? get likes;

  /// flutter_rust_bridge:sync,getter
  Flair get linkFlair;

  /// flutter_rust_bridge:sync,getter
  bool get locked;

  /// flutter_rust_bridge:sync,getter
  Media? get media;

  /// flutter_rust_bridge:sync,getter
  MediaEmbed? get mediaEmbed;

  /// flutter_rust_bridge:sync,getter
  bool get mediaOnly;

  /// flutter_rust_bridge:sync,getter
  String? get modNote;

  /// flutter_rust_bridge:sync,getter
  String? get modReasonBy;

  /// flutter_rust_bridge:sync,getter
  String? get modReasonTitle;

  /// flutter_rust_bridge:sync,getter
  List<String?> get modReports;

  /// flutter_rust_bridge:sync,getter
  @override
  Fullname get name;

  /// flutter_rust_bridge:sync,getter
  bool get noFollow;

  /// flutter_rust_bridge:sync,getter
  int get numComments;

  /// flutter_rust_bridge:sync,getter
  int? get numCrossposts;

  /// flutter_rust_bridge:sync,getter
  int? get numDuplicates;

  /// flutter_rust_bridge:sync,getter
  int? get numReports;

  /// flutter_rust_bridge:sync,getter
  bool get over18;

  /// flutter_rust_bridge:sync,getter
  String get permalink;

  /// flutter_rust_bridge:sync,getter
  bool get pinned;

  /// flutter_rust_bridge:sync,getter
  String? get postHint;

  /// flutter_rust_bridge:sync,getter
  Preview? get preview;

  /// flutter_rust_bridge:sync,getter
  int? get pwls;

  /// flutter_rust_bridge:sync,getter
  bool get quarantine;

  /// flutter_rust_bridge:sync,getter
  String? get removalReason;

  /// flutter_rust_bridge:sync,getter
  String? get removedBy;

  /// flutter_rust_bridge:sync,getter
  String? get removedByCategory;

  /// flutter_rust_bridge:sync,getter
  List<String> get reportReasons;

  /// flutter_rust_bridge:sync,getter
  bool get saved;

  /// flutter_rust_bridge:sync,getter
  int get score;

  /// flutter_rust_bridge:sync,getter
  Media? get secureMedia;

  /// flutter_rust_bridge:sync,getter
  SecureMediaEmbed? get secureMediaEmbed;

  /// flutter_rust_bridge:sync,getter
  String? get selftext;

  /// flutter_rust_bridge:sync,getter
  String? get selftextHtml;

  /// flutter_rust_bridge:sync,getter
  bool get sendReplies;

  /// flutter_rust_bridge:sync,getter
  bool get spoiler;

  /// flutter_rust_bridge:sync,getter
  bool get stickied;

  /// flutter_rust_bridge:sync,getter
  SubredditInfo get subreddit;

  /// Suggested sort for comments
  /// flutter_rust_bridge:sync,getter
  CommentSort? get suggestedSort;

  /// flutter_rust_bridge:sync,getter
  String get title;

  /// flutter_rust_bridge:sync,getter
  String? get topAwardedType;

  /// flutter_rust_bridge:sync,getter
  int? get totalAwardsReceived;

  /// flutter_rust_bridge:sync,getter
  List<String?> get treatmentTags;

  /// flutter_rust_bridge:sync,getter
  int get ups;

  /// flutter_rust_bridge:sync,getter
  double get upvoteRatio;

  /// flutter_rust_bridge:sync,getter
  String get url;

  /// flutter_rust_bridge:sync,getter
  String? get urlOverriddenByDest;

  /// flutter_rust_bridge:sync,getter
  List<String?> get userReports;

  /// flutter_rust_bridge:sync,getter
  String? get viewCount;

  /// flutter_rust_bridge:sync,getter
  bool get visited;

  /// flutter_rust_bridge:sync,getter
  int? get wls;

  bool get isCrosspost;

  Kind get kind;

  @override
  Future<void> name();

  @override
  Future<void> save({required Client client});

  @override
  Future<void> setLikes({bool? likes});

  @override
  Future<void> setSaved({required bool saved});

  Thumbnail? get thumbnail;

  @override
  Future<void> unsave({required Client client});

  @override
  Future<void> vote({required VoteDirection direction, required Client client});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PostID>>
abstract class PostId implements RustOpaqueInterface {
  String get asString;

  static Future<PostId> default_() =>
      RustLib.instance.api.redditApiModelPostPostIdDefault();
}

class Gildings {
  const Gildings();

  static Future<Gildings> default_() =>
      RustLib.instance.api.redditApiModelPostGildingsDefault();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Gildings && runtimeType == other.runtimeType;
}

class ImageBase {
  final String url;
  final int width;
  final int height;

  const ImageBase({
    required this.url,
    required this.width,
    required this.height,
  });

  static Future<ImageBase> default_() =>
      RustLib.instance.api.redditApiModelPostImageBaseDefault();

  @override
  int get hashCode => url.hashCode ^ width.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ImageBase &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          width == other.width &&
          height == other.height;
}

enum Kind {
  selftext,
  meta,
  image,

  /// Video hosted on Reddit
  video,

  /// Video hosted on Youtube
  youtubeVideo,

  /// Gallery present in `Post::Gallery`
  gallery,

  /// Gallery at `Post::url`
  mediaGallery,
  link,
  unknown,
  ;
}

@freezed
sealed class Media with _$Media {
  const Media._();

  const factory Media.redditVideo(
    RedditVideo field0,
  ) = Media_RedditVideo;
  const factory Media.oembed({
    required Oembed oembed,
    required String typeField,
  }) = Media_Oembed;
}

class MediaEmbed {
  final String content;
  final int width;
  final bool scrolling;
  final int height;

  const MediaEmbed({
    required this.content,
    required this.width,
    required this.scrolling,
    required this.height,
  });

  static Future<MediaEmbed> default_() =>
      RustLib.instance.api.redditApiModelPostMediaEmbedDefault();

  @override
  int get hashCode =>
      content.hashCode ^ width.hashCode ^ scrolling.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MediaEmbed &&
          runtimeType == other.runtimeType &&
          content == other.content &&
          width == other.width &&
          scrolling == other.scrolling &&
          height == other.height;
}

class Oembed {
  final String providerUrl;
  final String title;
  final String html;
  final int height;
  final int width;
  final String version;
  final String authorName;
  final String providerName;
  final String typeField;
  final String authorUrl;
  final ThumbnailOption thumbnail;

  const Oembed({
    required this.providerUrl,
    required this.title,
    required this.html,
    required this.height,
    required this.width,
    required this.version,
    required this.authorName,
    required this.providerName,
    required this.typeField,
    required this.authorUrl,
    required this.thumbnail,
  });

  static Future<Oembed> default_() =>
      RustLib.instance.api.redditApiModelPostOembedDefault();

  @override
  int get hashCode =>
      providerUrl.hashCode ^
      title.hashCode ^
      html.hashCode ^
      height.hashCode ^
      width.hashCode ^
      version.hashCode ^
      authorName.hashCode ^
      providerName.hashCode ^
      typeField.hashCode ^
      authorUrl.hashCode ^
      thumbnail.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Oembed &&
          runtimeType == other.runtimeType &&
          providerUrl == other.providerUrl &&
          title == other.title &&
          html == other.html &&
          height == other.height &&
          width == other.width &&
          version == other.version &&
          authorName == other.authorName &&
          providerName == other.providerName &&
          typeField == other.typeField &&
          authorUrl == other.authorUrl &&
          thumbnail == other.thumbnail;
}

class Preview {
  final List<RedditImage> images;
  final bool enabled;

  const Preview({
    required this.images,
    required this.enabled,
  });

  static Future<Preview> default_() =>
      RustLib.instance.api.redditApiModelPostPreviewDefault();

  @override
  int get hashCode => images.hashCode ^ enabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Preview &&
          runtimeType == other.runtimeType &&
          images == other.images &&
          enabled == other.enabled;
}

class RedditImage {
  final ImageBase source;
  final List<ImageBase> resolutions;
  final Variants variants;
  final String id;

  const RedditImage({
    required this.source,
    required this.resolutions,
    required this.variants,
    required this.id,
  });

  static Future<RedditImage> default_() =>
      RustLib.instance.api.redditApiModelPostRedditImageDefault();

  @override
  int get hashCode =>
      source.hashCode ^ resolutions.hashCode ^ variants.hashCode ^ id.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RedditImage &&
          runtimeType == other.runtimeType &&
          source == other.source &&
          resolutions == other.resolutions &&
          variants == other.variants &&
          id == other.id;
}

class RedditVideo {
  final int bitrateKbps;
  final int width;
  final int height;
  final bool hasAudio;
  final bool isGif;
  final String fallbackUrl;
  final String scrubberMediaUrl;
  final String dashUrl;
  final String hlsUrl;

  /// Duration in seconds
  final int duration;
  final String transcodingStatus;

  const RedditVideo({
    required this.bitrateKbps,
    required this.width,
    required this.height,
    required this.hasAudio,
    required this.isGif,
    required this.fallbackUrl,
    required this.scrubberMediaUrl,
    required this.dashUrl,
    required this.hlsUrl,
    required this.duration,
    required this.transcodingStatus,
  });

  static Future<RedditVideo> default_() =>
      RustLib.instance.api.redditApiModelPostRedditVideoDefault();

  @override
  int get hashCode =>
      bitrateKbps.hashCode ^
      width.hashCode ^
      height.hashCode ^
      hasAudio.hashCode ^
      isGif.hashCode ^
      fallbackUrl.hashCode ^
      scrubberMediaUrl.hashCode ^
      dashUrl.hashCode ^
      hlsUrl.hashCode ^
      duration.hashCode ^
      transcodingStatus.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RedditVideo &&
          runtimeType == other.runtimeType &&
          bitrateKbps == other.bitrateKbps &&
          width == other.width &&
          height == other.height &&
          hasAudio == other.hasAudio &&
          isGif == other.isGif &&
          fallbackUrl == other.fallbackUrl &&
          scrubberMediaUrl == other.scrubberMediaUrl &&
          dashUrl == other.dashUrl &&
          hlsUrl == other.hlsUrl &&
          duration == other.duration &&
          transcodingStatus == other.transcodingStatus;
}

class SecureMediaEmbed {
  final String content;
  final int width;
  final bool scrolling;
  final String mediaDomainUrl;
  final int height;

  const SecureMediaEmbed({
    required this.content,
    required this.width,
    required this.scrolling,
    required this.mediaDomainUrl,
    required this.height,
  });

  static Future<SecureMediaEmbed> default_() =>
      RustLib.instance.api.redditApiModelPostSecureMediaEmbedDefault();

  @override
  int get hashCode =>
      content.hashCode ^
      width.hashCode ^
      scrolling.hashCode ^
      mediaDomainUrl.hashCode ^
      height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SecureMediaEmbed &&
          runtimeType == other.runtimeType &&
          content == other.content &&
          width == other.width &&
          scrolling == other.scrolling &&
          mediaDomainUrl == other.mediaDomainUrl &&
          height == other.height;
}

class Thumbnail {
  final String url;
  final int height;
  final int width;

  const Thumbnail({
    required this.url,
    required this.height,
    required this.width,
  });

  @override
  int get hashCode => url.hashCode ^ height.hashCode ^ width.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Thumbnail &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          height == other.height &&
          width == other.width;
}

class ThumbnailOption {
  final String? url;
  final int? height;
  final int? width;

  const ThumbnailOption({
    this.url,
    this.height,
    this.width,
  });

  static Future<ThumbnailOption> default_() =>
      RustLib.instance.api.redditApiModelPostThumbnailOptionDefault();

  @override
  int get hashCode => url.hashCode ^ height.hashCode ^ width.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ThumbnailOption &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          height == other.height &&
          width == other.width;
}

class ThumbnailURL {
  final String? url;
  final int? height;
  final int? width;

  const ThumbnailURL({
    this.url,
    this.height,
    this.width,
  });

  static Future<ThumbnailURL> default_() =>
      RustLib.instance.api.redditApiModelPostThumbnailUrlDefault();

  @override
  int get hashCode => url.hashCode ^ height.hashCode ^ width.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ThumbnailURL &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          height == other.height &&
          width == other.width;
}

class VariantInner {
  final ImageBase source;
  final List<ImageBase> resolutions;

  const VariantInner({
    required this.source,
    required this.resolutions,
  });

  static Future<VariantInner> default_() =>
      RustLib.instance.api.redditApiModelPostVariantInnerDefault();

  @override
  int get hashCode => source.hashCode ^ resolutions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VariantInner &&
          runtimeType == other.runtimeType &&
          source == other.source &&
          resolutions == other.resolutions;
}

class Variants {
  final VariantInner? gif;
  final VariantInner? mp4;
  final VariantInner? obfuscated;
  final VariantInner? nsfw;

  const Variants({
    this.gif,
    this.mp4,
    this.obfuscated,
    this.nsfw,
  });

  static Future<Variants> default_() =>
      RustLib.instance.api.redditApiModelPostVariantsDefault();

  @override
  int get hashCode =>
      gif.hashCode ^ mp4.hashCode ^ obfuscated.hashCode ^ nsfw.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Variants &&
          runtimeType == other.runtimeType &&
          gif == other.gif &&
          mp4 == other.mp4 &&
          obfuscated == other.obfuscated &&
          nsfw == other.nsfw;
}
