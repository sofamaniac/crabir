// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../model.dart';
import 'flair.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ThumbnailOption`, `ThumbnailURL`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `try_from`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `default`, `default`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AuthorInfo>>
abstract class AuthorInfo implements RustOpaqueInterface {
  Flair get flair;

  String get fullname;

  bool get isBlocked;

  bool get patreonFlair;

  bool get premium;

  String get username;

  set flair(Flair flair);

  set fullname(String fullname);

  set isBlocked(bool isBlocked);

  set patreonFlair(bool patreonFlair);

  set premium(bool premium);

  set username(String username);

  static Future<AuthorInfo> default_() =>
      RustLib.instance.api.redditApiModelPostAuthorInfoDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Media>>
abstract class Media implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Oembed>>
abstract class Oembed implements RustOpaqueInterface {
  String get authorName;

  String get authorUrl;

  PlatformInt64 get height;

  String get html;

  String get providerName;

  String get providerUrl;

  String get title;

  String get typeField;

  String get version;

  PlatformInt64 get width;

  set authorName(String authorName);

  set authorUrl(String authorUrl);

  set height(PlatformInt64 height);

  set html(String html);

  set providerName(String providerName);

  set providerUrl(String providerUrl);

  set title(String title);

  set typeField(String typeField);

  set version(String version);

  set width(PlatformInt64 width);

  static Future<Oembed> default_() =>
      RustLib.instance.api.redditApiModelPostOembedDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Post>>
abstract class Post implements RustOpaqueInterface {
  List<String?> get allAwardings;

  bool get allowLiveComments;

  double? get approvedAtUtc;

  String? get approvedBy;

  bool get archived;

  AuthorInfo? get author;

  List<String?> get awarders;

  double? get bannedAtUtc;

  String? get bannedBy;

  bool get canGild;

  bool get canModPost;

  String? get category;

  bool get clicked;

  List<String> get contentCategories;

  bool get contestMode;

  DateTime get created;

  DateTime get createdUtc;

  String? get discussionType;

  String? get distinguished;

  String get domain;

  PlatformInt64 get downs;

  double? get edited;

  Gallery? get gallery;

  PlatformInt64 get gilded;

  Gildings get gildings;

  bool get hidden;

  bool get hideScore;

  PostId get id;

  bool get isCreatedFromAdsUi;

  bool get isCrosspostable;

  bool get isMeta;

  bool get isOriginalContent;

  bool get isRedditMediaDomain;

  bool get isRobotIndexable;

  bool get isSelf;

  bool get isVideo;

  bool? get likes;

  Flair get linkFlair;

  bool get locked;

  Media? get media;

  MediaEmbed? get mediaEmbed;

  bool get mediaOnly;

  String? get modNote;

  String? get modReasonBy;

  String? get modReasonTitle;

  List<String?> get modReports;

  Fullname get name;

  bool get noFollow;

  PlatformInt64 get numComments;

  PlatformInt64? get numCrossposts;

  BigInt? get numDuplicates;

  String? get numReports;

  bool get over18;

  String get permalink;

  bool get pinned;

  String? get postHint;

  Preview? get preview;

  PlatformInt64? get pwls;

  bool get quarantine;

  String? get removalReason;

  String? get removedBy;

  String? get removedByCategory;

  String? get reportReasons;

  bool get saved;

  PlatformInt64 get score;

  SecureMedia? get secureMedia;

  SecureMediaEmbed? get secureMediaEmbed;

  String? get selftext;

  String? get selftextHtml;

  bool get sendReplies;

  bool get spoiler;

  bool get stickied;

  SubredditInfo get subreddit;

  String? get suggestedSort;

  String get title;

  String? get topAwardedType;

  PlatformInt64? get totalAwardsReceived;

  List<String?> get treatmentTags;

  PlatformInt64 get ups;

  double get upvoteRatio;

  String get url;

  String? get urlOverriddenByDest;

  List<String?> get userReports;

  String? get viewCount;

  bool get visited;

  PlatformInt64? get wls;

  set allAwardings(List<String?> allAwardings);

  set allowLiveComments(bool allowLiveComments);

  set approvedAtUtc(double? approvedAtUtc);

  set approvedBy(String? approvedBy);

  set archived(bool archived);

  set author(AuthorInfo? author);

  set awarders(List<String?> awarders);

  set bannedAtUtc(double? bannedAtUtc);

  set bannedBy(String? bannedBy);

  set canGild(bool canGild);

  set canModPost(bool canModPost);

  set category(String? category);

  set clicked(bool clicked);

  set contentCategories(List<String> contentCategories);

  set contestMode(bool contestMode);

  set created(DateTime created);

  set createdUtc(DateTime createdUtc);

  set discussionType(String? discussionType);

  set distinguished(String? distinguished);

  set domain(String domain);

  set downs(PlatformInt64 downs);

  set edited(double? edited);

  set gallery(Gallery? gallery);

  set gilded(PlatformInt64 gilded);

  set gildings(Gildings gildings);

  set hidden(bool hidden);

  set hideScore(bool hideScore);

  set id(PostId id);

  set isCreatedFromAdsUi(bool isCreatedFromAdsUi);

  set isCrosspostable(bool isCrosspostable);

  set isMeta(bool isMeta);

  set isOriginalContent(bool isOriginalContent);

  set isRedditMediaDomain(bool isRedditMediaDomain);

  set isRobotIndexable(bool isRobotIndexable);

  set isSelf(bool isSelf);

  set isVideo(bool isVideo);

  set likes(bool? likes);

  set linkFlair(Flair linkFlair);

  set locked(bool locked);

  set media(Media? media);

  set mediaEmbed(MediaEmbed? mediaEmbed);

  set mediaOnly(bool mediaOnly);

  set modNote(String? modNote);

  set modReasonBy(String? modReasonBy);

  set modReasonTitle(String? modReasonTitle);

  set modReports(List<String?> modReports);

  set name(Fullname name);

  set noFollow(bool noFollow);

  set numComments(PlatformInt64 numComments);

  set numCrossposts(PlatformInt64? numCrossposts);

  set numDuplicates(BigInt? numDuplicates);

  set numReports(String? numReports);

  set over18(bool over18);

  set permalink(String permalink);

  set pinned(bool pinned);

  set postHint(String? postHint);

  set preview(Preview? preview);

  set pwls(PlatformInt64? pwls);

  set quarantine(bool quarantine);

  set removalReason(String? removalReason);

  set removedBy(String? removedBy);

  set removedByCategory(String? removedByCategory);

  set reportReasons(String? reportReasons);

  set saved(bool saved);

  set score(PlatformInt64 score);

  set secureMedia(SecureMedia? secureMedia);

  set secureMediaEmbed(SecureMediaEmbed? secureMediaEmbed);

  set selftext(String? selftext);

  set selftextHtml(String? selftextHtml);

  set sendReplies(bool sendReplies);

  set spoiler(bool spoiler);

  set stickied(bool stickied);

  set subreddit(SubredditInfo subreddit);

  set suggestedSort(String? suggestedSort);

  set title(String title);

  set topAwardedType(String? topAwardedType);

  set totalAwardsReceived(PlatformInt64? totalAwardsReceived);

  set treatmentTags(List<String?> treatmentTags);

  set ups(PlatformInt64 ups);

  set upvoteRatio(double upvoteRatio);

  set url(String url);

  set urlOverriddenByDest(String? urlOverriddenByDest);

  set userReports(List<String?> userReports);

  set viewCount(String? viewCount);

  set visited(bool visited);

  set wls(PlatformInt64? wls);

  static Future<Post> default_() =>
      RustLib.instance.api.redditApiModelPostPostDefault();

  Kind get kind;

  Thumbnail? get thumbnail;
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PostID>>
abstract class PostId implements RustOpaqueInterface {
  static Future<PostId> default_() =>
      RustLib.instance.api.redditApiModelPostPostIdDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RedditVideo>>
abstract class RedditVideo implements RustOpaqueInterface {
  static Future<RedditVideo> default_() =>
      RustLib.instance.api.redditApiModelPostRedditVideoDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SecureMedia>>
abstract class SecureMedia implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SubredditID>>
abstract class SubredditId implements RustOpaqueInterface {
  static Future<SubredditId> default_() =>
      RustLib.instance.api.redditApiModelPostSubredditIdDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SubredditInfo>>
abstract class SubredditInfo implements RustOpaqueInterface {
  String get subreddit;

  SubredditId get subredditId;

  String get subredditNamePrefixed;

  String get subredditType;

  BigInt get subscribers;

  set subreddit(String subreddit);

  set subredditId(SubredditId subredditId);

  set subredditNamePrefixed(String subredditNamePrefixed);

  set subredditType(String subredditType);

  set subscribers(BigInt subscribers);

  static Future<SubredditInfo> default_() =>
      RustLib.instance.api.redditApiModelPostSubredditInfoDefault();
}

class Gallery {
  const Gallery();

  static Future<Gallery> default_() =>
      RustLib.instance.api.redditApiModelPostGalleryDefault();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Gallery && runtimeType == other.runtimeType;
}

class Gildings {
  const Gildings();

  static Future<Gildings> default_() =>
      RustLib.instance.api.redditApiModelPostGildingsDefault();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Gildings && runtimeType == other.runtimeType;
}

class Image {
  final ImageBase source;
  final List<ImageBase> resolutions;
  final Variants variants;
  final String id;

  const Image({
    required this.source,
    required this.resolutions,
    required this.variants,
    required this.id,
  });

  static Future<Image> default_() =>
      RustLib.instance.api.redditApiModelPostImageDefault();

  @override
  int get hashCode =>
      source.hashCode ^ resolutions.hashCode ^ variants.hashCode ^ id.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Image &&
          runtimeType == other.runtimeType &&
          source == other.source &&
          resolutions == other.resolutions &&
          variants == other.variants &&
          id == other.id;
}

class ImageBase {
  final String url;
  final PlatformInt64 width;
  final PlatformInt64 height;

  const ImageBase({
    required this.url,
    required this.width,
    required this.height,
  });

  static Future<ImageBase> default_() =>
      RustLib.instance.api.redditApiModelPostImageBaseDefault();

  @override
  int get hashCode => url.hashCode ^ width.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ImageBase &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          width == other.width &&
          height == other.height;
}

enum Kind {
  selftext,
  meta,
  image,
  video,
  gallery,
  link,
  unknown,
  ;
}

class MediaEmbed {
  final String content;
  final PlatformInt64 width;
  final bool scrolling;
  final PlatformInt64 height;

  const MediaEmbed({
    required this.content,
    required this.width,
    required this.scrolling,
    required this.height,
  });

  static Future<MediaEmbed> default_() =>
      RustLib.instance.api.redditApiModelPostMediaEmbedDefault();

  @override
  int get hashCode =>
      content.hashCode ^ width.hashCode ^ scrolling.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MediaEmbed &&
          runtimeType == other.runtimeType &&
          content == other.content &&
          width == other.width &&
          scrolling == other.scrolling &&
          height == other.height;
}

class Preview {
  final List<Image> images;
  final bool enabled;

  const Preview({
    required this.images,
    required this.enabled,
  });

  static Future<Preview> default_() =>
      RustLib.instance.api.redditApiModelPostPreviewDefault();

  @override
  int get hashCode => images.hashCode ^ enabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Preview &&
          runtimeType == other.runtimeType &&
          images == other.images &&
          enabled == other.enabled;
}

class SecureMediaEmbed {
  final String content;
  final PlatformInt64 width;
  final bool scrolling;
  final String mediaDomainUrl;
  final PlatformInt64 height;

  const SecureMediaEmbed({
    required this.content,
    required this.width,
    required this.scrolling,
    required this.mediaDomainUrl,
    required this.height,
  });

  static Future<SecureMediaEmbed> default_() =>
      RustLib.instance.api.redditApiModelPostSecureMediaEmbedDefault();

  @override
  int get hashCode =>
      content.hashCode ^
      width.hashCode ^
      scrolling.hashCode ^
      mediaDomainUrl.hashCode ^
      height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SecureMediaEmbed &&
          runtimeType == other.runtimeType &&
          content == other.content &&
          width == other.width &&
          scrolling == other.scrolling &&
          mediaDomainUrl == other.mediaDomainUrl &&
          height == other.height;
}

class Thumbnail {
  final String url;
  final BigInt height;
  final BigInt width;

  const Thumbnail({
    required this.url,
    required this.height,
    required this.width,
  });

  @override
  int get hashCode => url.hashCode ^ height.hashCode ^ width.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Thumbnail &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          height == other.height &&
          width == other.width;
}

class Variants {
  const Variants();

  static Future<Variants> default_() =>
      RustLib.instance.api.redditApiModelPostVariantsDefault();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Variants && runtimeType == other.runtimeType;
}
