// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../model.dart';
import 'author.dart';
import 'flair.dart';
import 'gallery.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'subreddit.dart';
part 'post.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `SecureMedia`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `try_from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Post>>
abstract class Post implements RustOpaqueInterface {
  List<String?> get allAwardings;

  bool get allowLiveComments;

  double? get approvedAtUtc;

  String? get approvedBy;

  bool get archived;

  AuthorInfo? get author;

  List<String?> get awarders;

  double? get bannedAtUtc;

  String? get bannedBy;

  bool get canGild;

  bool get canModPost;

  String? get category;

  bool get clicked;

  List<String> get contentCategories;

  bool get contestMode;

  DateTime get created;

  DateTime get createdUtc;

  String? get discussionType;

  String? get distinguished;

  String get domain;

  int get downs;

  double? get edited;

  Gallery? get gallery;

  int get gilded;

  Gildings get gildings;

  bool get hidden;

  bool get hideScore;

  PostId get id;

  bool get isCreatedFromAdsUi;

  bool get isCrosspostable;

  bool get isGallery;

  bool get isMeta;

  bool get isOriginalContent;

  bool get isRedditMediaDomain;

  bool get isRobotIndexable;

  bool get isSelf;

  bool get isVideo;

  bool? get likes;

  Flair get linkFlair;

  bool get locked;

  Media? get media;

  MediaEmbed? get mediaEmbed;

  bool get mediaOnly;

  String? get modNote;

  String? get modReasonBy;

  String? get modReasonTitle;

  List<String?> get modReports;

  Fullname get name;

  bool get noFollow;

  int get numComments;

  int? get numCrossposts;

  int? get numDuplicates;

  int? get numReports;

  bool get over18;

  String get permalink;

  bool get pinned;

  String? get postHint;

  Preview? get preview;

  int? get pwls;

  bool get quarantine;

  String? get removalReason;

  String? get removedBy;

  String? get removedByCategory;

  List<String> get reportReasons;

  bool get saved;

  int get score;

  Media? get secureMedia;

  SecureMediaEmbed? get secureMediaEmbed;

  String? get selftext;

  String? get selftextHtml;

  bool get sendReplies;

  bool get spoiler;

  bool get stickied;

  SubredditInfo get subreddit;

  String? get suggestedSort;

  String get title;

  String? get topAwardedType;

  int? get totalAwardsReceived;

  List<String?> get treatmentTags;

  int get ups;

  double get upvoteRatio;

  String get url;

  String? get urlOverriddenByDest;

  List<String?> get userReports;

  String? get viewCount;

  bool get visited;

  int? get wls;

  set allAwardings(List<String?> allAwardings);

  set allowLiveComments(bool allowLiveComments);

  set approvedAtUtc(double? approvedAtUtc);

  set approvedBy(String? approvedBy);

  set archived(bool archived);

  set author(AuthorInfo? author);

  set awarders(List<String?> awarders);

  set bannedAtUtc(double? bannedAtUtc);

  set bannedBy(String? bannedBy);

  set canGild(bool canGild);

  set canModPost(bool canModPost);

  set category(String? category);

  set clicked(bool clicked);

  set contentCategories(List<String> contentCategories);

  set contestMode(bool contestMode);

  set created(DateTime created);

  set createdUtc(DateTime createdUtc);

  set discussionType(String? discussionType);

  set distinguished(String? distinguished);

  set domain(String domain);

  set downs(int downs);

  set edited(double? edited);

  set gallery(Gallery? gallery);

  set gilded(int gilded);

  set gildings(Gildings gildings);

  set hidden(bool hidden);

  set hideScore(bool hideScore);

  set id(PostId id);

  set isCreatedFromAdsUi(bool isCreatedFromAdsUi);

  set isCrosspostable(bool isCrosspostable);

  set isGallery(bool isGallery);

  set isMeta(bool isMeta);

  set isOriginalContent(bool isOriginalContent);

  set isRedditMediaDomain(bool isRedditMediaDomain);

  set isRobotIndexable(bool isRobotIndexable);

  set isSelf(bool isSelf);

  set isVideo(bool isVideo);

  set likes(bool? likes);

  set linkFlair(Flair linkFlair);

  set locked(bool locked);

  set media(Media? media);

  set mediaEmbed(MediaEmbed? mediaEmbed);

  set mediaOnly(bool mediaOnly);

  set modNote(String? modNote);

  set modReasonBy(String? modReasonBy);

  set modReasonTitle(String? modReasonTitle);

  set modReports(List<String?> modReports);

  set name(Fullname name);

  set noFollow(bool noFollow);

  set numComments(int numComments);

  set numCrossposts(int? numCrossposts);

  set numDuplicates(int? numDuplicates);

  set numReports(int? numReports);

  set over18(bool over18);

  set permalink(String permalink);

  set pinned(bool pinned);

  set postHint(String? postHint);

  set preview(Preview? preview);

  set pwls(int? pwls);

  set quarantine(bool quarantine);

  set removalReason(String? removalReason);

  set removedBy(String? removedBy);

  set removedByCategory(String? removedByCategory);

  set reportReasons(List<String> reportReasons);

  set saved(bool saved);

  set score(int score);

  set secureMedia(Media? secureMedia);

  set secureMediaEmbed(SecureMediaEmbed? secureMediaEmbed);

  set selftext(String? selftext);

  set selftextHtml(String? selftextHtml);

  set sendReplies(bool sendReplies);

  set spoiler(bool spoiler);

  set stickied(bool stickied);

  set subreddit(SubredditInfo subreddit);

  set suggestedSort(String? suggestedSort);

  set title(String title);

  set topAwardedType(String? topAwardedType);

  set totalAwardsReceived(int? totalAwardsReceived);

  set treatmentTags(List<String?> treatmentTags);

  set ups(int ups);

  set upvoteRatio(double upvoteRatio);

  set url(String url);

  set urlOverriddenByDest(String? urlOverriddenByDest);

  set userReports(List<String?> userReports);

  set viewCount(String? viewCount);

  set visited(bool visited);

  set wls(int? wls);

  static Future<Post> default_() =>
      RustLib.instance.api.redditApiModelPostPostDefault();

  Kind get kind;

  Thumbnail? get thumbnail;
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PostID>>
abstract class PostId implements RustOpaqueInterface {
  static Future<PostId> default_() =>
      RustLib.instance.api.redditApiModelPostPostIdDefault();
}

class Gildings {
  const Gildings();

  static Future<Gildings> default_() =>
      RustLib.instance.api.redditApiModelPostGildingsDefault();

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Gildings && runtimeType == other.runtimeType;
}

class ImageBase {
  final String url;
  final int width;
  final int height;

  const ImageBase({
    required this.url,
    required this.width,
    required this.height,
  });

  static Future<ImageBase> default_() =>
      RustLib.instance.api.redditApiModelPostImageBaseDefault();

  @override
  int get hashCode => url.hashCode ^ width.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ImageBase &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          width == other.width &&
          height == other.height;
}

enum Kind {
  selftext,
  meta,
  image,

  /// Video hosted on Reddit
  video,

  /// Video hosted on Youtube
  youtubeVideo,

  /// Gallery present in `Post::Gallery`
  gallery,

  /// Gallery at `Post::url`
  mediaGallery,
  link,
  unknown,
  ;
}

@freezed
sealed class Media with _$Media {
  const Media._();

  const factory Media.redditVideo(
    RedditVideo field0,
  ) = Media_RedditVideo;
  const factory Media.oembed({
    required Oembed oembed,
    required String typeField,
  }) = Media_Oembed;
}

class MediaEmbed {
  final String content;
  final int width;
  final bool scrolling;
  final int height;

  const MediaEmbed({
    required this.content,
    required this.width,
    required this.scrolling,
    required this.height,
  });

  static Future<MediaEmbed> default_() =>
      RustLib.instance.api.redditApiModelPostMediaEmbedDefault();

  @override
  int get hashCode =>
      content.hashCode ^ width.hashCode ^ scrolling.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MediaEmbed &&
          runtimeType == other.runtimeType &&
          content == other.content &&
          width == other.width &&
          scrolling == other.scrolling &&
          height == other.height;
}

/// flutter_rust_bridge:non_opaque
class Oembed {
  final String providerUrl;
  final String title;
  final String html;
  final int height;
  final int width;
  final String version;
  final String authorName;
  final String providerName;
  final String typeField;
  final String authorUrl;
  final ThumbnailOption thumbnail;

  const Oembed({
    required this.providerUrl,
    required this.title,
    required this.html,
    required this.height,
    required this.width,
    required this.version,
    required this.authorName,
    required this.providerName,
    required this.typeField,
    required this.authorUrl,
    required this.thumbnail,
  });

  static Future<Oembed> default_() =>
      RustLib.instance.api.redditApiModelPostOembedDefault();

  @override
  int get hashCode =>
      providerUrl.hashCode ^
      title.hashCode ^
      html.hashCode ^
      height.hashCode ^
      width.hashCode ^
      version.hashCode ^
      authorName.hashCode ^
      providerName.hashCode ^
      typeField.hashCode ^
      authorUrl.hashCode ^
      thumbnail.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Oembed &&
          runtimeType == other.runtimeType &&
          providerUrl == other.providerUrl &&
          title == other.title &&
          html == other.html &&
          height == other.height &&
          width == other.width &&
          version == other.version &&
          authorName == other.authorName &&
          providerName == other.providerName &&
          typeField == other.typeField &&
          authorUrl == other.authorUrl &&
          thumbnail == other.thumbnail;
}

class Preview {
  final List<RedditImage> images;
  final bool enabled;

  const Preview({
    required this.images,
    required this.enabled,
  });

  static Future<Preview> default_() =>
      RustLib.instance.api.redditApiModelPostPreviewDefault();

  @override
  int get hashCode => images.hashCode ^ enabled.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Preview &&
          runtimeType == other.runtimeType &&
          images == other.images &&
          enabled == other.enabled;
}

/// flutter_rust_bridge:non_opaque
class RedditImage {
  final ImageBase source;
  final List<ImageBase> resolutions;
  final Variants variants;
  final String id;

  const RedditImage({
    required this.source,
    required this.resolutions,
    required this.variants,
    required this.id,
  });

  static Future<RedditImage> default_() =>
      RustLib.instance.api.redditApiModelPostRedditImageDefault();

  @override
  int get hashCode =>
      source.hashCode ^ resolutions.hashCode ^ variants.hashCode ^ id.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RedditImage &&
          runtimeType == other.runtimeType &&
          source == other.source &&
          resolutions == other.resolutions &&
          variants == other.variants &&
          id == other.id;
}

/// flutter_rust_bridge:non_opaque
class RedditVideo {
  final int bitrateKbps;
  final int width;
  final int height;
  final bool hasAudio;
  final bool isGif;
  final String fallbackUrl;
  final String scrubberMediaUrl;
  final String dashUrl;
  final String hlsUrl;

  /// Duration in seconds
  final int duration;
  final String transcodingStatus;

  const RedditVideo({
    required this.bitrateKbps,
    required this.width,
    required this.height,
    required this.hasAudio,
    required this.isGif,
    required this.fallbackUrl,
    required this.scrubberMediaUrl,
    required this.dashUrl,
    required this.hlsUrl,
    required this.duration,
    required this.transcodingStatus,
  });

  static Future<RedditVideo> default_() =>
      RustLib.instance.api.redditApiModelPostRedditVideoDefault();

  @override
  int get hashCode =>
      bitrateKbps.hashCode ^
      width.hashCode ^
      height.hashCode ^
      hasAudio.hashCode ^
      isGif.hashCode ^
      fallbackUrl.hashCode ^
      scrubberMediaUrl.hashCode ^
      dashUrl.hashCode ^
      hlsUrl.hashCode ^
      duration.hashCode ^
      transcodingStatus.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RedditVideo &&
          runtimeType == other.runtimeType &&
          bitrateKbps == other.bitrateKbps &&
          width == other.width &&
          height == other.height &&
          hasAudio == other.hasAudio &&
          isGif == other.isGif &&
          fallbackUrl == other.fallbackUrl &&
          scrubberMediaUrl == other.scrubberMediaUrl &&
          dashUrl == other.dashUrl &&
          hlsUrl == other.hlsUrl &&
          duration == other.duration &&
          transcodingStatus == other.transcodingStatus;
}

class SecureMediaEmbed {
  final String content;
  final int width;
  final bool scrolling;
  final String mediaDomainUrl;
  final int height;

  const SecureMediaEmbed({
    required this.content,
    required this.width,
    required this.scrolling,
    required this.mediaDomainUrl,
    required this.height,
  });

  static Future<SecureMediaEmbed> default_() =>
      RustLib.instance.api.redditApiModelPostSecureMediaEmbedDefault();

  @override
  int get hashCode =>
      content.hashCode ^
      width.hashCode ^
      scrolling.hashCode ^
      mediaDomainUrl.hashCode ^
      height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SecureMediaEmbed &&
          runtimeType == other.runtimeType &&
          content == other.content &&
          width == other.width &&
          scrolling == other.scrolling &&
          mediaDomainUrl == other.mediaDomainUrl &&
          height == other.height;
}

class Thumbnail {
  final String url;
  final int height;
  final int width;

  const Thumbnail({
    required this.url,
    required this.height,
    required this.width,
  });

  @override
  int get hashCode => url.hashCode ^ height.hashCode ^ width.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Thumbnail &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          height == other.height &&
          width == other.width;
}

class ThumbnailOption {
  final String? url;
  final int? height;
  final int? width;

  const ThumbnailOption({
    this.url,
    this.height,
    this.width,
  });

  static Future<ThumbnailOption> default_() =>
      RustLib.instance.api.redditApiModelPostThumbnailOptionDefault();

  @override
  int get hashCode => url.hashCode ^ height.hashCode ^ width.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ThumbnailOption &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          height == other.height &&
          width == other.width;
}

class ThumbnailURL {
  final String? url;
  final int? height;
  final int? width;

  const ThumbnailURL({
    this.url,
    this.height,
    this.width,
  });

  static Future<ThumbnailURL> default_() =>
      RustLib.instance.api.redditApiModelPostThumbnailUrlDefault();

  @override
  int get hashCode => url.hashCode ^ height.hashCode ^ width.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ThumbnailURL &&
          runtimeType == other.runtimeType &&
          url == other.url &&
          height == other.height &&
          width == other.width;
}

/// flutter_rust_bridge:non_opaque
class VariantInner {
  final ImageBase source;
  final List<ImageBase> resolutions;

  const VariantInner({
    required this.source,
    required this.resolutions,
  });

  static Future<VariantInner> default_() =>
      RustLib.instance.api.redditApiModelPostVariantInnerDefault();

  @override
  int get hashCode => source.hashCode ^ resolutions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is VariantInner &&
          runtimeType == other.runtimeType &&
          source == other.source &&
          resolutions == other.resolutions;
}

/// flutter_rust_bridge:non_opaque
class Variants {
  final VariantInner? gif;
  final VariantInner? mp4;
  final VariantInner? obfuscated;
  final VariantInner? nsfw;

  const Variants({
    this.gif,
    this.mp4,
    this.obfuscated,
    this.nsfw,
  });

  static Future<Variants> default_() =>
      RustLib.instance.api.redditApiModelPostVariantsDefault();

  @override
  int get hashCode =>
      gif.hashCode ^ mp4.hashCode ^ obfuscated.hashCode ^ nsfw.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Variants &&
          runtimeType == other.runtimeType &&
          gif == other.gif &&
          mp4 == other.mp4 &&
          obfuscated == other.obfuscated &&
          nsfw == other.nsfw;
}
