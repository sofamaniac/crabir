// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'gallery.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `MediaId`, `MediaMetadata`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Gallery>>
abstract class Gallery implements RustOpaqueInterface {
  static Future<Gallery> default_() =>
      RustLib.instance.api.redditApiModelGalleryGalleryDefault();

  /// flutter_rust_bridge:sync
  Source get_({required int index});

  /// flutter_rust_bridge:sync,getter
  double get aspectRatio;

  /// flutter_rust_bridge:sync,getter
  int get length;
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GalleryData>>
abstract class GalleryData implements RustOpaqueInterface {
  static Future<GalleryData> default_() =>
      RustLib.instance.api.redditApiModelGalleryGalleryDataDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GalleryMedia>>
abstract class GalleryMedia implements RustOpaqueInterface {
  String get mediaType;

  set mediaType(String mediaType);
}

class AnimatedImage {
  final int x;
  final int y;
  final String gif;
  final String mp4;

  const AnimatedImage({
    required this.x,
    required this.y,
    required this.gif,
    required this.mp4,
  });

  static Future<AnimatedImage> default_() =>
      RustLib.instance.api.redditApiModelGalleryAnimatedImageDefault();

  @override
  int get hashCode => x.hashCode ^ y.hashCode ^ gif.hashCode ^ mp4.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AnimatedImage &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y &&
          gif == other.gif &&
          mp4 == other.mp4;
}

class Image {
  final String u;
  final int x;
  final int y;

  const Image({
    required this.u,
    required this.x,
    required this.y,
  });

  static Future<Image> default_() =>
      RustLib.instance.api.redditApiModelGalleryImageDefault();

  @override
  int get hashCode => u.hashCode ^ x.hashCode ^ y.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Image &&
          runtimeType == other.runtimeType &&
          u == other.u &&
          x == other.x &&
          y == other.y;
}

@freezed
sealed class Source with _$Source {
  const Source._();

  const factory Source.image({
    required Image source,
  }) = Source_Image;
  const factory Source.animatedImage({
    required AnimatedImage source,
  }) = Source_AnimatedImage;
}
