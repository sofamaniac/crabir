// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../../frb_generated.dart';
import '../../model.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'model.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

class Features {
  final bool modmailHarassmentFilter;
  final bool modServiceMuteWrites;
  final bool promotedTrendBlanks;
  final bool showAmpLink;
  final bool isEmailPermissionRequired;
  final bool modAwards;
  final bool expensiveCoinsPackage;
  final bool chatSubreddit;
  final bool awardsOnStreams;
  final bool mwebXpromoModalListingClickDailyDismissibleIos;
  final bool cookieConsentBanner;
  final bool modlogCopyrightRemoval;
  final bool doNotTrack;
  final bool imagesInComments;
  final bool modServiceMuteReads;
  final bool chatUserSettings;
  final bool usePrefAccountDeployment;
  final bool mwebXpromoInterstitialCommentsIos;
  final bool mwebXpromoModalListingClickDailyDismissibleAndroid;
  final bool premiumSubscriptionsTable;
  final bool mwebXpromoInterstitialCommentsAndroid;
  final bool crowdControlForPost;
  final bool chatGroupRollout;
  final bool resizedStylesImages;
  final bool noreferrerToNoopener;

  const Features({
    required this.modmailHarassmentFilter,
    required this.modServiceMuteWrites,
    required this.promotedTrendBlanks,
    required this.showAmpLink,
    required this.isEmailPermissionRequired,
    required this.modAwards,
    required this.expensiveCoinsPackage,
    required this.chatSubreddit,
    required this.awardsOnStreams,
    required this.mwebXpromoModalListingClickDailyDismissibleIos,
    required this.cookieConsentBanner,
    required this.modlogCopyrightRemoval,
    required this.doNotTrack,
    required this.imagesInComments,
    required this.modServiceMuteReads,
    required this.chatUserSettings,
    required this.usePrefAccountDeployment,
    required this.mwebXpromoInterstitialCommentsIos,
    required this.mwebXpromoModalListingClickDailyDismissibleAndroid,
    required this.premiumSubscriptionsTable,
    required this.mwebXpromoInterstitialCommentsAndroid,
    required this.crowdControlForPost,
    required this.chatGroupRollout,
    required this.resizedStylesImages,
    required this.noreferrerToNoopener,
  });

  static Future<Features> default_() =>
      RustLib.instance.api.redditApiModelUserModelFeaturesDefault();

  @override
  int get hashCode =>
      modmailHarassmentFilter.hashCode ^
      modServiceMuteWrites.hashCode ^
      promotedTrendBlanks.hashCode ^
      showAmpLink.hashCode ^
      isEmailPermissionRequired.hashCode ^
      modAwards.hashCode ^
      expensiveCoinsPackage.hashCode ^
      chatSubreddit.hashCode ^
      awardsOnStreams.hashCode ^
      mwebXpromoModalListingClickDailyDismissibleIos.hashCode ^
      cookieConsentBanner.hashCode ^
      modlogCopyrightRemoval.hashCode ^
      doNotTrack.hashCode ^
      imagesInComments.hashCode ^
      modServiceMuteReads.hashCode ^
      chatUserSettings.hashCode ^
      usePrefAccountDeployment.hashCode ^
      mwebXpromoInterstitialCommentsIos.hashCode ^
      mwebXpromoModalListingClickDailyDismissibleAndroid.hashCode ^
      premiumSubscriptionsTable.hashCode ^
      mwebXpromoInterstitialCommentsAndroid.hashCode ^
      crowdControlForPost.hashCode ^
      chatGroupRollout.hashCode ^
      resizedStylesImages.hashCode ^
      noreferrerToNoopener.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Features &&
          runtimeType == other.runtimeType &&
          modmailHarassmentFilter == other.modmailHarassmentFilter &&
          modServiceMuteWrites == other.modServiceMuteWrites &&
          promotedTrendBlanks == other.promotedTrendBlanks &&
          showAmpLink == other.showAmpLink &&
          isEmailPermissionRequired == other.isEmailPermissionRequired &&
          modAwards == other.modAwards &&
          expensiveCoinsPackage == other.expensiveCoinsPackage &&
          chatSubreddit == other.chatSubreddit &&
          awardsOnStreams == other.awardsOnStreams &&
          mwebXpromoModalListingClickDailyDismissibleIos ==
              other.mwebXpromoModalListingClickDailyDismissibleIos &&
          cookieConsentBanner == other.cookieConsentBanner &&
          modlogCopyrightRemoval == other.modlogCopyrightRemoval &&
          doNotTrack == other.doNotTrack &&
          imagesInComments == other.imagesInComments &&
          modServiceMuteReads == other.modServiceMuteReads &&
          chatUserSettings == other.chatUserSettings &&
          usePrefAccountDeployment == other.usePrefAccountDeployment &&
          mwebXpromoInterstitialCommentsIos ==
              other.mwebXpromoInterstitialCommentsIos &&
          mwebXpromoModalListingClickDailyDismissibleAndroid ==
              other.mwebXpromoModalListingClickDailyDismissibleAndroid &&
          premiumSubscriptionsTable == other.premiumSubscriptionsTable &&
          mwebXpromoInterstitialCommentsAndroid ==
              other.mwebXpromoInterstitialCommentsAndroid &&
          crowdControlForPost == other.crowdControlForPost &&
          chatGroupRollout == other.chatGroupRollout &&
          resizedStylesImages == other.resizedStylesImages &&
          noreferrerToNoopener == other.noreferrerToNoopener;
}

class Preferences {
  final bool prefAutoplay;
  final bool prefVideoAutoplay;
  final bool prefNoProfanity;
  final String prefGeopopular;
  final bool prefShowTrending;
  final bool prefShowPresence;
  final bool prefNightmode;
  final bool prefTopKarmaSubreddits;
  final PlatformInt64 prefClickgadget;
  final bool prefShowTwitter;

  const Preferences({
    required this.prefAutoplay,
    required this.prefVideoAutoplay,
    required this.prefNoProfanity,
    required this.prefGeopopular,
    required this.prefShowTrending,
    required this.prefShowPresence,
    required this.prefNightmode,
    required this.prefTopKarmaSubreddits,
    required this.prefClickgadget,
    required this.prefShowTwitter,
  });

  static Future<Preferences> default_() =>
      RustLib.instance.api.redditApiModelUserModelPreferencesDefault();

  @override
  int get hashCode =>
      prefAutoplay.hashCode ^
      prefVideoAutoplay.hashCode ^
      prefNoProfanity.hashCode ^
      prefGeopopular.hashCode ^
      prefShowTrending.hashCode ^
      prefShowPresence.hashCode ^
      prefNightmode.hashCode ^
      prefTopKarmaSubreddits.hashCode ^
      prefClickgadget.hashCode ^
      prefShowTwitter.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Preferences &&
          runtimeType == other.runtimeType &&
          prefAutoplay == other.prefAutoplay &&
          prefVideoAutoplay == other.prefVideoAutoplay &&
          prefNoProfanity == other.prefNoProfanity &&
          prefGeopopular == other.prefGeopopular &&
          prefShowTrending == other.prefShowTrending &&
          prefShowPresence == other.prefShowPresence &&
          prefNightmode == other.prefNightmode &&
          prefTopKarmaSubreddits == other.prefTopKarmaSubreddits &&
          prefClickgadget == other.prefClickgadget &&
          prefShowTwitter == other.prefShowTwitter;
}

class Snoovatar {
  final bool prefShowSnoovatar;
  final String? snoovatarSize;
  final String snoovatarImg;

  const Snoovatar({
    required this.prefShowSnoovatar,
    this.snoovatarSize,
    required this.snoovatarImg,
  });

  static Future<Snoovatar> default_() =>
      RustLib.instance.api.redditApiModelUserModelSnoovatarDefault();

  @override
  int get hashCode =>
      prefShowSnoovatar.hashCode ^
      snoovatarSize.hashCode ^
      snoovatarImg.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Snoovatar &&
          runtimeType == other.runtimeType &&
          prefShowSnoovatar == other.prefShowSnoovatar &&
          snoovatarSize == other.snoovatarSize &&
          snoovatarImg == other.snoovatarImg;
}

/// Info return by /u/me/about.json
class User {
  final UserInfo info;
  final String? goldExpiration;
  final bool hasGoldSubscription;
  final bool isSponsor;
  final PlatformInt64 numFriends;
  final Features features;
  final bool canEditName;
  final String? newModmailExists;
  final PlatformInt64 coins;
  final bool canCreateSubreddit;
  final double? suspensionExpirationUtc;
  final bool hasStripeSubscription;
  final bool hasAndroidSubscription;
  final bool hasModMail;
  final bool hasMail;
  final bool hasPaypalSubscription;
  final bool hasSubscribedToPremium;
  final bool inRedesignBeta;
  final bool passwordSet;
  final String modhash;
  final bool isSuspended;
  final bool forcePasswordReset;
  final PlatformInt64 inboxCount;
  final PlatformInt64 goldCreddits;
  final bool hasIosSubscription;
  final bool inBeta;
  final bool hasVisitedNewProfile;
  final bool hasExternalAccount;

  const User({
    required this.info,
    this.goldExpiration,
    required this.hasGoldSubscription,
    required this.isSponsor,
    required this.numFriends,
    required this.features,
    required this.canEditName,
    this.newModmailExists,
    required this.coins,
    required this.canCreateSubreddit,
    this.suspensionExpirationUtc,
    required this.hasStripeSubscription,
    required this.hasAndroidSubscription,
    required this.hasModMail,
    required this.hasMail,
    required this.hasPaypalSubscription,
    required this.hasSubscribedToPremium,
    required this.inRedesignBeta,
    required this.passwordSet,
    required this.modhash,
    required this.isSuspended,
    required this.forcePasswordReset,
    required this.inboxCount,
    required this.goldCreddits,
    required this.hasIosSubscription,
    required this.inBeta,
    required this.hasVisitedNewProfile,
    required this.hasExternalAccount,
  });

  static Future<User> default_() =>
      RustLib.instance.api.redditApiModelUserModelUserDefault();

  @override
  int get hashCode =>
      info.hashCode ^
      goldExpiration.hashCode ^
      hasGoldSubscription.hashCode ^
      isSponsor.hashCode ^
      numFriends.hashCode ^
      features.hashCode ^
      canEditName.hashCode ^
      newModmailExists.hashCode ^
      coins.hashCode ^
      canCreateSubreddit.hashCode ^
      suspensionExpirationUtc.hashCode ^
      hasStripeSubscription.hashCode ^
      hasAndroidSubscription.hashCode ^
      hasModMail.hashCode ^
      hasMail.hashCode ^
      hasPaypalSubscription.hashCode ^
      hasSubscribedToPremium.hashCode ^
      inRedesignBeta.hashCode ^
      passwordSet.hashCode ^
      modhash.hashCode ^
      isSuspended.hashCode ^
      forcePasswordReset.hashCode ^
      inboxCount.hashCode ^
      goldCreddits.hashCode ^
      hasIosSubscription.hashCode ^
      inBeta.hashCode ^
      hasVisitedNewProfile.hashCode ^
      hasExternalAccount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is User &&
          runtimeType == other.runtimeType &&
          info == other.info &&
          goldExpiration == other.goldExpiration &&
          hasGoldSubscription == other.hasGoldSubscription &&
          isSponsor == other.isSponsor &&
          numFriends == other.numFriends &&
          features == other.features &&
          canEditName == other.canEditName &&
          newModmailExists == other.newModmailExists &&
          coins == other.coins &&
          canCreateSubreddit == other.canCreateSubreddit &&
          suspensionExpirationUtc == other.suspensionExpirationUtc &&
          hasStripeSubscription == other.hasStripeSubscription &&
          hasAndroidSubscription == other.hasAndroidSubscription &&
          hasModMail == other.hasModMail &&
          hasMail == other.hasMail &&
          hasPaypalSubscription == other.hasPaypalSubscription &&
          hasSubscribedToPremium == other.hasSubscribedToPremium &&
          inRedesignBeta == other.inRedesignBeta &&
          passwordSet == other.passwordSet &&
          modhash == other.modhash &&
          isSuspended == other.isSuspended &&
          forcePasswordReset == other.forcePasswordReset &&
          inboxCount == other.inboxCount &&
          goldCreddits == other.goldCreddits &&
          hasIosSubscription == other.hasIosSubscription &&
          inBeta == other.inBeta &&
          hasVisitedNewProfile == other.hasVisitedNewProfile &&
          hasExternalAccount == other.hasExternalAccount;
}

/// Info returned by /u/someuser/about.json
class UserInfo {
  final String id;
  final String name;
  final UserSubreddit subreddit;
  final double created;
  final bool over18;
  final double createdUtc;

  /// Missing when querying api/v1/me
  final bool isBlocked;
  final bool isEmployee;

  /// Missing when querying api/v1/me
  final bool isFriend;
  final PlatformInt64 awardeeKarma;
  final bool isGold;
  final bool isMod;
  final bool verified;
  final PlatformInt64 awarderKarma;
  final bool hasVerifiedEmail;
  final bool hasSubscribed;
  final String iconImg;
  final bool hideFromRobots;
  final PlatformInt64 linkKarma;
  final PlatformInt64 totalKarma;
  final PlatformInt64 commentKarma;
  final bool acceptFollowers;
  final bool acceptChats;
  final bool acceptPms;

  const UserInfo({
    required this.id,
    required this.name,
    required this.subreddit,
    required this.created,
    required this.over18,
    required this.createdUtc,
    required this.isBlocked,
    required this.isEmployee,
    required this.isFriend,
    required this.awardeeKarma,
    required this.isGold,
    required this.isMod,
    required this.verified,
    required this.awarderKarma,
    required this.hasVerifiedEmail,
    required this.hasSubscribed,
    required this.iconImg,
    required this.hideFromRobots,
    required this.linkKarma,
    required this.totalKarma,
    required this.commentKarma,
    required this.acceptFollowers,
    required this.acceptChats,
    required this.acceptPms,
  });

  static Future<UserInfo> default_() =>
      RustLib.instance.api.redditApiModelUserModelUserInfoDefault();

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      subreddit.hashCode ^
      created.hashCode ^
      over18.hashCode ^
      createdUtc.hashCode ^
      isBlocked.hashCode ^
      isEmployee.hashCode ^
      isFriend.hashCode ^
      awardeeKarma.hashCode ^
      isGold.hashCode ^
      isMod.hashCode ^
      verified.hashCode ^
      awarderKarma.hashCode ^
      hasVerifiedEmail.hashCode ^
      hasSubscribed.hashCode ^
      iconImg.hashCode ^
      hideFromRobots.hashCode ^
      linkKarma.hashCode ^
      totalKarma.hashCode ^
      commentKarma.hashCode ^
      acceptFollowers.hashCode ^
      acceptChats.hashCode ^
      acceptPms.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          subreddit == other.subreddit &&
          created == other.created &&
          over18 == other.over18 &&
          createdUtc == other.createdUtc &&
          isBlocked == other.isBlocked &&
          isEmployee == other.isEmployee &&
          isFriend == other.isFriend &&
          awardeeKarma == other.awardeeKarma &&
          isGold == other.isGold &&
          isMod == other.isMod &&
          verified == other.verified &&
          awarderKarma == other.awarderKarma &&
          hasVerifiedEmail == other.hasVerifiedEmail &&
          hasSubscribed == other.hasSubscribed &&
          iconImg == other.iconImg &&
          hideFromRobots == other.hideFromRobots &&
          linkKarma == other.linkKarma &&
          totalKarma == other.totalKarma &&
          commentKarma == other.commentKarma &&
          acceptFollowers == other.acceptFollowers &&
          acceptChats == other.acceptChats &&
          acceptPms == other.acceptPms;
}

@freezed
sealed class UserStreamSort with _$UserStreamSort {
  const UserStreamSort._();

  const factory UserStreamSort.hot() = UserStreamSort_Hot;
  const factory UserStreamSort.top(
    Timeframe field0,
  ) = UserStreamSort_Top;
  const factory UserStreamSort.new_() = UserStreamSort_New;
  const factory UserStreamSort.controversial(
    Timeframe field0,
  ) = UserStreamSort_Controversial;
}

class UserSubreddit {
  final bool defaultSet;
  final bool userIsContributor;
  final String bannerImg;
  final List<String> allowedMediaInComments;
  final bool userIsBanned;
  final bool freeFormReports;
  final String? communityIcon;
  final bool showMedia;
  final String iconColor;
  final bool? userIsMuted;
  final String displayName;
  final String? headerImg;
  final String title;
  final PlatformInt64 coins;
  final List<String> previousNames;
  final bool over18;
  final Int64List iconSize;
  final String primaryColor;
  final String iconImg;
  final String description;
  final String submitLinkLabel;
  final String? headerSize;
  final bool restrictPosting;
  final bool restrictCommenting;
  final PlatformInt64 subscribers;
  final String submitTextLabel;
  final bool isDefaultIcon;
  final String linkFlairPosition;
  final String displayNamePrefixed;
  final String keyColor;
  final bool isDefaultBanner;
  final String url;
  final bool quarantine;
  final String? bannerSize;
  final bool userIsModerator;
  final String publicDescription;
  final bool linkFlairEnabled;
  final bool disableContributorRequests;
  final String subredditType;
  final bool userIsSubscriber;

  const UserSubreddit({
    required this.defaultSet,
    required this.userIsContributor,
    required this.bannerImg,
    required this.allowedMediaInComments,
    required this.userIsBanned,
    required this.freeFormReports,
    this.communityIcon,
    required this.showMedia,
    required this.iconColor,
    this.userIsMuted,
    required this.displayName,
    this.headerImg,
    required this.title,
    required this.coins,
    required this.previousNames,
    required this.over18,
    required this.iconSize,
    required this.primaryColor,
    required this.iconImg,
    required this.description,
    required this.submitLinkLabel,
    this.headerSize,
    required this.restrictPosting,
    required this.restrictCommenting,
    required this.subscribers,
    required this.submitTextLabel,
    required this.isDefaultIcon,
    required this.linkFlairPosition,
    required this.displayNamePrefixed,
    required this.keyColor,
    required this.isDefaultBanner,
    required this.url,
    required this.quarantine,
    this.bannerSize,
    required this.userIsModerator,
    required this.publicDescription,
    required this.linkFlairEnabled,
    required this.disableContributorRequests,
    required this.subredditType,
    required this.userIsSubscriber,
  });

  static Future<UserSubreddit> default_() =>
      RustLib.instance.api.redditApiModelUserModelUserSubredditDefault();

  @override
  int get hashCode =>
      defaultSet.hashCode ^
      userIsContributor.hashCode ^
      bannerImg.hashCode ^
      allowedMediaInComments.hashCode ^
      userIsBanned.hashCode ^
      freeFormReports.hashCode ^
      communityIcon.hashCode ^
      showMedia.hashCode ^
      iconColor.hashCode ^
      userIsMuted.hashCode ^
      displayName.hashCode ^
      headerImg.hashCode ^
      title.hashCode ^
      coins.hashCode ^
      previousNames.hashCode ^
      over18.hashCode ^
      iconSize.hashCode ^
      primaryColor.hashCode ^
      iconImg.hashCode ^
      description.hashCode ^
      submitLinkLabel.hashCode ^
      headerSize.hashCode ^
      restrictPosting.hashCode ^
      restrictCommenting.hashCode ^
      subscribers.hashCode ^
      submitTextLabel.hashCode ^
      isDefaultIcon.hashCode ^
      linkFlairPosition.hashCode ^
      displayNamePrefixed.hashCode ^
      keyColor.hashCode ^
      isDefaultBanner.hashCode ^
      url.hashCode ^
      quarantine.hashCode ^
      bannerSize.hashCode ^
      userIsModerator.hashCode ^
      publicDescription.hashCode ^
      linkFlairEnabled.hashCode ^
      disableContributorRequests.hashCode ^
      subredditType.hashCode ^
      userIsSubscriber.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UserSubreddit &&
          runtimeType == other.runtimeType &&
          defaultSet == other.defaultSet &&
          userIsContributor == other.userIsContributor &&
          bannerImg == other.bannerImg &&
          allowedMediaInComments == other.allowedMediaInComments &&
          userIsBanned == other.userIsBanned &&
          freeFormReports == other.freeFormReports &&
          communityIcon == other.communityIcon &&
          showMedia == other.showMedia &&
          iconColor == other.iconColor &&
          userIsMuted == other.userIsMuted &&
          displayName == other.displayName &&
          headerImg == other.headerImg &&
          title == other.title &&
          coins == other.coins &&
          previousNames == other.previousNames &&
          over18 == other.over18 &&
          iconSize == other.iconSize &&
          primaryColor == other.primaryColor &&
          iconImg == other.iconImg &&
          description == other.description &&
          submitLinkLabel == other.submitLinkLabel &&
          headerSize == other.headerSize &&
          restrictPosting == other.restrictPosting &&
          restrictCommenting == other.restrictCommenting &&
          subscribers == other.subscribers &&
          submitTextLabel == other.submitTextLabel &&
          isDefaultIcon == other.isDefaultIcon &&
          linkFlairPosition == other.linkFlairPosition &&
          displayNamePrefixed == other.displayNamePrefixed &&
          keyColor == other.keyColor &&
          isDefaultBanner == other.isDefaultBanner &&
          url == other.url &&
          quarantine == other.quarantine &&
          bannerSize == other.bannerSize &&
          userIsModerator == other.userIsModerator &&
          publicDescription == other.publicDescription &&
          linkFlairEnabled == other.linkFlairEnabled &&
          disableContributorRequests == other.disableContributorRequests &&
          subredditType == other.subredditType &&
          userIsSubscriber == other.userIsSubscriber;
}
