// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Sort {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() best,
    required TResult Function() hot,
    required TResult Function(Timeframe field0) new_,
    required TResult Function(Timeframe field0) top,
    required TResult Function() rising,
    required TResult Function(Timeframe field0) controversial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? best,
    TResult? Function()? hot,
    TResult? Function(Timeframe field0)? new_,
    TResult? Function(Timeframe field0)? top,
    TResult? Function()? rising,
    TResult? Function(Timeframe field0)? controversial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? best,
    TResult Function()? hot,
    TResult Function(Timeframe field0)? new_,
    TResult Function(Timeframe field0)? top,
    TResult Function()? rising,
    TResult Function(Timeframe field0)? controversial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Sort_Best value) best,
    required TResult Function(Sort_Hot value) hot,
    required TResult Function(Sort_New value) new_,
    required TResult Function(Sort_Top value) top,
    required TResult Function(Sort_Rising value) rising,
    required TResult Function(Sort_Controversial value) controversial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Sort_Best value)? best,
    TResult? Function(Sort_Hot value)? hot,
    TResult? Function(Sort_New value)? new_,
    TResult? Function(Sort_Top value)? top,
    TResult? Function(Sort_Rising value)? rising,
    TResult? Function(Sort_Controversial value)? controversial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Sort_Best value)? best,
    TResult Function(Sort_Hot value)? hot,
    TResult Function(Sort_New value)? new_,
    TResult Function(Sort_Top value)? top,
    TResult Function(Sort_Rising value)? rising,
    TResult Function(Sort_Controversial value)? controversial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SortCopyWith<$Res> {
  factory $SortCopyWith(Sort value, $Res Function(Sort) then) =
      _$SortCopyWithImpl<$Res, Sort>;
}

/// @nodoc
class _$SortCopyWithImpl<$Res, $Val extends Sort>
    implements $SortCopyWith<$Res> {
  _$SortCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$Sort_BestImplCopyWith<$Res> {
  factory _$$Sort_BestImplCopyWith(
          _$Sort_BestImpl value, $Res Function(_$Sort_BestImpl) then) =
      __$$Sort_BestImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Sort_BestImplCopyWithImpl<$Res>
    extends _$SortCopyWithImpl<$Res, _$Sort_BestImpl>
    implements _$$Sort_BestImplCopyWith<$Res> {
  __$$Sort_BestImplCopyWithImpl(
      _$Sort_BestImpl _value, $Res Function(_$Sort_BestImpl) _then)
      : super(_value, _then);

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$Sort_BestImpl extends Sort_Best {
  const _$Sort_BestImpl() : super._();

  @override
  String toString() {
    return 'Sort.best()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Sort_BestImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() best,
    required TResult Function() hot,
    required TResult Function(Timeframe field0) new_,
    required TResult Function(Timeframe field0) top,
    required TResult Function() rising,
    required TResult Function(Timeframe field0) controversial,
  }) {
    return best();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? best,
    TResult? Function()? hot,
    TResult? Function(Timeframe field0)? new_,
    TResult? Function(Timeframe field0)? top,
    TResult? Function()? rising,
    TResult? Function(Timeframe field0)? controversial,
  }) {
    return best?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? best,
    TResult Function()? hot,
    TResult Function(Timeframe field0)? new_,
    TResult Function(Timeframe field0)? top,
    TResult Function()? rising,
    TResult Function(Timeframe field0)? controversial,
    required TResult orElse(),
  }) {
    if (best != null) {
      return best();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Sort_Best value) best,
    required TResult Function(Sort_Hot value) hot,
    required TResult Function(Sort_New value) new_,
    required TResult Function(Sort_Top value) top,
    required TResult Function(Sort_Rising value) rising,
    required TResult Function(Sort_Controversial value) controversial,
  }) {
    return best(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Sort_Best value)? best,
    TResult? Function(Sort_Hot value)? hot,
    TResult? Function(Sort_New value)? new_,
    TResult? Function(Sort_Top value)? top,
    TResult? Function(Sort_Rising value)? rising,
    TResult? Function(Sort_Controversial value)? controversial,
  }) {
    return best?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Sort_Best value)? best,
    TResult Function(Sort_Hot value)? hot,
    TResult Function(Sort_New value)? new_,
    TResult Function(Sort_Top value)? top,
    TResult Function(Sort_Rising value)? rising,
    TResult Function(Sort_Controversial value)? controversial,
    required TResult orElse(),
  }) {
    if (best != null) {
      return best(this);
    }
    return orElse();
  }
}

abstract class Sort_Best extends Sort {
  const factory Sort_Best() = _$Sort_BestImpl;
  const Sort_Best._() : super._();
}

/// @nodoc
abstract class _$$Sort_HotImplCopyWith<$Res> {
  factory _$$Sort_HotImplCopyWith(
          _$Sort_HotImpl value, $Res Function(_$Sort_HotImpl) then) =
      __$$Sort_HotImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Sort_HotImplCopyWithImpl<$Res>
    extends _$SortCopyWithImpl<$Res, _$Sort_HotImpl>
    implements _$$Sort_HotImplCopyWith<$Res> {
  __$$Sort_HotImplCopyWithImpl(
      _$Sort_HotImpl _value, $Res Function(_$Sort_HotImpl) _then)
      : super(_value, _then);

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$Sort_HotImpl extends Sort_Hot {
  const _$Sort_HotImpl() : super._();

  @override
  String toString() {
    return 'Sort.hot()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Sort_HotImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() best,
    required TResult Function() hot,
    required TResult Function(Timeframe field0) new_,
    required TResult Function(Timeframe field0) top,
    required TResult Function() rising,
    required TResult Function(Timeframe field0) controversial,
  }) {
    return hot();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? best,
    TResult? Function()? hot,
    TResult? Function(Timeframe field0)? new_,
    TResult? Function(Timeframe field0)? top,
    TResult? Function()? rising,
    TResult? Function(Timeframe field0)? controversial,
  }) {
    return hot?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? best,
    TResult Function()? hot,
    TResult Function(Timeframe field0)? new_,
    TResult Function(Timeframe field0)? top,
    TResult Function()? rising,
    TResult Function(Timeframe field0)? controversial,
    required TResult orElse(),
  }) {
    if (hot != null) {
      return hot();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Sort_Best value) best,
    required TResult Function(Sort_Hot value) hot,
    required TResult Function(Sort_New value) new_,
    required TResult Function(Sort_Top value) top,
    required TResult Function(Sort_Rising value) rising,
    required TResult Function(Sort_Controversial value) controversial,
  }) {
    return hot(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Sort_Best value)? best,
    TResult? Function(Sort_Hot value)? hot,
    TResult? Function(Sort_New value)? new_,
    TResult? Function(Sort_Top value)? top,
    TResult? Function(Sort_Rising value)? rising,
    TResult? Function(Sort_Controversial value)? controversial,
  }) {
    return hot?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Sort_Best value)? best,
    TResult Function(Sort_Hot value)? hot,
    TResult Function(Sort_New value)? new_,
    TResult Function(Sort_Top value)? top,
    TResult Function(Sort_Rising value)? rising,
    TResult Function(Sort_Controversial value)? controversial,
    required TResult orElse(),
  }) {
    if (hot != null) {
      return hot(this);
    }
    return orElse();
  }
}

abstract class Sort_Hot extends Sort {
  const factory Sort_Hot() = _$Sort_HotImpl;
  const Sort_Hot._() : super._();
}

/// @nodoc
abstract class _$$Sort_NewImplCopyWith<$Res> {
  factory _$$Sort_NewImplCopyWith(
          _$Sort_NewImpl value, $Res Function(_$Sort_NewImpl) then) =
      __$$Sort_NewImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Timeframe field0});
}

/// @nodoc
class __$$Sort_NewImplCopyWithImpl<$Res>
    extends _$SortCopyWithImpl<$Res, _$Sort_NewImpl>
    implements _$$Sort_NewImplCopyWith<$Res> {
  __$$Sort_NewImplCopyWithImpl(
      _$Sort_NewImpl _value, $Res Function(_$Sort_NewImpl) _then)
      : super(_value, _then);

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Sort_NewImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Timeframe,
    ));
  }
}

/// @nodoc

class _$Sort_NewImpl extends Sort_New {
  const _$Sort_NewImpl(this.field0) : super._();

  @override
  final Timeframe field0;

  @override
  String toString() {
    return 'Sort.new_(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Sort_NewImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Sort_NewImplCopyWith<_$Sort_NewImpl> get copyWith =>
      __$$Sort_NewImplCopyWithImpl<_$Sort_NewImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() best,
    required TResult Function() hot,
    required TResult Function(Timeframe field0) new_,
    required TResult Function(Timeframe field0) top,
    required TResult Function() rising,
    required TResult Function(Timeframe field0) controversial,
  }) {
    return new_(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? best,
    TResult? Function()? hot,
    TResult? Function(Timeframe field0)? new_,
    TResult? Function(Timeframe field0)? top,
    TResult? Function()? rising,
    TResult? Function(Timeframe field0)? controversial,
  }) {
    return new_?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? best,
    TResult Function()? hot,
    TResult Function(Timeframe field0)? new_,
    TResult Function(Timeframe field0)? top,
    TResult Function()? rising,
    TResult Function(Timeframe field0)? controversial,
    required TResult orElse(),
  }) {
    if (new_ != null) {
      return new_(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Sort_Best value) best,
    required TResult Function(Sort_Hot value) hot,
    required TResult Function(Sort_New value) new_,
    required TResult Function(Sort_Top value) top,
    required TResult Function(Sort_Rising value) rising,
    required TResult Function(Sort_Controversial value) controversial,
  }) {
    return new_(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Sort_Best value)? best,
    TResult? Function(Sort_Hot value)? hot,
    TResult? Function(Sort_New value)? new_,
    TResult? Function(Sort_Top value)? top,
    TResult? Function(Sort_Rising value)? rising,
    TResult? Function(Sort_Controversial value)? controversial,
  }) {
    return new_?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Sort_Best value)? best,
    TResult Function(Sort_Hot value)? hot,
    TResult Function(Sort_New value)? new_,
    TResult Function(Sort_Top value)? top,
    TResult Function(Sort_Rising value)? rising,
    TResult Function(Sort_Controversial value)? controversial,
    required TResult orElse(),
  }) {
    if (new_ != null) {
      return new_(this);
    }
    return orElse();
  }
}

abstract class Sort_New extends Sort {
  const factory Sort_New(final Timeframe field0) = _$Sort_NewImpl;
  const Sort_New._() : super._();

  Timeframe get field0;

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Sort_NewImplCopyWith<_$Sort_NewImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Sort_TopImplCopyWith<$Res> {
  factory _$$Sort_TopImplCopyWith(
          _$Sort_TopImpl value, $Res Function(_$Sort_TopImpl) then) =
      __$$Sort_TopImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Timeframe field0});
}

/// @nodoc
class __$$Sort_TopImplCopyWithImpl<$Res>
    extends _$SortCopyWithImpl<$Res, _$Sort_TopImpl>
    implements _$$Sort_TopImplCopyWith<$Res> {
  __$$Sort_TopImplCopyWithImpl(
      _$Sort_TopImpl _value, $Res Function(_$Sort_TopImpl) _then)
      : super(_value, _then);

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Sort_TopImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Timeframe,
    ));
  }
}

/// @nodoc

class _$Sort_TopImpl extends Sort_Top {
  const _$Sort_TopImpl(this.field0) : super._();

  @override
  final Timeframe field0;

  @override
  String toString() {
    return 'Sort.top(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Sort_TopImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Sort_TopImplCopyWith<_$Sort_TopImpl> get copyWith =>
      __$$Sort_TopImplCopyWithImpl<_$Sort_TopImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() best,
    required TResult Function() hot,
    required TResult Function(Timeframe field0) new_,
    required TResult Function(Timeframe field0) top,
    required TResult Function() rising,
    required TResult Function(Timeframe field0) controversial,
  }) {
    return top(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? best,
    TResult? Function()? hot,
    TResult? Function(Timeframe field0)? new_,
    TResult? Function(Timeframe field0)? top,
    TResult? Function()? rising,
    TResult? Function(Timeframe field0)? controversial,
  }) {
    return top?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? best,
    TResult Function()? hot,
    TResult Function(Timeframe field0)? new_,
    TResult Function(Timeframe field0)? top,
    TResult Function()? rising,
    TResult Function(Timeframe field0)? controversial,
    required TResult orElse(),
  }) {
    if (top != null) {
      return top(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Sort_Best value) best,
    required TResult Function(Sort_Hot value) hot,
    required TResult Function(Sort_New value) new_,
    required TResult Function(Sort_Top value) top,
    required TResult Function(Sort_Rising value) rising,
    required TResult Function(Sort_Controversial value) controversial,
  }) {
    return top(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Sort_Best value)? best,
    TResult? Function(Sort_Hot value)? hot,
    TResult? Function(Sort_New value)? new_,
    TResult? Function(Sort_Top value)? top,
    TResult? Function(Sort_Rising value)? rising,
    TResult? Function(Sort_Controversial value)? controversial,
  }) {
    return top?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Sort_Best value)? best,
    TResult Function(Sort_Hot value)? hot,
    TResult Function(Sort_New value)? new_,
    TResult Function(Sort_Top value)? top,
    TResult Function(Sort_Rising value)? rising,
    TResult Function(Sort_Controversial value)? controversial,
    required TResult orElse(),
  }) {
    if (top != null) {
      return top(this);
    }
    return orElse();
  }
}

abstract class Sort_Top extends Sort {
  const factory Sort_Top(final Timeframe field0) = _$Sort_TopImpl;
  const Sort_Top._() : super._();

  Timeframe get field0;

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Sort_TopImplCopyWith<_$Sort_TopImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Sort_RisingImplCopyWith<$Res> {
  factory _$$Sort_RisingImplCopyWith(
          _$Sort_RisingImpl value, $Res Function(_$Sort_RisingImpl) then) =
      __$$Sort_RisingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Sort_RisingImplCopyWithImpl<$Res>
    extends _$SortCopyWithImpl<$Res, _$Sort_RisingImpl>
    implements _$$Sort_RisingImplCopyWith<$Res> {
  __$$Sort_RisingImplCopyWithImpl(
      _$Sort_RisingImpl _value, $Res Function(_$Sort_RisingImpl) _then)
      : super(_value, _then);

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$Sort_RisingImpl extends Sort_Rising {
  const _$Sort_RisingImpl() : super._();

  @override
  String toString() {
    return 'Sort.rising()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Sort_RisingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() best,
    required TResult Function() hot,
    required TResult Function(Timeframe field0) new_,
    required TResult Function(Timeframe field0) top,
    required TResult Function() rising,
    required TResult Function(Timeframe field0) controversial,
  }) {
    return rising();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? best,
    TResult? Function()? hot,
    TResult? Function(Timeframe field0)? new_,
    TResult? Function(Timeframe field0)? top,
    TResult? Function()? rising,
    TResult? Function(Timeframe field0)? controversial,
  }) {
    return rising?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? best,
    TResult Function()? hot,
    TResult Function(Timeframe field0)? new_,
    TResult Function(Timeframe field0)? top,
    TResult Function()? rising,
    TResult Function(Timeframe field0)? controversial,
    required TResult orElse(),
  }) {
    if (rising != null) {
      return rising();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Sort_Best value) best,
    required TResult Function(Sort_Hot value) hot,
    required TResult Function(Sort_New value) new_,
    required TResult Function(Sort_Top value) top,
    required TResult Function(Sort_Rising value) rising,
    required TResult Function(Sort_Controversial value) controversial,
  }) {
    return rising(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Sort_Best value)? best,
    TResult? Function(Sort_Hot value)? hot,
    TResult? Function(Sort_New value)? new_,
    TResult? Function(Sort_Top value)? top,
    TResult? Function(Sort_Rising value)? rising,
    TResult? Function(Sort_Controversial value)? controversial,
  }) {
    return rising?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Sort_Best value)? best,
    TResult Function(Sort_Hot value)? hot,
    TResult Function(Sort_New value)? new_,
    TResult Function(Sort_Top value)? top,
    TResult Function(Sort_Rising value)? rising,
    TResult Function(Sort_Controversial value)? controversial,
    required TResult orElse(),
  }) {
    if (rising != null) {
      return rising(this);
    }
    return orElse();
  }
}

abstract class Sort_Rising extends Sort {
  const factory Sort_Rising() = _$Sort_RisingImpl;
  const Sort_Rising._() : super._();
}

/// @nodoc
abstract class _$$Sort_ControversialImplCopyWith<$Res> {
  factory _$$Sort_ControversialImplCopyWith(_$Sort_ControversialImpl value,
          $Res Function(_$Sort_ControversialImpl) then) =
      __$$Sort_ControversialImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Timeframe field0});
}

/// @nodoc
class __$$Sort_ControversialImplCopyWithImpl<$Res>
    extends _$SortCopyWithImpl<$Res, _$Sort_ControversialImpl>
    implements _$$Sort_ControversialImplCopyWith<$Res> {
  __$$Sort_ControversialImplCopyWithImpl(_$Sort_ControversialImpl _value,
      $Res Function(_$Sort_ControversialImpl) _then)
      : super(_value, _then);

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Sort_ControversialImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Timeframe,
    ));
  }
}

/// @nodoc

class _$Sort_ControversialImpl extends Sort_Controversial {
  const _$Sort_ControversialImpl(this.field0) : super._();

  @override
  final Timeframe field0;

  @override
  String toString() {
    return 'Sort.controversial(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Sort_ControversialImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Sort_ControversialImplCopyWith<_$Sort_ControversialImpl> get copyWith =>
      __$$Sort_ControversialImplCopyWithImpl<_$Sort_ControversialImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() best,
    required TResult Function() hot,
    required TResult Function(Timeframe field0) new_,
    required TResult Function(Timeframe field0) top,
    required TResult Function() rising,
    required TResult Function(Timeframe field0) controversial,
  }) {
    return controversial(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? best,
    TResult? Function()? hot,
    TResult? Function(Timeframe field0)? new_,
    TResult? Function(Timeframe field0)? top,
    TResult? Function()? rising,
    TResult? Function(Timeframe field0)? controversial,
  }) {
    return controversial?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? best,
    TResult Function()? hot,
    TResult Function(Timeframe field0)? new_,
    TResult Function(Timeframe field0)? top,
    TResult Function()? rising,
    TResult Function(Timeframe field0)? controversial,
    required TResult orElse(),
  }) {
    if (controversial != null) {
      return controversial(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Sort_Best value) best,
    required TResult Function(Sort_Hot value) hot,
    required TResult Function(Sort_New value) new_,
    required TResult Function(Sort_Top value) top,
    required TResult Function(Sort_Rising value) rising,
    required TResult Function(Sort_Controversial value) controversial,
  }) {
    return controversial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Sort_Best value)? best,
    TResult? Function(Sort_Hot value)? hot,
    TResult? Function(Sort_New value)? new_,
    TResult? Function(Sort_Top value)? top,
    TResult? Function(Sort_Rising value)? rising,
    TResult? Function(Sort_Controversial value)? controversial,
  }) {
    return controversial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Sort_Best value)? best,
    TResult Function(Sort_Hot value)? hot,
    TResult Function(Sort_New value)? new_,
    TResult Function(Sort_Top value)? top,
    TResult Function(Sort_Rising value)? rising,
    TResult Function(Sort_Controversial value)? controversial,
    required TResult orElse(),
  }) {
    if (controversial != null) {
      return controversial(this);
    }
    return orElse();
  }
}

abstract class Sort_Controversial extends Sort {
  const factory Sort_Controversial(final Timeframe field0) =
      _$Sort_ControversialImpl;
  const Sort_Controversial._() : super._();

  Timeframe get field0;

  /// Create a copy of Sort
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Sort_ControversialImplCopyWith<_$Sort_ControversialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Thing {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Listing field0) listing,
    required TResult Function() comment,
    required TResult Function(User field0) user,
    required TResult Function(Post field0) post,
    required TResult Function() message,
    required TResult Function(Subreddit field0) subreddit,
    required TResult Function() award,
    required TResult Function(Multi field0) multi,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Listing field0)? listing,
    TResult? Function()? comment,
    TResult? Function(User field0)? user,
    TResult? Function(Post field0)? post,
    TResult? Function()? message,
    TResult? Function(Subreddit field0)? subreddit,
    TResult? Function()? award,
    TResult? Function(Multi field0)? multi,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Listing field0)? listing,
    TResult Function()? comment,
    TResult Function(User field0)? user,
    TResult Function(Post field0)? post,
    TResult Function()? message,
    TResult Function(Subreddit field0)? subreddit,
    TResult Function()? award,
    TResult Function(Multi field0)? multi,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Thing_Listing value) listing,
    required TResult Function(Thing_Comment value) comment,
    required TResult Function(Thing_User value) user,
    required TResult Function(Thing_Post value) post,
    required TResult Function(Thing_Message value) message,
    required TResult Function(Thing_Subreddit value) subreddit,
    required TResult Function(Thing_Award value) award,
    required TResult Function(Thing_Multi value) multi,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Thing_Listing value)? listing,
    TResult? Function(Thing_Comment value)? comment,
    TResult? Function(Thing_User value)? user,
    TResult? Function(Thing_Post value)? post,
    TResult? Function(Thing_Message value)? message,
    TResult? Function(Thing_Subreddit value)? subreddit,
    TResult? Function(Thing_Award value)? award,
    TResult? Function(Thing_Multi value)? multi,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Thing_Listing value)? listing,
    TResult Function(Thing_Comment value)? comment,
    TResult Function(Thing_User value)? user,
    TResult Function(Thing_Post value)? post,
    TResult Function(Thing_Message value)? message,
    TResult Function(Thing_Subreddit value)? subreddit,
    TResult Function(Thing_Award value)? award,
    TResult Function(Thing_Multi value)? multi,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ThingCopyWith<$Res> {
  factory $ThingCopyWith(Thing value, $Res Function(Thing) then) =
      _$ThingCopyWithImpl<$Res, Thing>;
}

/// @nodoc
class _$ThingCopyWithImpl<$Res, $Val extends Thing>
    implements $ThingCopyWith<$Res> {
  _$ThingCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$Thing_ListingImplCopyWith<$Res> {
  factory _$$Thing_ListingImplCopyWith(
          _$Thing_ListingImpl value, $Res Function(_$Thing_ListingImpl) then) =
      __$$Thing_ListingImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Listing field0});
}

/// @nodoc
class __$$Thing_ListingImplCopyWithImpl<$Res>
    extends _$ThingCopyWithImpl<$Res, _$Thing_ListingImpl>
    implements _$$Thing_ListingImplCopyWith<$Res> {
  __$$Thing_ListingImplCopyWithImpl(
      _$Thing_ListingImpl _value, $Res Function(_$Thing_ListingImpl) _then)
      : super(_value, _then);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Thing_ListingImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Listing,
    ));
  }
}

/// @nodoc

class _$Thing_ListingImpl extends Thing_Listing {
  const _$Thing_ListingImpl(this.field0) : super._();

  @override
  final Listing field0;

  @override
  String toString() {
    return 'Thing.listing(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Thing_ListingImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Thing_ListingImplCopyWith<_$Thing_ListingImpl> get copyWith =>
      __$$Thing_ListingImplCopyWithImpl<_$Thing_ListingImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Listing field0) listing,
    required TResult Function() comment,
    required TResult Function(User field0) user,
    required TResult Function(Post field0) post,
    required TResult Function() message,
    required TResult Function(Subreddit field0) subreddit,
    required TResult Function() award,
    required TResult Function(Multi field0) multi,
  }) {
    return listing(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Listing field0)? listing,
    TResult? Function()? comment,
    TResult? Function(User field0)? user,
    TResult? Function(Post field0)? post,
    TResult? Function()? message,
    TResult? Function(Subreddit field0)? subreddit,
    TResult? Function()? award,
    TResult? Function(Multi field0)? multi,
  }) {
    return listing?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Listing field0)? listing,
    TResult Function()? comment,
    TResult Function(User field0)? user,
    TResult Function(Post field0)? post,
    TResult Function()? message,
    TResult Function(Subreddit field0)? subreddit,
    TResult Function()? award,
    TResult Function(Multi field0)? multi,
    required TResult orElse(),
  }) {
    if (listing != null) {
      return listing(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Thing_Listing value) listing,
    required TResult Function(Thing_Comment value) comment,
    required TResult Function(Thing_User value) user,
    required TResult Function(Thing_Post value) post,
    required TResult Function(Thing_Message value) message,
    required TResult Function(Thing_Subreddit value) subreddit,
    required TResult Function(Thing_Award value) award,
    required TResult Function(Thing_Multi value) multi,
  }) {
    return listing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Thing_Listing value)? listing,
    TResult? Function(Thing_Comment value)? comment,
    TResult? Function(Thing_User value)? user,
    TResult? Function(Thing_Post value)? post,
    TResult? Function(Thing_Message value)? message,
    TResult? Function(Thing_Subreddit value)? subreddit,
    TResult? Function(Thing_Award value)? award,
    TResult? Function(Thing_Multi value)? multi,
  }) {
    return listing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Thing_Listing value)? listing,
    TResult Function(Thing_Comment value)? comment,
    TResult Function(Thing_User value)? user,
    TResult Function(Thing_Post value)? post,
    TResult Function(Thing_Message value)? message,
    TResult Function(Thing_Subreddit value)? subreddit,
    TResult Function(Thing_Award value)? award,
    TResult Function(Thing_Multi value)? multi,
    required TResult orElse(),
  }) {
    if (listing != null) {
      return listing(this);
    }
    return orElse();
  }
}

abstract class Thing_Listing extends Thing {
  const factory Thing_Listing(final Listing field0) = _$Thing_ListingImpl;
  const Thing_Listing._() : super._();

  Listing get field0;

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Thing_ListingImplCopyWith<_$Thing_ListingImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Thing_CommentImplCopyWith<$Res> {
  factory _$$Thing_CommentImplCopyWith(
          _$Thing_CommentImpl value, $Res Function(_$Thing_CommentImpl) then) =
      __$$Thing_CommentImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Thing_CommentImplCopyWithImpl<$Res>
    extends _$ThingCopyWithImpl<$Res, _$Thing_CommentImpl>
    implements _$$Thing_CommentImplCopyWith<$Res> {
  __$$Thing_CommentImplCopyWithImpl(
      _$Thing_CommentImpl _value, $Res Function(_$Thing_CommentImpl) _then)
      : super(_value, _then);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$Thing_CommentImpl extends Thing_Comment {
  const _$Thing_CommentImpl() : super._();

  @override
  String toString() {
    return 'Thing.comment()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Thing_CommentImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Listing field0) listing,
    required TResult Function() comment,
    required TResult Function(User field0) user,
    required TResult Function(Post field0) post,
    required TResult Function() message,
    required TResult Function(Subreddit field0) subreddit,
    required TResult Function() award,
    required TResult Function(Multi field0) multi,
  }) {
    return comment();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Listing field0)? listing,
    TResult? Function()? comment,
    TResult? Function(User field0)? user,
    TResult? Function(Post field0)? post,
    TResult? Function()? message,
    TResult? Function(Subreddit field0)? subreddit,
    TResult? Function()? award,
    TResult? Function(Multi field0)? multi,
  }) {
    return comment?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Listing field0)? listing,
    TResult Function()? comment,
    TResult Function(User field0)? user,
    TResult Function(Post field0)? post,
    TResult Function()? message,
    TResult Function(Subreddit field0)? subreddit,
    TResult Function()? award,
    TResult Function(Multi field0)? multi,
    required TResult orElse(),
  }) {
    if (comment != null) {
      return comment();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Thing_Listing value) listing,
    required TResult Function(Thing_Comment value) comment,
    required TResult Function(Thing_User value) user,
    required TResult Function(Thing_Post value) post,
    required TResult Function(Thing_Message value) message,
    required TResult Function(Thing_Subreddit value) subreddit,
    required TResult Function(Thing_Award value) award,
    required TResult Function(Thing_Multi value) multi,
  }) {
    return comment(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Thing_Listing value)? listing,
    TResult? Function(Thing_Comment value)? comment,
    TResult? Function(Thing_User value)? user,
    TResult? Function(Thing_Post value)? post,
    TResult? Function(Thing_Message value)? message,
    TResult? Function(Thing_Subreddit value)? subreddit,
    TResult? Function(Thing_Award value)? award,
    TResult? Function(Thing_Multi value)? multi,
  }) {
    return comment?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Thing_Listing value)? listing,
    TResult Function(Thing_Comment value)? comment,
    TResult Function(Thing_User value)? user,
    TResult Function(Thing_Post value)? post,
    TResult Function(Thing_Message value)? message,
    TResult Function(Thing_Subreddit value)? subreddit,
    TResult Function(Thing_Award value)? award,
    TResult Function(Thing_Multi value)? multi,
    required TResult orElse(),
  }) {
    if (comment != null) {
      return comment(this);
    }
    return orElse();
  }
}

abstract class Thing_Comment extends Thing {
  const factory Thing_Comment() = _$Thing_CommentImpl;
  const Thing_Comment._() : super._();
}

/// @nodoc
abstract class _$$Thing_UserImplCopyWith<$Res> {
  factory _$$Thing_UserImplCopyWith(
          _$Thing_UserImpl value, $Res Function(_$Thing_UserImpl) then) =
      __$$Thing_UserImplCopyWithImpl<$Res>;
  @useResult
  $Res call({User field0});
}

/// @nodoc
class __$$Thing_UserImplCopyWithImpl<$Res>
    extends _$ThingCopyWithImpl<$Res, _$Thing_UserImpl>
    implements _$$Thing_UserImplCopyWith<$Res> {
  __$$Thing_UserImplCopyWithImpl(
      _$Thing_UserImpl _value, $Res Function(_$Thing_UserImpl) _then)
      : super(_value, _then);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Thing_UserImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as User,
    ));
  }
}

/// @nodoc

class _$Thing_UserImpl extends Thing_User {
  const _$Thing_UserImpl(this.field0) : super._();

  @override
  final User field0;

  @override
  String toString() {
    return 'Thing.user(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Thing_UserImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Thing_UserImplCopyWith<_$Thing_UserImpl> get copyWith =>
      __$$Thing_UserImplCopyWithImpl<_$Thing_UserImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Listing field0) listing,
    required TResult Function() comment,
    required TResult Function(User field0) user,
    required TResult Function(Post field0) post,
    required TResult Function() message,
    required TResult Function(Subreddit field0) subreddit,
    required TResult Function() award,
    required TResult Function(Multi field0) multi,
  }) {
    return user(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Listing field0)? listing,
    TResult? Function()? comment,
    TResult? Function(User field0)? user,
    TResult? Function(Post field0)? post,
    TResult? Function()? message,
    TResult? Function(Subreddit field0)? subreddit,
    TResult? Function()? award,
    TResult? Function(Multi field0)? multi,
  }) {
    return user?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Listing field0)? listing,
    TResult Function()? comment,
    TResult Function(User field0)? user,
    TResult Function(Post field0)? post,
    TResult Function()? message,
    TResult Function(Subreddit field0)? subreddit,
    TResult Function()? award,
    TResult Function(Multi field0)? multi,
    required TResult orElse(),
  }) {
    if (user != null) {
      return user(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Thing_Listing value) listing,
    required TResult Function(Thing_Comment value) comment,
    required TResult Function(Thing_User value) user,
    required TResult Function(Thing_Post value) post,
    required TResult Function(Thing_Message value) message,
    required TResult Function(Thing_Subreddit value) subreddit,
    required TResult Function(Thing_Award value) award,
    required TResult Function(Thing_Multi value) multi,
  }) {
    return user(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Thing_Listing value)? listing,
    TResult? Function(Thing_Comment value)? comment,
    TResult? Function(Thing_User value)? user,
    TResult? Function(Thing_Post value)? post,
    TResult? Function(Thing_Message value)? message,
    TResult? Function(Thing_Subreddit value)? subreddit,
    TResult? Function(Thing_Award value)? award,
    TResult? Function(Thing_Multi value)? multi,
  }) {
    return user?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Thing_Listing value)? listing,
    TResult Function(Thing_Comment value)? comment,
    TResult Function(Thing_User value)? user,
    TResult Function(Thing_Post value)? post,
    TResult Function(Thing_Message value)? message,
    TResult Function(Thing_Subreddit value)? subreddit,
    TResult Function(Thing_Award value)? award,
    TResult Function(Thing_Multi value)? multi,
    required TResult orElse(),
  }) {
    if (user != null) {
      return user(this);
    }
    return orElse();
  }
}

abstract class Thing_User extends Thing {
  const factory Thing_User(final User field0) = _$Thing_UserImpl;
  const Thing_User._() : super._();

  User get field0;

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Thing_UserImplCopyWith<_$Thing_UserImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Thing_PostImplCopyWith<$Res> {
  factory _$$Thing_PostImplCopyWith(
          _$Thing_PostImpl value, $Res Function(_$Thing_PostImpl) then) =
      __$$Thing_PostImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Post field0});
}

/// @nodoc
class __$$Thing_PostImplCopyWithImpl<$Res>
    extends _$ThingCopyWithImpl<$Res, _$Thing_PostImpl>
    implements _$$Thing_PostImplCopyWith<$Res> {
  __$$Thing_PostImplCopyWithImpl(
      _$Thing_PostImpl _value, $Res Function(_$Thing_PostImpl) _then)
      : super(_value, _then);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Thing_PostImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Post,
    ));
  }
}

/// @nodoc

class _$Thing_PostImpl extends Thing_Post {
  const _$Thing_PostImpl(this.field0) : super._();

  @override
  final Post field0;

  @override
  String toString() {
    return 'Thing.post(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Thing_PostImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Thing_PostImplCopyWith<_$Thing_PostImpl> get copyWith =>
      __$$Thing_PostImplCopyWithImpl<_$Thing_PostImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Listing field0) listing,
    required TResult Function() comment,
    required TResult Function(User field0) user,
    required TResult Function(Post field0) post,
    required TResult Function() message,
    required TResult Function(Subreddit field0) subreddit,
    required TResult Function() award,
    required TResult Function(Multi field0) multi,
  }) {
    return post(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Listing field0)? listing,
    TResult? Function()? comment,
    TResult? Function(User field0)? user,
    TResult? Function(Post field0)? post,
    TResult? Function()? message,
    TResult? Function(Subreddit field0)? subreddit,
    TResult? Function()? award,
    TResult? Function(Multi field0)? multi,
  }) {
    return post?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Listing field0)? listing,
    TResult Function()? comment,
    TResult Function(User field0)? user,
    TResult Function(Post field0)? post,
    TResult Function()? message,
    TResult Function(Subreddit field0)? subreddit,
    TResult Function()? award,
    TResult Function(Multi field0)? multi,
    required TResult orElse(),
  }) {
    if (post != null) {
      return post(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Thing_Listing value) listing,
    required TResult Function(Thing_Comment value) comment,
    required TResult Function(Thing_User value) user,
    required TResult Function(Thing_Post value) post,
    required TResult Function(Thing_Message value) message,
    required TResult Function(Thing_Subreddit value) subreddit,
    required TResult Function(Thing_Award value) award,
    required TResult Function(Thing_Multi value) multi,
  }) {
    return post(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Thing_Listing value)? listing,
    TResult? Function(Thing_Comment value)? comment,
    TResult? Function(Thing_User value)? user,
    TResult? Function(Thing_Post value)? post,
    TResult? Function(Thing_Message value)? message,
    TResult? Function(Thing_Subreddit value)? subreddit,
    TResult? Function(Thing_Award value)? award,
    TResult? Function(Thing_Multi value)? multi,
  }) {
    return post?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Thing_Listing value)? listing,
    TResult Function(Thing_Comment value)? comment,
    TResult Function(Thing_User value)? user,
    TResult Function(Thing_Post value)? post,
    TResult Function(Thing_Message value)? message,
    TResult Function(Thing_Subreddit value)? subreddit,
    TResult Function(Thing_Award value)? award,
    TResult Function(Thing_Multi value)? multi,
    required TResult orElse(),
  }) {
    if (post != null) {
      return post(this);
    }
    return orElse();
  }
}

abstract class Thing_Post extends Thing {
  const factory Thing_Post(final Post field0) = _$Thing_PostImpl;
  const Thing_Post._() : super._();

  Post get field0;

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Thing_PostImplCopyWith<_$Thing_PostImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Thing_MessageImplCopyWith<$Res> {
  factory _$$Thing_MessageImplCopyWith(
          _$Thing_MessageImpl value, $Res Function(_$Thing_MessageImpl) then) =
      __$$Thing_MessageImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Thing_MessageImplCopyWithImpl<$Res>
    extends _$ThingCopyWithImpl<$Res, _$Thing_MessageImpl>
    implements _$$Thing_MessageImplCopyWith<$Res> {
  __$$Thing_MessageImplCopyWithImpl(
      _$Thing_MessageImpl _value, $Res Function(_$Thing_MessageImpl) _then)
      : super(_value, _then);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$Thing_MessageImpl extends Thing_Message {
  const _$Thing_MessageImpl() : super._();

  @override
  String toString() {
    return 'Thing.message()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Thing_MessageImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Listing field0) listing,
    required TResult Function() comment,
    required TResult Function(User field0) user,
    required TResult Function(Post field0) post,
    required TResult Function() message,
    required TResult Function(Subreddit field0) subreddit,
    required TResult Function() award,
    required TResult Function(Multi field0) multi,
  }) {
    return message();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Listing field0)? listing,
    TResult? Function()? comment,
    TResult? Function(User field0)? user,
    TResult? Function(Post field0)? post,
    TResult? Function()? message,
    TResult? Function(Subreddit field0)? subreddit,
    TResult? Function()? award,
    TResult? Function(Multi field0)? multi,
  }) {
    return message?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Listing field0)? listing,
    TResult Function()? comment,
    TResult Function(User field0)? user,
    TResult Function(Post field0)? post,
    TResult Function()? message,
    TResult Function(Subreddit field0)? subreddit,
    TResult Function()? award,
    TResult Function(Multi field0)? multi,
    required TResult orElse(),
  }) {
    if (message != null) {
      return message();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Thing_Listing value) listing,
    required TResult Function(Thing_Comment value) comment,
    required TResult Function(Thing_User value) user,
    required TResult Function(Thing_Post value) post,
    required TResult Function(Thing_Message value) message,
    required TResult Function(Thing_Subreddit value) subreddit,
    required TResult Function(Thing_Award value) award,
    required TResult Function(Thing_Multi value) multi,
  }) {
    return message(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Thing_Listing value)? listing,
    TResult? Function(Thing_Comment value)? comment,
    TResult? Function(Thing_User value)? user,
    TResult? Function(Thing_Post value)? post,
    TResult? Function(Thing_Message value)? message,
    TResult? Function(Thing_Subreddit value)? subreddit,
    TResult? Function(Thing_Award value)? award,
    TResult? Function(Thing_Multi value)? multi,
  }) {
    return message?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Thing_Listing value)? listing,
    TResult Function(Thing_Comment value)? comment,
    TResult Function(Thing_User value)? user,
    TResult Function(Thing_Post value)? post,
    TResult Function(Thing_Message value)? message,
    TResult Function(Thing_Subreddit value)? subreddit,
    TResult Function(Thing_Award value)? award,
    TResult Function(Thing_Multi value)? multi,
    required TResult orElse(),
  }) {
    if (message != null) {
      return message(this);
    }
    return orElse();
  }
}

abstract class Thing_Message extends Thing {
  const factory Thing_Message() = _$Thing_MessageImpl;
  const Thing_Message._() : super._();
}

/// @nodoc
abstract class _$$Thing_SubredditImplCopyWith<$Res> {
  factory _$$Thing_SubredditImplCopyWith(_$Thing_SubredditImpl value,
          $Res Function(_$Thing_SubredditImpl) then) =
      __$$Thing_SubredditImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Subreddit field0});
}

/// @nodoc
class __$$Thing_SubredditImplCopyWithImpl<$Res>
    extends _$ThingCopyWithImpl<$Res, _$Thing_SubredditImpl>
    implements _$$Thing_SubredditImplCopyWith<$Res> {
  __$$Thing_SubredditImplCopyWithImpl(
      _$Thing_SubredditImpl _value, $Res Function(_$Thing_SubredditImpl) _then)
      : super(_value, _then);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Thing_SubredditImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Subreddit,
    ));
  }
}

/// @nodoc

class _$Thing_SubredditImpl extends Thing_Subreddit {
  const _$Thing_SubredditImpl(this.field0) : super._();

  @override
  final Subreddit field0;

  @override
  String toString() {
    return 'Thing.subreddit(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Thing_SubredditImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Thing_SubredditImplCopyWith<_$Thing_SubredditImpl> get copyWith =>
      __$$Thing_SubredditImplCopyWithImpl<_$Thing_SubredditImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Listing field0) listing,
    required TResult Function() comment,
    required TResult Function(User field0) user,
    required TResult Function(Post field0) post,
    required TResult Function() message,
    required TResult Function(Subreddit field0) subreddit,
    required TResult Function() award,
    required TResult Function(Multi field0) multi,
  }) {
    return subreddit(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Listing field0)? listing,
    TResult? Function()? comment,
    TResult? Function(User field0)? user,
    TResult? Function(Post field0)? post,
    TResult? Function()? message,
    TResult? Function(Subreddit field0)? subreddit,
    TResult? Function()? award,
    TResult? Function(Multi field0)? multi,
  }) {
    return subreddit?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Listing field0)? listing,
    TResult Function()? comment,
    TResult Function(User field0)? user,
    TResult Function(Post field0)? post,
    TResult Function()? message,
    TResult Function(Subreddit field0)? subreddit,
    TResult Function()? award,
    TResult Function(Multi field0)? multi,
    required TResult orElse(),
  }) {
    if (subreddit != null) {
      return subreddit(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Thing_Listing value) listing,
    required TResult Function(Thing_Comment value) comment,
    required TResult Function(Thing_User value) user,
    required TResult Function(Thing_Post value) post,
    required TResult Function(Thing_Message value) message,
    required TResult Function(Thing_Subreddit value) subreddit,
    required TResult Function(Thing_Award value) award,
    required TResult Function(Thing_Multi value) multi,
  }) {
    return subreddit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Thing_Listing value)? listing,
    TResult? Function(Thing_Comment value)? comment,
    TResult? Function(Thing_User value)? user,
    TResult? Function(Thing_Post value)? post,
    TResult? Function(Thing_Message value)? message,
    TResult? Function(Thing_Subreddit value)? subreddit,
    TResult? Function(Thing_Award value)? award,
    TResult? Function(Thing_Multi value)? multi,
  }) {
    return subreddit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Thing_Listing value)? listing,
    TResult Function(Thing_Comment value)? comment,
    TResult Function(Thing_User value)? user,
    TResult Function(Thing_Post value)? post,
    TResult Function(Thing_Message value)? message,
    TResult Function(Thing_Subreddit value)? subreddit,
    TResult Function(Thing_Award value)? award,
    TResult Function(Thing_Multi value)? multi,
    required TResult orElse(),
  }) {
    if (subreddit != null) {
      return subreddit(this);
    }
    return orElse();
  }
}

abstract class Thing_Subreddit extends Thing {
  const factory Thing_Subreddit(final Subreddit field0) = _$Thing_SubredditImpl;
  const Thing_Subreddit._() : super._();

  Subreddit get field0;

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Thing_SubredditImplCopyWith<_$Thing_SubredditImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Thing_AwardImplCopyWith<$Res> {
  factory _$$Thing_AwardImplCopyWith(
          _$Thing_AwardImpl value, $Res Function(_$Thing_AwardImpl) then) =
      __$$Thing_AwardImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Thing_AwardImplCopyWithImpl<$Res>
    extends _$ThingCopyWithImpl<$Res, _$Thing_AwardImpl>
    implements _$$Thing_AwardImplCopyWith<$Res> {
  __$$Thing_AwardImplCopyWithImpl(
      _$Thing_AwardImpl _value, $Res Function(_$Thing_AwardImpl) _then)
      : super(_value, _then);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$Thing_AwardImpl extends Thing_Award {
  const _$Thing_AwardImpl() : super._();

  @override
  String toString() {
    return 'Thing.award()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Thing_AwardImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Listing field0) listing,
    required TResult Function() comment,
    required TResult Function(User field0) user,
    required TResult Function(Post field0) post,
    required TResult Function() message,
    required TResult Function(Subreddit field0) subreddit,
    required TResult Function() award,
    required TResult Function(Multi field0) multi,
  }) {
    return award();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Listing field0)? listing,
    TResult? Function()? comment,
    TResult? Function(User field0)? user,
    TResult? Function(Post field0)? post,
    TResult? Function()? message,
    TResult? Function(Subreddit field0)? subreddit,
    TResult? Function()? award,
    TResult? Function(Multi field0)? multi,
  }) {
    return award?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Listing field0)? listing,
    TResult Function()? comment,
    TResult Function(User field0)? user,
    TResult Function(Post field0)? post,
    TResult Function()? message,
    TResult Function(Subreddit field0)? subreddit,
    TResult Function()? award,
    TResult Function(Multi field0)? multi,
    required TResult orElse(),
  }) {
    if (award != null) {
      return award();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Thing_Listing value) listing,
    required TResult Function(Thing_Comment value) comment,
    required TResult Function(Thing_User value) user,
    required TResult Function(Thing_Post value) post,
    required TResult Function(Thing_Message value) message,
    required TResult Function(Thing_Subreddit value) subreddit,
    required TResult Function(Thing_Award value) award,
    required TResult Function(Thing_Multi value) multi,
  }) {
    return award(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Thing_Listing value)? listing,
    TResult? Function(Thing_Comment value)? comment,
    TResult? Function(Thing_User value)? user,
    TResult? Function(Thing_Post value)? post,
    TResult? Function(Thing_Message value)? message,
    TResult? Function(Thing_Subreddit value)? subreddit,
    TResult? Function(Thing_Award value)? award,
    TResult? Function(Thing_Multi value)? multi,
  }) {
    return award?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Thing_Listing value)? listing,
    TResult Function(Thing_Comment value)? comment,
    TResult Function(Thing_User value)? user,
    TResult Function(Thing_Post value)? post,
    TResult Function(Thing_Message value)? message,
    TResult Function(Thing_Subreddit value)? subreddit,
    TResult Function(Thing_Award value)? award,
    TResult Function(Thing_Multi value)? multi,
    required TResult orElse(),
  }) {
    if (award != null) {
      return award(this);
    }
    return orElse();
  }
}

abstract class Thing_Award extends Thing {
  const factory Thing_Award() = _$Thing_AwardImpl;
  const Thing_Award._() : super._();
}

/// @nodoc
abstract class _$$Thing_MultiImplCopyWith<$Res> {
  factory _$$Thing_MultiImplCopyWith(
          _$Thing_MultiImpl value, $Res Function(_$Thing_MultiImpl) then) =
      __$$Thing_MultiImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Multi field0});
}

/// @nodoc
class __$$Thing_MultiImplCopyWithImpl<$Res>
    extends _$ThingCopyWithImpl<$Res, _$Thing_MultiImpl>
    implements _$$Thing_MultiImplCopyWith<$Res> {
  __$$Thing_MultiImplCopyWithImpl(
      _$Thing_MultiImpl _value, $Res Function(_$Thing_MultiImpl) _then)
      : super(_value, _then);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Thing_MultiImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Multi,
    ));
  }
}

/// @nodoc

class _$Thing_MultiImpl extends Thing_Multi {
  const _$Thing_MultiImpl(this.field0) : super._();

  @override
  final Multi field0;

  @override
  String toString() {
    return 'Thing.multi(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Thing_MultiImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$Thing_MultiImplCopyWith<_$Thing_MultiImpl> get copyWith =>
      __$$Thing_MultiImplCopyWithImpl<_$Thing_MultiImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Listing field0) listing,
    required TResult Function() comment,
    required TResult Function(User field0) user,
    required TResult Function(Post field0) post,
    required TResult Function() message,
    required TResult Function(Subreddit field0) subreddit,
    required TResult Function() award,
    required TResult Function(Multi field0) multi,
  }) {
    return multi(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Listing field0)? listing,
    TResult? Function()? comment,
    TResult? Function(User field0)? user,
    TResult? Function(Post field0)? post,
    TResult? Function()? message,
    TResult? Function(Subreddit field0)? subreddit,
    TResult? Function()? award,
    TResult? Function(Multi field0)? multi,
  }) {
    return multi?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Listing field0)? listing,
    TResult Function()? comment,
    TResult Function(User field0)? user,
    TResult Function(Post field0)? post,
    TResult Function()? message,
    TResult Function(Subreddit field0)? subreddit,
    TResult Function()? award,
    TResult Function(Multi field0)? multi,
    required TResult orElse(),
  }) {
    if (multi != null) {
      return multi(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Thing_Listing value) listing,
    required TResult Function(Thing_Comment value) comment,
    required TResult Function(Thing_User value) user,
    required TResult Function(Thing_Post value) post,
    required TResult Function(Thing_Message value) message,
    required TResult Function(Thing_Subreddit value) subreddit,
    required TResult Function(Thing_Award value) award,
    required TResult Function(Thing_Multi value) multi,
  }) {
    return multi(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Thing_Listing value)? listing,
    TResult? Function(Thing_Comment value)? comment,
    TResult? Function(Thing_User value)? user,
    TResult? Function(Thing_Post value)? post,
    TResult? Function(Thing_Message value)? message,
    TResult? Function(Thing_Subreddit value)? subreddit,
    TResult? Function(Thing_Award value)? award,
    TResult? Function(Thing_Multi value)? multi,
  }) {
    return multi?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Thing_Listing value)? listing,
    TResult Function(Thing_Comment value)? comment,
    TResult Function(Thing_User value)? user,
    TResult Function(Thing_Post value)? post,
    TResult Function(Thing_Message value)? message,
    TResult Function(Thing_Subreddit value)? subreddit,
    TResult Function(Thing_Award value)? award,
    TResult Function(Thing_Multi value)? multi,
    required TResult orElse(),
  }) {
    if (multi != null) {
      return multi(this);
    }
    return orElse();
  }
}

abstract class Thing_Multi extends Thing {
  const factory Thing_Multi(final Multi field0) = _$Thing_MultiImpl;
  const Thing_Multi._() : super._();

  Multi get field0;

  /// Create a copy of Thing
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$Thing_MultiImplCopyWith<_$Thing_MultiImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
